<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>缓存机制</title>
    <link href="/2025/01/15/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/01/15/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><div class="note note-info">            <p>注意！！！！</p><p>缓存的工作机制：</p><p>由一个内存地址，判断其是否在缓存中</p>          </div><p>考虑一个计算机系统，其中每一个存储器地址有$m$位，形成$M&#x3D;2^m$个不同的地址，这样一个机器的高速缓存被组织成一个有$S&#x3D;2^s$个高速缓存组<code>cache set</code>的数组，每个组包含<code>E</code>个高速缓存行<code>cache line</code>，每个行由一个$B&#x3D;2^b$字节的数据块<code>block</code>组成，在行中，一个有效位<code>valid bit</code>指明这个行是否包含有意义的信息，还有$t&#x3D;m-(s+b)$个标记位<code>tag bit</code>，它们唯一地标识存储在这个高速缓存行中的块。</p><p>$\textcolor{red}{一般而言，高速缓存的结构可以用元组(S,E,B,m)来描述}$</p><p>$\textcolor{red}{高速缓存的容量：C&#x3D;S<em>E</em>B}$</p><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p>根据每个组的高速缓存行数E，高速缓存被分为不同的类，每个组只有一行的高速缓存称为$\textcolor{red}{直接映射高速缓存}$。</p><h2 id="组相连"><a href="#组相连" class="headerlink" title="组相连"></a>组相连</h2><p>每个组<code>set</code>有多个行，每个行为一路<code>way</code>，但是需要依次组中的所有行来匹配标识位。</p><h2 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h2><p>没有组索引位，全都是一个组，地址只被划分成一个标记位和一个块偏移。</p><h2 id="组相连缓存示例"><a href="#组相连缓存示例" class="headerlink" title="组相连缓存示例"></a>组相连缓存示例</h2><p>考虑一个<code>64GB</code>内存大小的计算机系统，<code>L1 cache</code>容量<code>32KB</code>，使用<code>64</code>组<code>8</code>路组相连方式，每个缓存行<code>64</code>字节</p><div class="note note-info">            <p>$C&#x3D;S<em>E</em>B&#x3D;64<em>8</em>64&#x3D;32768BTYE&#x3D;32KB$</p>          </div><ul><li><p>内存<code>64GB</code>，共需要<code>36</code>位比特来进行寻址</p></li><li><p><code>64</code>组，则需要占用<code>6</code>个比特</p></li><li><p>每个缓存行有<code>64</code>字节，也需要<code>6</code>个比特</p></li><li><p><code>TAG</code>位则需要$36-6-6&#x3D;24$个比特</p></li><li><p>在至于缓存在哪个路中，则需要遍历</p></li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">+---------------------+---+-------+------+<br>|        TAG          | V | index |offset|<br>+---------------------+---+-------+------+<br></code></pre></td></tr></table></figure><h3 id="CPU读数据——缓存miss——填充缓存"><a href="#CPU读数据——缓存miss——填充缓存" class="headerlink" title="CPU读数据——缓存miss——填充缓存"></a>CPU读数据——缓存miss——填充缓存</h3><p>当<code>CPU</code>发起一个地址访问操作时，会首先向缓存发出一个地址，比如：<code>0x8000200E4</code>，对应二进制位为<code>1000 0000 0000 0000 0010 0000 | 000011 | 100100</code></p><p>缓存拿到这个地址后，首先拿出<code>index</code>位段的比特，这里是<code>000011</code>，确定<strong>组索引</strong></p><p>然后<strong>遍历</strong>这个组中所有的路，对比有效位<code>V</code>和<code>TAG</code>位，这里的<code>TAG</code>是寻址地址的高<code>24</code>位，也就是<code>1000 0000 0000 0000 0010 0000</code>，将其与每一路的<code>TAG</code>位进行对比，如果存在<code>V</code>有效并且<code>TAG</code>一致，则为缓存<code>hit</code>，<code>hit</code>之后根据<code>offset</code>位段获取对应字节即可</p><p>否则为缓存<code>miss</code>，这里考虑<code>miss</code>的情况</p><p>当缓存<code>miss</code>时，<code>CPU</code>向主存进行内存访问，其访问单位为<code>64</code>字节，也就是一个缓存行，<code>CPU</code>将获得主存上对应内存地址（以64字节对齐的那一整个缓存行大小的区域）的内容<code>DATA</code>和地址都发给缓存</p><p>缓存根据索引位<code>index</code>的位段确定组编号，在对应的组中使用某种策略（如LRU等）对某个缓存行进行替换，即将数据填充到缓存行内，将地址的高<code>24</code>bits填充到<code>TAG</code>中，<code>V</code>填充为1，标记为有效，并将对应<code>offset</code>的字节发给<code>CPU</code></p><p>到此完成一次<code>CPU</code>读数据操作</p><h2 id="缓存替换策略——Replacement-Algorithm"><a href="#缓存替换策略——Replacement-Algorithm" class="headerlink" title="缓存替换策略——Replacement Algorithm"></a>缓存替换策略——Replacement Algorithm</h2><h3 id="LRU——Least-Recently-Used"><a href="#LRU——Least-Recently-Used" class="headerlink" title="LRU——Least Recently Used"></a>LRU——Least Recently Used</h3><p>最近最少使用算法：当缓存行满且需要加载新数据时，最近最长时间未使用的数据将被替换</p><h4 id="Full-LRU"><a href="#Full-LRU" class="headerlink" title="Full LRU"></a>Full LRU</h4><p>缓存需要跟踪访问数据的顺序，由于缓存行只可能在同组之内，即不同的路之间随机放置，那么每一组需要维护一个组内不同路的访问顺序</p><p>如果以4路组相连为例，4路表示一个组内有四个缓存行，访问的数据可以是这四个缓存行之一，那么这四个缓存行的访问顺序可以是<strong>路数的阶乘</strong>，如4路则是$4!&#x3D;24$，24需要5个比特位来表示</p><div class="note note-info}">            <p>通常，对于具有<code>n</code>种排列方式的缓存，每组需要的<code>LRU</code>位的数量是<code>n</code>阶乘的对数（以<code>2</code>为底）</p>          </div><p>当访问数据并且发生缓存命中，相关组中的<code>LRU</code> 位将更新以反映新顺序</p><p>如果缓存已满且发生缓存未命中，则需要对<code>LRU</code>位进行解码，逐出该顺序中的最后一个缓存行，并更新<code>LRU</code>位以反映新顺序</p><p>优势：当最近使用的数据可能很快再次使用时，表现较好</p><p>劣势：开销相当大，使用较少</p><h4 id="Tree-Based-Pseudo-LRU"><a href="#Tree-Based-Pseudo-LRU" class="headerlink" title="Tree-Based Pseudo LRU"></a>Tree-Based Pseudo LRU</h4><p>使用二叉树树来近似<code>LRU</code></p><p>树的结点都表示一个比特位，树的叶子表示一组缓存行</p><p>每个位的值表示最近使用的数据的路径：</p><ul><li>0表示左子树较新</li><li>1表示右子树较新</li></ul><div class="note note-info}">            <p>占用的<code>LRU</code>位数为路数减一</p>          </div><p>当访问缓存行并且请求地址在缓存行中，算法会沿着根到该行的路径更新树位，以将其标记位最近使用的数据</p><p>当请求的缓存行不在缓存中，树算法会沿相反方向（比如一个结点是0，表示左侧较新，但是我去右边较久的地方）遍历树，以查找最近最少使用的数据逐出，更新树位数</p><h4 id="Not-Recently-Used"><a href="#Not-Recently-Used" class="headerlink" title="Not Recently Used"></a>Not Recently Used</h4><p>最近未使用算法：在每个缓存行增加一个位<code>NRU</code>，为0表示相关缓存行最近使用过，为1表示最近未使用过</p><p>最开始，所有<code>NRU</code>都为1，表示都未使用过，访问某个缓存行时，将其标记为1，表示最近使用过</p><p>发生缓存未命中时，系统查找组中第一个仍为1的缓存行，将其逐出，加载新数据，并将<code>NRU</code>位翻转为0，标记其最近使用过</p><p>如果发生缓存未命中，并且该组中只有一个缓存行的<code>NRU</code>值为1，则该行中的数据被替换，其<code>NRU</code>位置0，并且该组中其他所有的缓存行<code>NRU</code>位都翻转为1，表示现在该组中的其他缓存行都被视为最近未使用过</p><p>在某组中所有<code>NRU</code>位为0的情况下，该组中的所有缓存行的<code>NRU</code>位都被翻转为1</p><h4 id="Quad-Age-LRU"><a href="#Quad-Age-LRU" class="headerlink" title="Quad-Age LRU"></a>Quad-Age LRU</h4><p>四倍年龄LRU算法：通常用于具有更高关联性的缓存，如L3缓存，每个缓存行都有额外的两位<code>AGE</code>，表示其与同一组中其他缓存行相比的相对年龄，年龄较低的缓存行意味着比年龄较高的缓存行访问更近</p><p>最初，所有缓存行的<code>AGE</code>位均置为1，发生缓存命中时，根据其当前年龄进行修改，值2或3将变为1，值1将减少为0</p><p>如果在访问，命中或未命中后，没有年龄为3的缓存行，则所有缓存行的年龄加一，重复此操作，直到找到一个年龄为3的缓存行</p><p>当缓存未命中时，第一个年龄为3的缓存行将被逐出，新数据被写入，<code>AGE</code>被更新为1</p><h3 id="LFU——Least-Frequently-Used"><a href="#LFU——Least-Frequently-Used" class="headerlink" title="LFU——Least Frequently Used"></a>LFU——Least Frequently Used</h3><p>最不常用算法：跟踪数据访问频率，并将最长使用的数据保留在缓存中</p><p>因此需要为每个缓存行维护一个频率计数器，该计数器表示该缓存行进行读写的次数</p><p>当需要逐出数据时，将替换频率最低的行</p><h3 id="RR——Random-Replacement"><a href="#RR——Random-Replacement" class="headerlink" title="RR——Random Replacement"></a>RR——Random Replacement</h3><p>随机替换算法：随机选择任何缓存行进行替换</p><p>优势：适用于不可预测系统，实现简单</p><p>劣势：在相关性较强的系统中表现不佳</p><h3 id="FIFO——First-In-First-Out"><a href="#FIFO——First-In-First-Out" class="headerlink" title="FIFO——First-In First-Out"></a>FIFO——First-In First-Out</h3><p>先入先出算法：需要逐出数据时，将缓存行按加载顺序逐出，无论访问次数和访问频率</p><p>优势：简单实现，开销最小</p><p>劣势：某些情况下，性能不佳</p><h3 id="MRU——Most-Recently-Used"><a href="#MRU——Most-Recently-Used" class="headerlink" title="MRU——Most Recently Used"></a>MRU——Most Recently Used</h3><p>最近使用算法：需要逐出数据时，将最近使用的数据逐出（<code>LRU</code>的相反操作）</p><p>优势：适用于旧数据比新数据更可能被访问的系统（比如大文件的重复访问）</p><p>劣势：其他情况性能不佳</p><h3 id="AR——Adaptive-Replacement"><a href="#AR——Adaptive-Replacement" class="headerlink" title="AR——Adaptive Replacement"></a>AR——Adaptive Replacement</h3><p>自适应替换算法：根据工作负载的访问模式，以及每种算法的实际命中率和未命中率在两种算法之间动态平衡</p><p>实现方式是将缓存集分组，通常分为三组。</p><p>比如第一组用<code>LRU</code>，第二组用<code>MRU</code>，第三组自适应，根据策略将其改为上述两种算法之一</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>嵌入式</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宏的展开规则</title>
    <link href="/2025/01/15/%E5%AE%8F%E7%9A%84%E5%B1%95%E5%BC%80%E8%A7%84%E5%88%99/"/>
    <url>/2025/01/15/%E5%AE%8F%E7%9A%84%E5%B1%95%E5%BC%80%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="宏的展开规则"><a href="#宏的展开规则" class="headerlink" title="宏的展开规则"></a>宏的展开规则</h1><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>最基本的替换规则，就是文本替换</p><h2 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h2><p>宏可以带参数，并且在展开后使用这些参数</p><h2 id="字符串化"><a href="#字符串化" class="headerlink" title="字符串化"></a>字符串化</h2><p><code>#</code>可以将宏参数转化为字符串</p><h2 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h2><p><code>##</code>可以将两个参数连接起来，变成一个新符号，注意不是字符串</p><div class="note note-info}">            <p>在使用了<code>#</code>或<code>##</code>的宏中，如果宏的参数也是一个宏，则会阻止这个宏展开，为了保证参数宏优先展开，需要多嵌套一层宏</p>          </div><p>e.g:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Stringify(A) _Stringify(A)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Stringify(A) #A</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Concat(A, B) _Concat(A, B)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _Concat(A, B) A##B</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, Stringify(Concat(Hel, lo)));<br><span class="hljs-comment">/* 展开顺序如下：</span><br><span class="hljs-comment">   Concat也是一个宏，并且是内层的，它被优先展开</span><br><span class="hljs-comment">   1.Stringify(_Concat(Hel, lo))  # 注，如果Hel和lo也是宏的话，这一步也会展开</span><br><span class="hljs-comment">   2.Stringify(Hello)</span><br><span class="hljs-comment">   3.&quot;Hello&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="嵌套宏展开"><a href="#嵌套宏展开" class="headerlink" title="嵌套宏展开"></a>嵌套宏展开</h2><p>宏展开时会递归的展开嵌套的宏定义</p><div class="note note-info}">            <p>当预处理器遇到一个宏调用时，它会用宏定义的内容替换宏调用</p><p>对于参数化的宏，预处理器会尝试用传递的参数替换掉宏定义中的参数</p><p>默认情况下，宏参数的替换是立刻发生的，在展开过程中，遇到该宏名时参数首先被替换，然后宏体会被继续展开</p><p>在展开一个宏时，如果参数本身也是宏，通常会进一步展开</p>          </div><ol><li>展开内层宏参数，再展开外层宏参数</li><li>如果某个形参前面有<code>#</code>运算符，那么先不展开该形参对应的实参，而是直接把这个实参变为字符串</li><li>如果某个形参前面有<code>#@</code>，则调用此宏定义时，不展开该形参对应的实参，而是直接把这个实参变为字符</li><li>如果某个形参前面或后面有<code>##</code>，则调用此宏定义时，不展开该形参对应得实参，而是将该运算符前后都实参连接起来作为一个新符号</li></ol>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>嵌入式</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剖析内存屏障</title>
    <link href="/2025/01/15/%E5%89%96%E6%9E%90%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <url>/2025/01/15/%E5%89%96%E6%9E%90%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="剖析内存屏障"><a href="#剖析内存屏障" class="headerlink" title="剖析内存屏障"></a>剖析内存屏障</h1><h2 id="理解乱序"><a href="#理解乱序" class="headerlink" title="理解乱序"></a>理解乱序</h2><p>乱序可以分为两个大类，即：软件和硬件</p><ul><li><p>软件</p><ul><li>编译器优化</li><li>编译时</li><li>目的通常是为了更有效率的使用寄存器</li><li>多线程时可见</li></ul></li><li><p>硬件</p><ul><li>CPU乱序执行</li><li>运行时</li><li>目的通常是为了并行执行互相无干扰的指令，以节省时间</li><li>通常在多核系统中可见</li></ul></li></ul><p>这两种情况都会导致程序的执行顺序与程序员书写的顺序不一致，特别是多线程环境中，逻辑的正确性可能依赖于内存访问顺序</p><p>这是一个出错的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// thread 1</span><br><span class="hljs-keyword">while</span>( !ok );<br><span class="hljs-keyword">do</span>(x);<br><br><span class="hljs-comment">// thread 2</span><br>x = <span class="hljs-number">42</span>;<br>ok = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><code>ok</code>作为全局变量，被初始化为<code>0</code>，现在两线程并发，有可能<code>ok</code>的赋值被乱序到<code>x = 42</code>之前（之所以会出现这种原因，是由于编译器发现<code>x</code>和<code>ok</code>的赋值没有依赖关系，它并不知道另一个线程对其有依赖），那么，线程1就判断条件通过，执行<code>do(x)</code>，他的实参<code>x</code>就不是<code>42</code>了，这种错误非常难以发现</p><h2 id="经典示例"><a href="#经典示例" class="headerlink" title="经典示例"></a>经典示例</h2><div class="note note-primary">            <p>注意如下场景：</p><p>多线程环境 or 多进程共享内存时</p><p>一个线程&#x2F;进程操作一个共享内容后，设置一个标志位，用以通知其余线程&#x2F;进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">shared_variable = new_value;<br>flag = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>在编译器和处理器中，由于<code>flag</code>和<code>shared_variable</code>两个变量没有依赖关系，因此有可能发生重排，也就是<code>flag = 1</code>在<code>shared_variable = new_value</code>之前发生，这就会导致，其他进程&#x2F;线程以为<code>shared_variable</code>已经是新值了，但其实这个赋值还没有发生，此时导致故障</p>          </div><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><div class="note note-info">            <p>通常，内存屏障应用于并发无锁编程</p>          </div><p>理解了乱序之后，就需要想办法解决由此产生的问题</p><p>既然乱序有两种原因导致，那么内存屏障也应该有两种</p><ul><li>编译器屏障</li><li>CPU屏障</li></ul><h3 id="编译器屏障"><a href="#编译器屏障" class="headerlink" title="编译器屏障"></a>编译器屏障</h3><p>编译器屏障是用来指挥编译器的，不会产生任何运行时的指令</p><p>它仅仅是用来告诉编译器，不要重排屏障前后的指令</p><p>经典的编译器屏障就是<code>barrier</code></p><p>其实现可能就是单纯的这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> barrier() __asm__ __volatile__(<span class="hljs-string">&quot;&quot;</span>:::<span class="hljs-string">&quot;memory&quot;</span>);</span><br></code></pre></td></tr></table></figure><p>这句代码在编译完成后，不会产生任何运行时指令，但是可以有效隔绝屏障前后的指令乱序</p><div class="note note-info">            <p>by the way, <code>volatile</code>关键字可以起到同样的作用</p><p>但仍有细微的差异：<code>volatile</code>会绑定该变量，这导致这个变量永远不能被寄存器缓存，每次访问该变量都会强制从内存中取值。而<code>barrier</code>只会影响该语句所在的上下文</p>          </div><p>那么，<code>barrier</code>本身是完美的么？</p><p>也不尽然</p><p><code>barrier</code>会使当前上下文的所有寄存器缓存失效，这意味着所有的寄存器都需要从内存中更新内容，但是这可能是不必要的，有时我们可能只关心某一个寄存器中的内容</p><p>这就引出了<code>ACCESS_ONCE</code>!!!!!</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</span><br></code></pre></td></tr></table></figure><p>虽然这里仍使用了<code>volatile</code>，但却是在一个临时变量中，这意味着仅在调用<code>ACCESS_ONCE</code>的时候抑制编译器优化，其他时候访问变量仍会启用编译器优化</p><p>在GCC4.6和4.7版本中有一个bug，如果<code>ACCESS_ONCE</code>的参数是非标量（就是结构体，联合体，数组等），<code>volatile</code>标记会被编译器移除，例如通过<code>ACCESS_ONCE</code>访问<code>pte_t</code>类型变量会导致错误</p><div class="note note-info}">            <p>标量类型：只包含单一数值的简单数据类型，包括整形，浮点，指针</p><p>向量类型：包含多个数值，数组，结构体，联合体</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pte;<br>&#125; <span class="hljs-type">pte_t</span>;<br><span class="hljs-type">pte_t</span> p = ACCESS_ONCE(pte);  <span class="hljs-comment">// 报错！！！</span><br></code></pre></td></tr></table></figure><p>由此，Linux引入了<code>READ_ONCE</code>和<code>WRITE_ONCE</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __READ_ONCE(x, check) \</span><br><span class="hljs-meta">(&#123;                                    \</span><br><span class="hljs-meta">    union &#123; typeof(x) __val; char __c[1]; &#125; __u; \</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (check)                        \</span><br><span class="hljs-meta">        __read_once_size(&amp;(x), __u.__c, sizeof(x)); \</span><br><span class="hljs-meta">    <span class="hljs-keyword">else</span>                                \</span><br><span class="hljs-meta">        __read_once_size_nocheck(&amp;(x), __u.__c, sizeof(x)); \</span><br><span class="hljs-meta">    smp_read_barrier_depends(); <span class="hljs-comment">/* Enforce dependency ordering from x */</span> \</span><br><span class="hljs-meta">    __u.__val;                        \</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> READ_ONCE(x) __READ_ONCE(x, 1)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __READ_ONCE_SIZE    \</span><br><span class="hljs-meta">(&#123;                                    \</span><br><span class="hljs-meta">    switch (size) &#123;            \</span><br><span class="hljs-meta">    case 1: *(__u8 *)res = *(volatile __u8 *)p; break;   \</span><br><span class="hljs-meta">    case 2: *(__u16 *)res = *(volatile __u16 *)p; break; \</span><br><span class="hljs-meta">    case 4: *(__u32 *)res = *(volatile __u32 *)p; break; \</span><br><span class="hljs-meta">    case 8: *(__u64 *)res = *(volatile __u64 *)p; break; \</span><br><span class="hljs-meta">    default:                        \</span><br><span class="hljs-meta">        barrier();                    \</span><br><span class="hljs-meta">        __builtin_memcpy((void *)res, (const void *)p, size); \</span><br><span class="hljs-meta">        barrier();                    \</span><br><span class="hljs-meta">    &#125;                                \</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-type">static</span> __always_inline<br><span class="hljs-type">void</span> __read_once_size(<span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> *p, <span class="hljs-type">void</span> *res, <span class="hljs-type">int</span> size)<br>&#123;<br>    __READ_ONCE_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心思路是：将向量类型转化为标量类型，然后再使用<code>ACCESS_ONCE</code>的方式，<code>WRITE_ONCE</code>同理</p><h3 id="CPU屏障"><a href="#CPU屏障" class="headerlink" title="CPU屏障"></a>CPU屏障</h3><h4 id="内存操作序"><a href="#内存操作序" class="headerlink" title="内存操作序"></a>内存操作序</h4><p>这是通常理解的内存屏障，在<code>CPU</code>运行时起作用，既然是内存乱序，针对内存的操作一共只有读和写两种操作。</p><p>将读操作记为<code>Load</code>，将写操作记为<code>Store</code>，那么内存重排的次序排列组合共有四种：</p><ul><li><code>StoreStore</code>：两次写入</li><li><code>StoreLoad</code>：先写入再加载（这个代价最大，一般实现为全屏障）</li><li><code>LoadLoad</code>：两次加载</li><li><code>LoadStore</code>：先加载再写入</li></ul><div class="note note-info">            <p>其中，<code>STORESTORE</code>和<code>STORELOAD</code>两种重排涉及<code>store buffer</code></p><p><code>LOADLOAD</code>涉及<code>invalidation queue</code></p>          </div><h4 id="存储缓冲区"><a href="#存储缓冲区" class="headerlink" title="存储缓冲区"></a>存储缓冲区</h4><p><code>CPU0</code>执行<code>STORE</code>操作时，需要通知其他<code>CPU</code>缓存失效，这是由<code>MESI</code>机制决定的</p><p>但是这会造成<code>CPU0</code>在发出<code>Invalidate</code>到收到其他<code>CPU</code>的<code>Acknowledgement</code>这段时间进行忙等，由于<code>STORE</code>操作本质上是异步的，这段忙等完全可以让<code>CPU0</code>用来做其他事情</p><p>因此硬件工程师们设计了一个存储缓冲区<code>store buffer</code>，<code>CPU</code>可以直接写入<code>store buffer</code>然后去做其他事情</p><p>这个<code>store buffer</code>的位置在<code>CPU</code>和<code>L1 cache</code>之间，只有<code>STORE</code>操作会往里面写入数据，<code>CPU</code>发送<code>Invalidate</code>指令，将新数据写入<code>store buffer</code>，然后<code>CPU</code>继续执行其他操作，<code>store buffer</code>则等待收到其他<code>CPU</code>的<code>Acknowledgement</code>后，将其中的内容放入缓存行</p><div class="note note-danger">            <p>注意，<code>MESI</code>指令是针对缓存的，<code>store buffer</code>不是缓存，因此不受<code>MESI</code>影响，这会导致，在收到其他<code>CPU</code>的<code>Acknowledgement</code>回复之前，这个数据只在当前<code>CPU</code>的<code>store buffer</code>中存在</p>          </div><p>e.g: 查看如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a, b均为全局变量，a仅在cpu1的缓存行，b仅在cpu0的缓存行，其值均为0</span><br>a = <span class="hljs-number">1</span>;<br>b = a + <span class="hljs-number">1</span>;<br>assert(b == <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>假设<code>CPU0</code>执行上述代码：</p><ol><li><code>CPU0</code>执行<code>a = 1</code>，但是<code>a</code>不在<code>CPU0</code>的缓存行中，发生缓存未命中，<code>CPU0</code>发出<code>MESI</code>的<code>read invalidate</code>消息，<code>CPU0</code>将<code>a</code>的值<code>1</code>写入到<code>CPU0</code>的<code>store buffer</code>中</li><li><code>CPU1</code>收到<code>read invalidate</code>消息，回复<code>CPU0</code>读响应消息<code>read response</code>和应答消息<code>Acknowledgement</code>，读响应消息将<code>CPU1</code>的缓存中的<code>a</code>置为0</li><li><code>CPU0</code>执行<code>b = a + 1</code>，<code>CPU0</code>收到了<code>CPU1</code>的读响应<code>read response</code>消息，其中变量<code>a</code>的值被描述为<code>0</code>，因此，<code>CPU0</code>的缓存行中，变量<code>a</code>的值被更新为<code>0</code></li><li><code>CPU0</code>执行<code>b = a + 1</code>，然后<code>a</code>的值为<code>0</code>，因此<code>b</code>的值为<code>1</code></li><li>断言失败</li></ol><p>导致上述问题的关键在于，<code>CPU0</code>的存储缓冲区和缓存行中缓存了相同的变量，他们是无需同步的</p><p>由此需要改进存取缓冲区的机制，即：</p><p><code>CPU</code>执行完存储<code>STORE</code>操作后，将值写入到<code>store buffer</code>，然后继续执行其他指令，当<code>CPU</code>在存储之后执行加载<code>LOAD</code>操作时，会先去<code>store buffer</code>里面查找，再去缓存行查找。如果<code>store buffer</code>里面有对应的数据，则加载操作直接使用<code>store buffer</code>中的数据，而不是缓存行中的数据。</p><h4 id="StoreStore乱序"><a href="#StoreStore乱序" class="headerlink" title="StoreStore乱序"></a>StoreStore乱序</h4><p>如上所述，<code>store buffer</code>可以加快<code>CPU</code>执行速度，然而，在<code>SMP</code>系统中，如果多个线程&#x2F;进程在多个<code>CPU</code>上并行时，<code>store buffer</code>会导致<code>STORESTORE</code>乱序</p><p>e.g:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    a = <span class="hljs-number">1</span>;<br>    b = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-comment">// CPU0</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">while</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    assert(a == <span class="hljs-number">1</span>);<br>&#125; <span class="hljs-comment">// CPU1</span><br></code></pre></td></tr></table></figure><p>全局变量<code>a</code>，<code>b</code>的初始值为0，最初，变量<code>a</code>仅在<code>CPU1</code>的缓存行中，变量<code>b</code>仅在<code>CPU0</code>的缓存行中，假定<code>CPU0</code>执行<code>foo</code>，<code>CPU1</code>执行<code>bar</code>，运行过程为：</p><ol><li><code>CPU0</code>执行<code>a = 1</code>，因为变量<code>a</code>不在<code>CPU0</code>的缓存行里面，因此<code>CPU0</code>将<code>a</code>的新值放在其存储缓冲区<code>store buffer</code>，并发出读无效<code>read invalidate</code>信息</li><li><code>CPU1</code>执行<code>while(b == 0) continue</code>这一句，但是<code>CPU1</code>没有变量<code>b</code>的缓存，因此发出读<code>read</code>信息</li><li><code>CPU0</code>执行<code>b = 1</code>，它已经拥有该缓存行（或者说，该缓存行已经处于<code>modified</code>或<code>exclusive</code>状态），因此<code>CPU0</code>将<code>b</code>的新值写入其缓存行中</li><li><code>CPU0</code>收到读取<code>read</code>消息，并将包含更新过后的<code>b</code>值的缓存行传输到<code>CPU1</code>，同时在其缓存行中将其标记为<code>shared</code></li><li><code>CPU1</code>接收到包含<code>b</code>的高速缓存行，并将其放在<code>CPU1</code>的高速缓存行中</li><li><code>CPU1</code>现在可以通过语句<code>while(b == 0) continue;</code>，因为<code>b</code>现在是<code>1</code>了</li><li><code>CPU1</code>现在执行断言<code>assert(1 == a)</code>，发现<code>a</code>的值为<code>0</code>，断言失败</li><li><code>CPU1</code>收到读无效<code>read invalidate</code>消息，并将包含<code>a</code>的缓存行传输到<code>CPU0</code>，并从其缓存中使该缓存行无效，但为时已晚，断言已经执行过了</li><li><code>CPU0</code>接收包含<code>a</code>的缓存行，并用<code>store buffer</code>中<code>a</code>的新值修改，对于<code>CPU0</code>而言，缓存行中的<code>a</code>已经成为新的，<code>Modified</code>状态的值，<code>CPU0</code>无异常，但是成为<code>CPU1</code>断言失败的受害者</li></ol><p>这导致了一个现象，从<code>CPU1</code>的角度看，<code>CPU0</code>中出现了内存重排序，然而在<code>CPU0</code>的视角中，它是正常执行的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// CPU0 view</span><br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// CPU1 view</span><br>b = <span class="hljs-number">1</span>;<br>a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>两条<code>STORE</code>指令被重排，因此称为<code>STORESTORE</code></p><p>针对这个问题，就需要使用内存屏障</p><p>问题的关键在于：两条写指令，前一条不在当前核的缓存中，后一条在，那么<code>a = 1</code>时，<code>a</code>被放在<code>store buffer</code>中，<code>b = 1</code>由于在缓存中，可以直接执行，而不会收到来自其他<code>CPU</code>的<code>invalidate acknowledge</code>信息</p><div class="note note-info}">            <p>引入<code>store buffer</code>后，多个<code>CPU</code>上并行运行的线程或进程的执行逻辑之间就有了联系，但是，编译器和硬件很难感受到这种逻辑联系，<strong>只有软件程序员知道</strong>，这就是内存屏障的用武之地！</p>          </div><p>内存屏障的指令由硬件实现，不同架构的<code>CPU</code>有不同的内存屏障指令，内存屏障指令需要程序员在代码中显式调用，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    a = <span class="hljs-number">1</span>;<br>    smp_mb();<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">while</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    assert(a == <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的内存屏障<code>smp_mb()</code>用于实现<code>STORESTORE</code>同步，当<code>smp_mb()</code>被调用时，<code>CPU</code>首先对<code>store buffer</code>执行刷新操作。在刷新操作期间，需要接收到所有其他<code>CPU</code>的无效确认<code>invalidate acknowledge</code>消息后，<code>store buffer</code>中缓存的修改后的数据将被更新到缓存行，此时，当<code>store buffer</code>中的所有数据都更新到缓存行时，<code>store buffer</code>造成的影响消失，<code>CPU</code>可以在<code>smp_mb()</code>内存屏障之后继续执行存储操作，<code>smp_mb()</code>内存屏障之后的加载操作可以在不完成<code>store buffer</code>刷新操作的情况下进行。</p><p>当调用<code>smp_mb()</code>来刷新<code>store buffer</code>时，<code>CPU</code>可以等到<code>store buffer</code>中的数据被清除后再继续内存屏障之后的存储操作</p><div class="note note-info">            <p>这里是指，当刷新<code>store buffer</code>时，可以继续执行<code>STORESTORE</code>后面的存储操作，但是不能直接写入到缓存行里面，只能放在<code>store buffer</code>里面</p>          </div><p>在上述代码中，如果没有使用<code>smp_mb()</code>内存屏障，当<code>CPU0</code>执行<code>b = 1</code>时，<code>CPU0</code>可以直接将变量<code>b</code>的新值写入缓存行中，因为变量<code>b</code>在<code>CPU0</code>中是<code>MESI</code>的<code>E</code>或<code>M</code>状态，即缓存命中</p><p>现在加了<code>smp_mb()</code>内存屏障，当<code>CPU0</code>执行<code>b = 1</code>时，即使发生缓存命中，变量<code>b</code>的新值也无法写入缓存行，因为此时正在执行<code>store buffer</code>的刷新操作，相反，变量<code>b</code>的新值必须写入<code>store buffer</code>中，然后，变量<code>b</code>的新值可以在<code>store buffer</code>刷新的过程中更新的缓存行中</p><p>在使用了<code>smp_mb()</code>内存屏障后，上述代码的执行流程变为：</p><ol><li><code>CPU0</code>执行<code>a = 1</code>，该变量<code>a</code>发生缓存未命中，因此<code>CPU0</code>将新值<code>a</code> 放入其<code>store buffer</code>中，并传输<code>read invalidate</code>消息</li><li><code>CPU1</code>执行<code>while (b == 0) continue;</code>，但是变量<code>b</code>发生缓存未命中，<code>CPU1</code>发出<code>read</code>消息</li><li><code>CPU0</code>执行<code>smp_mb()</code>，并将当前缓冲区条目<code>a = 1</code>进行标记</li><li><code>CPU0</code>执行<code>b = 1</code>，发生缓存命中，但是<code>store buffer</code>中有一个标记条目，因此，<code>CPU0</code>将变量<code>b</code> 的新值放在<code>store buffer</code>中（但是放在未标记的条目中）</li><li><code>CPU0</code>接收到<code>read</code>消息，并将包含<code>b</code>的原始值的缓存行传输到<code>CPU1</code>，并且将该行缓存行标记为<code>shared</code></li><li><code>CPU1</code>接收包含<code>b</code>的高速缓存行，并将其安装到其高速缓存中</li><li><code>CPU1</code>执行<code>while (b == 0) continue;</code>，并且变量<code>b</code>在其缓存行中，但是这仍然是旧值，即<code>b = 0</code>，其新值仍在<code>CPU0</code>的<code>store buffer</code>中，于是重复<code>while</code>语句</li><li><code>CPU1</code>接收到读无效<code>read invalidate</code>消息，并将包含<code>a</code>的缓存行传输到<code>CPU0</code>，并使该行标记为无效<code>Invalidate</code></li><li><code>CPU0</code>接收包含<code>a</code>的缓存行并且用<code>store buffer</code>中<code>a</code>的新值修改，将该行置于<code>Modified</code>状态</li><li>在<code>CPU0</code>中，由于<code>a = 1</code>是<code>store buffer</code>中的唯一被标记的条目，<code>CPU0</code>的<code>store buffer</code>还可以存储<code>b</code>的新值，此时，<code>CPU0</code>的有变量<code>b</code>的缓存行仍然还是被标记为<code>shared</code>状态的</li><li>因此，<code>CPU0</code>向<code>CPU1</code>发送<code>invalidate</code>消息</li><li><code>CPU1</code>收到<code>invalidate</code>消息，并将<code>b</code>对应的缓存行置为<code>Invalidate</code>，同时向<code>CPU0</code>发送应答<code>Acknowledge</code>消息</li><li><code>CPU1</code>执行<code>while (b == 0) continue;</code>，但是缓存行中的<code>b</code>是<code>invalidate</code>状态，因此<code>CPU1</code>发送读取<code>b</code>的消息<code>read</code></li><li><code>CPU0</code>收到确认<code>Acknowledge</code>消息，并将包含<code>b</code> 的缓存行置为独占<code>Exclusive</code>状态，<code>CPU0</code>将<code>b</code>的新值存储到缓存行中</li><li><code>CPU0</code>接收到读取消息，并将包含新值<code>b</code>的缓存行传输到<code>CPU1</code>，并将自己的该行缓存行标记为<code>shared</code></li><li><code>CPU1</code>接收到包含<code>b</code>的缓存行并将其安装到自己的缓存行中</li><li><code>CPU1</code>现在可以完成<code>while</code>循环的执行，然后执行<code>assert</code>语句，由于<code>a</code>不在其缓存行中，它会发起读<code>read</code>消息，获取到<code>CPU0</code>中的<code>a</code>变量，两个<code>CPU</code>都将该变量置为<code>shared</code>，并且该变量值为<code>1</code>，通过断言</li></ol><h4 id="StoreLoad乱序"><a href="#StoreLoad乱序" class="headerlink" title="StoreLoad乱序"></a>StoreLoad乱序</h4><p>查看一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// CPU0</span><br>WRITE(A, <span class="hljs-number">1</span>)<br>READ(B)<br><br><span class="hljs-comment">// CPU1</span><br>WRITE(B, <span class="hljs-number">1</span>)<br>READ(A)<br></code></pre></td></tr></table></figure><p>内存<code>A</code>和<code>B</code>的初始值都是<code>0</code>，<code>CPU0</code>执行<code>A=1</code>，<code>CPU1</code>执行<code>B=1</code>，<strong>但是两个<code>CPU</code>读取的结果都有可能是<code>0</code></strong></p><p>假设变量<code>A</code>最初只在<code>CPU1</code>的缓存行中，变量<code>B</code>只在<code>CPU0</code>的缓存行中，有以下过程：</p><ol><li>当<code>CPU0</code>执行<code>A = 1</code>时，发生缓存未命中，因此，<code>A</code>的新值被保留在<code>store buffer</code>中，并向<code>CPU1</code>发送一条无效<code>invalidate</code>消息</li><li>然后，<code>CPU0</code>继续执行<code>READ(B)</code>，发生缓存命中，<code>B</code>值为<code>0</code></li><li>当<code>CPU1</code>执行<code>B = 1</code>时，发生缓存未命中，因此，<code>B</code>的新值被放置在<code>store buffer</code>中，<code>CPU1</code>发出<code>invalidate</code>消息</li><li>然后，<code>CPU1</code>继续执行<code>READ(A)</code>，缓存命中，<code>A</code>值为<code>0</code></li><li>然后，<code>CPU1</code>从<code>CPU0</code>接收到关于变量<code>A</code>的<code>invalidate</code>消息，并将缓存行中的变量<code>A</code>的值更新为<code>1</code></li><li>然后，<code>CPU0</code>从<code>CPU1</code>接收到关于变量<code>B</code>的<code>invalidate</code>消息，并将缓存行中的变量<code>B</code>的值更新为<code>1</code></li></ol><p>这种重排称为<code>StoreLoad</code>重排，解决方案是在<code>Store</code>和<code>Load</code>操作中间加入<code>StoreLoad</code>内存屏障，当遇到内存屏障时，<code>store buffer</code>会被刷新到缓存行中，此时，<code>CPU</code>必须等待<code>store buffer</code>中的数据刷新完成，然后才能访问内存屏障之后的访存操作</p><h4 id="invalidation-queue"><a href="#invalidation-queue" class="headerlink" title="invalidation queue"></a>invalidation queue</h4><p><code>store buffer</code>的容量一般比较小，在这两种情况下，其很快就会被填满：</p><ol><li>当<code>CPU</code>执行<code>STORE</code>操作时发生缓存未命中时，当前<code>STORE</code>操作修改的数据必须放在<code>store buffer</code>里面，然后才能继续执行后续指令。当<code>CPU</code>连续执行多个<code>STORE</code>操作期间发生缓存未命中时，<code>store buffer</code>会很快填满，此时，<code>CPU</code>必须等待其他<code>CPU</code>的无效确认消息，之后<code>CPU</code>就可以将<code>store buffer</code>里面的内容更新到缓存行中，<strong>这是<code>store buffer</code>中有可用空间的唯一办法</strong></li><li>当<code>CPU</code>调用内存屏障操作时，内存屏障之后的<code>STORE</code>操作必须在<code>store buffer</code>中，这种情况下，无论相应的缓存行是否准备好，<code>store buffer</code>都有可能很快被填满，<code>CPU</code>必须等待其他<code>CPU</code>的无效确认消息</li></ol><p>当<code>store buffer</code>被填满时，<code>CPU</code>必须等待其他<code>CPU</code>的无效确认消息，使用<code>invalidation queue</code>可以减少等待时间</p><p>有时，<code>CPU</code>会延迟发送无效确认消息，因为<code>CPU</code>在发送无效确认<code>invalidate acknowledge</code>消息之前必须对相应缓存行执行无效<code>invalidate</code>操作，但是，当<code>CPU</code>的<code>LOAD/STORE</code>操作比较重时，<code>CPU</code>通常会将接收到的无效消息搁置，当负载变轻时，再处理无效消息并回复无效确认消息</p><p>使用了无效队列<code>invalidation queue</code>后，<code>CPU</code>可以将收到的无效消息缓存到<code>invalidation queue</code>中，并立即发送无效确认消息，之后，<code>CPU</code>在发送<code>invalidate</code>消息时，必须检查<code>invalidation queue</code>中是否存在对应的<code>invalidate</code>消息</p><h4 id="LoadLoad乱序"><a href="#LoadLoad乱序" class="headerlink" title="LoadLoad乱序"></a>LoadLoad乱序</h4><p><code>invalidation queue</code>队列机制会导致<code>LoadLoad</code>乱序</p><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    a = <span class="hljs-number">1</span>;<br>    smp_mb();<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">while</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    assert(a == <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>全局变量<code>a</code>和<code>b</code>都初始为<code>0</code>，<code>a</code>同时缓存在<code>CPU0</code>和<code>CPU1</code>里面（即变量<code>a</code>状态为<code>shared</code>），变量<code>b</code>仅存放在<code>CPU0</code>的缓存行中</p><p>假设<code>CPU0</code>运行<code>foo</code>函数，<code>CPU1</code>运行<code>bar</code>函数，运行过程是：</p><ol><li><code>CPU0</code>执行<code>a = 1</code>，相应的高速缓存行在<code>CPU0</code>中是<code>shared</code>的，因此<code>CPU0</code>将新值<code>a</code>放入<code>store buffer</code>中，并发送<code>invalidate</code>消息到其他<code>CPU</code>，使<code>CPU1</code>中的变量<code>a</code>的状态变为<code>Invalidation</code>（<code>CPU0</code>中的<code>a</code>为<code>Modified</code>了）</li><li><code>CPU1</code>执行<code>while</code>语句，但是变量<code>b</code>发生缓存未命中，因此其发送<code>read</code>消息</li><li><code>CPU1</code>收到了<code>CPU0</code>的<code>invalidate</code>消息，将其放入<code>invalidation queue</code>，并立即发送<code>invalidate acknowledge</code>消息给<code>CPU0</code></li><li><code>CPU0</code>收到了<code>CPU1</code>的<code>invalidate acknowledge</code>消息，就可以将<code>a</code>从<code>store buffer</code>中放入缓存行</li><li><code>CPU0</code>执行<code>b = 1</code>，发生缓存命中，因此可以直接将<code>b</code>的新值放在其缓存行中</li><li><code>CPU0</code>接到读取消息，并将包含现在的新<code>b</code>值发送给<code>CPU1</code>，同时在缓存行中标记其为<code>shared</code></li><li><code>CPU1</code>接收到包含<code>b</code>的数据，并将其放在缓存行中</li><li><code>CPU1</code>现在可以完成<code>while</code>语句了，因为<code>b</code>现在是<code>1</code>，于是继续执行下一个指令</li><li><code>CPU1</code>执行断言失败，由于<code>a</code>的旧值<code>0</code>仍在<code>CPU1</code>的高速缓存行中</li><li>尽管断言失败，<code>CPU1</code>仍会处理排队中的<code>invalidate</code>消息，并（迟缓的，于事无补的）使高速缓存行中的<code>a</code>状态变为<code>Invalidation</code>（但是没啥卵用，错误已经发生了）</li></ol><p>使用内存屏障可以解决这个问题</p><p><code> CPU1</code>在执行<code>LOAD</code>操作来访问变量<code>a</code>的值之前，需要检查<code>invalidation queue</code>中是否存在要处理变量<code>a</code>的无效消息（<code>a</code>在屏障之后），即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    a = <span class="hljs-number">1</span>;<br>    smp_mb();<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">while</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    smp_mb();<br>    assert(a == <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，当<code>CPU</code>的两次<code>LOAD</code>操作之间调用<code>LoadLoad</code>屏障时，<code>LoadLoad</code>屏障会标记<code>invalidations queue</code>中待处理的<code>invalidate</code>消息对应的缓存行，当<code>LoadLoad</code>屏障之后的加载操作对应的缓存行被标记后，就会等待对应的<code>pending invalidate</code>消息处理完毕后，才会执行<code>LOAD</code>操作</p><p><code>LoadLoad</code>屏障将等待<code>invalidation queue</code>的所有待处理的<code>invalidate</code>消息被处理完成后，再执行屏障后的加载操作，代码流程为：</p><ol><li><code>CPU0</code>执行<code>a = 1</code>，缓存命中，但是由于<code>a</code>是<code>shared</code>状态，因此需要写入<code>store buffer</code>，发出<code>invalidate</code>消息到<code>CPU1</code></li><li><code>CPU1</code>执行<code>while</code>语句，但是<code>b</code>发生缓存未命中，发出<code>read</code>消息</li><li><code>CPU1</code>收到<code>CPU0</code>的<code>invalidate</code>消息，将其入队<code>invalidate queue</code>，并立即发送<code>invalidate acknowledge</code>消息</li><li><code>CPU0</code>收到来自<code>CPU1</code>的响应，于是可以通过内存屏障，将<code>a</code>的值写入缓存，执行<code>b = 1</code>语句，发生缓存命中，将<code>b</code>的新值放入缓存行中</li><li><code>CPU0</code>收到<code>read</code>消息，并将包含<code>b</code>新值的缓存行发送到<code>CPU1</code>，并将该缓存行标记为<code>shared</code></li><li><code>CPU1</code>收到<code>b</code>的新值，将其放入缓存行中</li><li><code>CPU1</code>现在可以通过<code>while</code>语句，并遇到了内存屏障</li><li><code>CPU1</code>必须停止运行，直到处理完其<code>invalidate queue</code>中的<code>invalidate</code>消息</li><li><code>CPU1</code>使<code>a</code>的缓存行无效（即处理了来自<code>CPU0</code>的，变量<code>a</code>的<code>invalidate</code>消息）</li><li><code>CPU1</code>执行<code>assert</code>语句，<code>a</code>发生缓存未命中，并向<code>CPU0</code>发起<code>read</code>消息</li><li><code>CPU0</code>使用包含新值<code>a</code>的缓存行进行回复此<code>read</code>消息</li><li><code>CPU1</code>收到此缓存行，其中<code>a</code>的值为<code>1</code>，通过断言</li></ol><h4 id="LoadStore乱序"><a href="#LoadStore乱序" class="headerlink" title="LoadStore乱序"></a>LoadStore乱序</h4><p>这是一个单纯的内存重排，<code>LOAD</code>操作如果发生缓存未命中，则需要从主存&#x2F;其他<code>CPU</code>中获取，这是一个比较漫长的过程，<code>CPU</code>可能在这个等待的过程中继续执行下一条<code>STORE</code>指令</p><h4 id="CPU内存屏障"><a href="#CPU内存屏障" class="headerlink" title="CPU内存屏障"></a>CPU内存屏障</h4><p>如上所述，CPU乱序的解决方案是使用内存屏障</p><p>内存屏障共有三类：</p><ul><li>全屏障：限制语义最强，但是性能最差，应对所有乱序情况</li><li>读屏障：保证读屏障之前的读操作一定在读屏障之后的读操作前完成，应对<code>LoadLoad</code>乱序</li><li>写屏障：保证写屏障之前的写操作一定在写屏障之后的写操作前完成，应对<code>StoreStore</code>乱序</li></ul><h4 id="内存屏障在不同平台上的实现"><a href="#内存屏障在不同平台上的实现" class="headerlink" title="内存屏障在不同平台上的实现"></a>内存屏障在不同平台上的实现</h4><p>x86架构中的内存屏障</p><p>在x86架构中，内存屏障由以下指令实现：</p><ul><li><strong>MFENCE</strong>：全屏障，确保读写操作的顺序。</li><li><strong>LFENCE</strong>：读屏障，确保读操作的顺序。</li><li><strong>SFENCE</strong>：写屏障，确保写操作的顺序。</li></ul><p>x86架构中的内存模型通常较为严格，因此在大多数情况下，编写多线程代码时不需要显式使用这些屏障指令。但是在涉及高性能、精确控制的场合，内存屏障仍然是必不可少的。</p><p>ARM架构中的内存屏障</p><p>ARM架构的内存模型相对宽松，因此在多核系统中更加依赖于内存屏障：</p><ul><li><strong>DMB（Data Memory Barrier）</strong>：确保内存访问的顺序。</li><li><strong>DSB（Data Synchronization Barrier）</strong>：确保所有内存访问完成，并且后续指令在屏障前的指令完成后再执行。</li><li><strong>ISB（Instruction Synchronization Barrier）</strong>：确保处理器重新获取指令，并在后续指令执行前更新状态。</li></ul><p>在ARM系统中，由于处理器和内存之间的操作可能会重排，因此内存屏障在保证操作顺序和数据一致性方面尤为重要。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="SC模型（sequential-consistency-顺序一致性）"><a href="#SC模型（sequential-consistency-顺序一致性）" class="headerlink" title="SC模型（sequential consistency, 顺序一致性）"></a>SC模型（sequential consistency, 顺序一致性）</h3><p><code>CPU</code>会按照程序中的顺序依次执行<code>STORE</code>和<code>LOAD</code></p><div class="note note-info">            <p>最严格的内存模型</p>          </div><h3 id="TSO模型（Total-Store-Order-完全存储顺序）"><a href="#TSO模型（Total-Store-Order-完全存储顺序）" class="headerlink" title="TSO模型（Total Store Order, 完全存储顺序）"></a>TSO模型（Total Store Order, 完全存储顺序）</h3><p>x86使用这种模型</p><p>TSO模型允许store-load乱序</p><p>store buffer会按照FIFO的顺序将数据写入到<code>L1 cache</code></p><h3 id="PSO模型（Part-Store-Order-部分存储顺序）"><a href="#PSO模型（Part-Store-Order-部分存储顺序）" class="headerlink" title="PSO模型（Part Store Order, 部分存储顺序）"></a>PSO模型（Part Store Order, 部分存储顺序）</h3><p>PSO模型，store buffer不再按照FIFO顺序写入<code>L1 cache</code></p><p>PSO模型允许store-load, store-store乱序</p><h3 id="RMO模型（Relaxed-Memory-Order，弱内存模型）"><a href="#RMO模型（Relaxed-Memory-Order，弱内存模型）" class="headerlink" title="RMO模型（Relaxed Memory Order，弱内存模型）"></a>RMO模型（Relaxed Memory Order，弱内存模型）</h3><p>aarch64架构采用此种内存模型</p><p>RMO对四种操作皆可乱序</p><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>对于每个<code>CPU</code>核心而言，都有其自己独立的<code>L1 cache</code></p><p>同一个簇内的<code>CPU</code>核心，有它们簇内共享的<code>L2 cache</code></p><p>所有<code>CPU</code>核心，共享<code>L3 cache</code></p><p><code>CPU</code>在执行内存读写操作时，首先会去自己的<code>L1 cache</code>查找缓存，如果没有，依次向<code>L2 cache</code>，<code>L3 cache</code>查找，如果都没有找到，再去主存中查找</p><p>那么，如果<code>CPU0</code>从主存中读取了变量<code>a</code>，另一个线程在<code>CPU1</code>上也读取了这个变量<code>a</code>，此时就会出现竞态问题，如果<code>CPU0</code>修改了变量<code>a</code>，而<code>CPU1</code>上的另一个线程需要这个修改后的变量<code>a</code>来执行一些操作，这就需要在缓存行之间有一些同步的协议，也就是<code>MESI</code></p><hr><p>MESI协议（Modified, Exclusive, Shared, Invalid）是多处理器系统中一种广泛使用的缓存一致性协议。它通过维护缓存行的状态来确保缓存的一致性，避免上述的数据不一致问题。</p><p>MESI协议的四种状态</p><ul><li><strong>M（Modified）</strong>：缓存行已被当前核心修改，且与主内存中的数据不一致。只有当前核心持有该缓存行。</li><li><strong>E（Exclusive）</strong>：缓存行仅存在于当前核心的缓存中，但数据与主内存一致。</li><li><strong>S（Shared）</strong>：缓存行可能存在于多个核心的缓存中，且数据与主内存一致。</li><li><strong>I（Invalid）</strong>：缓存行无效，数据与主内存不一致或不再被使用。</li></ul><p><code>MESI</code>协议的核心思想是通过状态转换来确保各个核心的缓存数据一致。当一个核心对某个缓存行进行修改时，其他核心中对应的缓存行状态将变为无效（Invalid）。当一个核心需要访问一个已失效的缓存行时，它会从主内存或其他核心的缓存中获取最新数据，并更新其缓存状态。</p><p>有限状态自动机的状态转换结束两种场景：缓存所在处理器的读写；其他处理器的读写。总线请求被[总线窥探器]监视。</p><p>处理器对缓存的请求:</p><ol><li><code>PrRd</code>: 处理器请求<strong>读</strong>一个缓存块</li><li><code>PrWr</code>: 处理器请求<strong>写</strong>一个缓存块</li></ol><p>总线对缓存的请求:</p><ol><li><code>BusRd</code>: 窥探器请求指出其他处理器请求<strong>读</strong>一个缓存块</li><li><code>BusRdX</code>: 窥探器请求指出其他处理器请求<strong>写</strong>一个该处理器不拥有的缓存块</li><li><code>BusUpgr</code>: 窥探器请求指出其他处理器请求<strong>写</strong>一个该处理器拥有的缓存块</li><li><code>Flush</code>: 窥探器请求指出请求<strong>回写</strong>整个缓存到主存</li><li><code>FlushOpt</code>: 窥探器请求指出整个缓存块被发到总线以发送给另外一个处理器（缓存到缓存的复制）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存屏障与缓存一致性协议是互补的</p><ul><li><strong>MESI协议</strong>确保当一个核心修改了某个缓存行时，其他核心能够及时感知到这一变化，并更新或失效它们的缓存行，从而保证数据一致性。</li><li><strong>内存屏障</strong>确保共享数据的更新顺序不会被编译器或处理器的重排机制打乱，从而防止数据竞态和不一致问题。</li></ul><p><strong>例子</strong>：考虑一个典型的生产者-消费者问题。生产者线程会将数据写入缓冲区，然后设置一个标志位通知消费者线程数据已准备好。消费者线程则等待标志位的变化，并读取缓冲区中的数据。</p><ul><li>生产者线程在写入缓冲区数据后，需要插入一个写屏障，以确保缓冲区数据在标志位更新前被完全写入。</li><li>消费者线程在读取标志位前，需要插入一个读屏障，以确保它看到的标志位变化对应的是最新的缓冲区数据。</li></ul><p>MESI协议会确保生产者线程对缓冲区的修改在消费者线程中可见，而内存屏障则确保消费者读取到的缓冲区数据和标志位状态是一致的。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">https://alibaba-cloud.medium.com/memory-model-and-synchronization-primitive-part-1-memory-barrier-9585e50b4735<br></code></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">// 一个MESI体验网站<br>https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESI.htm<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>嵌入式</tag>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备驱动模型</title>
    <link href="/2025/01/06/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/01/06/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="linux设备驱动框架"><a href="#linux设备驱动框架" class="headerlink" title="linux设备驱动框架"></a>linux设备驱动框架</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Linux的设备驱动框架是以<code>bus</code>，<code>driver</code>，<code>device</code>，<code>class</code>为基石，<code>kobject</code>为基本元素所构成的，配合<code>sysfs</code>文件系统对操作系统软硬件进行组织，管理的框架。</p><p>每个<code>kobject</code>都对应<code>sysfs</code>文件系统里面的一个目录，出现在该目录中的文件称为该对象的属性。</p><h2 id="二、kobject，kset，subsystem"><a href="#二、kobject，kset，subsystem" class="headerlink" title="二、kobject，kset，subsystem"></a>二、kobject，kset，subsystem</h2><p><code>kobject</code>包含在一个层次化的组织当中，它可以有一个父对象，可以包含在一个<code>kset</code>对象中。</p><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><h4 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设备驱动程序模型的核心数据结构。对应于sysfs文件系统中每一个目录。</span><br><span class="hljs-comment"> * 它通常被放到设备驱动程序的一个大容器中。典型的容器有总线、设备及驱动程序描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向容器名称，注意，这里是指针，其在注册时进行分配，注销时回收。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>* k_name;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果容器名称不超过20个字符，就存在这里。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span>name[KOBJ_NAME_LEN];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 容器的引用计数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span><span class="hljs-title">kref</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于将kobject插入某个链表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">entry</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向父kobject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span>* <span class="hljs-title">parent</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向包含的kset,kset是同类型的kobject结构的一个集合体。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span>* <span class="hljs-title">kset</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向kobject的类型描述符。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span>* <span class="hljs-title">ktype</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 指向与kobject对应的sysfs文件的dentry数据结构。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>* <span class="hljs-title">dentry</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 嵌入相同类型结构的kobject集合。</span><br><span class="hljs-comment"> * 当创建一个kobject对象时，通常需要将它们加入到kset中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所属子系统。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsystem</span>* <span class="hljs-title">subsys</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所包含的kobjec的类型。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span>* <span class="hljs-title">ktype</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第一个kobject节点。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">list</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 嵌入的kobject，也就是说，</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span><span class="hljs-title">kobj</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于处理kobject结构的过滤和热插拨操作的回调函数表。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_hotplug_ops</span>* <span class="hljs-title">hotplug_ops</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="kobj-type"><a href="#kobj-type" class="headerlink" title="kobj_type"></a>kobj_type</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述包含kobject对象的结构类型。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * kobject类型的release函数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> (*release)(<span class="hljs-keyword">struct</span> kobject *);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现对象属性的方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysfs_ops</span>* <span class="hljs-title">sysfs_ops</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当创建kobject时，赋予该对象的默认属性。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span>** <span class="hljs-title">default_attrs</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>kset_hotplug_ops</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 控制热插拨事件的结构。由kset的hotplug_ops指向该结构。</span><br><span class="hljs-comment"> * 如果kset不包含一个指定的kobject，则在sysfs分层结构中进行搜索，直到找到一个包含有kset的kobject为止，然后使用这个kset的热插拨操作。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset_hotplug_ops</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 无论何时，当内核要为指定的kobject产生事件时，都要调用filter函数。如果filter函数返回0，将不产生事件。</span><br><span class="hljs-comment"> * 因此，该函数给kset一个机会，用于决定是否向用户空间传递指定的事件。</span><br><span class="hljs-comment"> * 使用此函数的一个例子是块设备子系统。在block_hotplug_filter中，只为kobject产生磁盘和分区事件，而不会为请求队列kobject产生事件。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*filter)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在调用用户空间的热插拨程序时，相关子系统的名字将作为唯一的参数传递给它。</span><br><span class="hljs-comment"> * name方法负责提供此名字。它将返回一个适合传递给用户空间的字符串。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">char</span> *(*name)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任何热插拨脚本所需要知道的信息将通过环境变量传递。最后一个hotplug方法会在调用脚本前，提供添加环境变量的机会。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> (*hotplug)(<span class="hljs-keyword">struct</span> kset *kset, <span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-type">char</span> **envp,<br><span class="hljs-type">int</span> num_envp, <span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> buffer_size);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="subsystem"><a href="#subsystem" class="headerlink" title="subsystem"></a>subsystem</h4><blockquote><p>在高版本中，将其废弃，因为其与kset功能重复，读写信号量的功能被klist替代</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 子系统。通常显示在sysfs分层结构中的顶层。</span><br><span class="hljs-comment"> * 包含block_subsys、devices_subsys以及各种总线等子系统，对应于sys/block、sys/devices等目录。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsystem</span> &#123;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 下层对象集合。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span><span class="hljs-title">kset</span>;</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 访问子系统所用的读写信号量。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span><span class="hljs-title">rwsem</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="subsys-attribute"><a href="#subsys-attribute" class="headerlink" title="subsys_attribute"></a>subsys_attribute</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">subsys_attribute</span> &#123;</span><br>    <span class="hljs-comment">//属性本身</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> <span class="hljs-title">attr</span>;</span><br>    <span class="hljs-comment">//sysfs文件的读</span><br><span class="hljs-type">ssize_t</span> (*show)(<span class="hljs-keyword">struct</span> subsystem *, <span class="hljs-type">char</span> *);<br>    <span class="hljs-comment">//sysfs文件的写</span><br><span class="hljs-type">ssize_t</span> (*store)(<span class="hljs-keyword">struct</span> subsystem *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">size_t</span>); <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="内部API"><a href="#内部API" class="headerlink" title="内部API"></a>内部API</h3><h4 id="kobject-name"><a href="#kobject-name" class="headerlink" title="kobject_name"></a>kobject_name</h4><blockquote><p>返回其k_name，这是在这个kobj对象分配后才会指定的，其他情况下为NULL，可用用来判断kobj对象是否合法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> * <span class="hljs-title function_">kobject_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-keyword">return</span> kobj-&gt;k_name;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="populate-dir"><a href="#populate-dir" class="headerlink" title="populate_dir"></a>populate_dir</h4><blockquote><p>填充目录（kobject是一个目录，这个API使用默认属性建立该目录下的文件）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">populate_dir</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br>    <span class="hljs-comment">//得到该kobj的类型，里面有该kobj的默认属性</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> * <span class="hljs-title">t</span> =</span> get_ktype(kobj);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">attribute</span> * <span class="hljs-title">attr</span>;</span><br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><span class="hljs-comment">//如果kobj的类型存在，并且其有默认属性</span><br><span class="hljs-keyword">if</span> (t &amp;&amp; t-&gt;default_attrs) &#123;<br>        <span class="hljs-comment">//kobj_type的默认属性是一个二级指针，意味着其可以有多个默认的属性，遍历其可用的属性，创建对应的属性文件，也就是这个kobj目录下的文件</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; (attr = t-&gt;default_attrs[i]) != <span class="hljs-literal">NULL</span>; i++) &#123;<br>            <span class="hljs-comment">//如果创建文件出错，就break掉，返回错误码</span><br><span class="hljs-keyword">if</span> ((error = sysfs_create_file(kobj,attr)))<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="create-dir"><a href="#create-dir" class="headerlink" title="create_dir"></a>create_dir</h4><blockquote><p>建立<code>kobject</code>对应的目录</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">create_dir</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//注意，这里的kobject_name返回的是k_name，这个成员是分配其kobj对象时才会赋值，所以这个if判断可以检查kobj是否是一个合法的kobj</span><br><span class="hljs-keyword">if</span> (kobject_name(kobj)) &#123;<br>        <span class="hljs-comment">//建立kobj对象对应的目录</span><br>error = sysfs_create_dir(kobj);<br><span class="hljs-keyword">if</span> (!error) &#123;<br>            <span class="hljs-comment">//若没有出错，填充其目录下的文件，也就是这个kobj的属性</span><br><span class="hljs-keyword">if</span> ((error = populate_dir(kobj)))<br>                <span class="hljs-comment">//如果出错，清理现场</span><br>sysfs_remove_dir(kobj);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="to-kobj"><a href="#to-kobj" class="headerlink" title="to_kobj"></a>to_kobj</h4><blockquote><p>从链表节点得到其kobj</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> kobject * <span class="hljs-title function_">to_kobj</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> list_head * entry)</span><br>&#123;<br><span class="hljs-keyword">return</span> container_of(entry,<span class="hljs-keyword">struct</span> kobject,entry);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-kobj-path-length"><a href="#get-kobj-path-length" class="headerlink" title="get_kobj_path_length"></a>get_kobj_path_length</h4><blockquote><p>得到kobj目录的路径长度</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_kobj_path_length</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj)</span><br>&#123;<br>    <span class="hljs-comment">//length初始为一，是因为kobj本身也是一个目录，在其后面也可以有一个&#x27;/&#x27;</span><br><span class="hljs-type">int</span> length = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//从这个kobj本身开始</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> * <span class="hljs-title">parent</span> =</span> kobj;<br><br><span class="hljs-comment">/* walk up the ancestors until we hit the one pointing to the </span><br><span class="hljs-comment"> * root.</span><br><span class="hljs-comment"> * Add 1 to strlen for leading &#x27;/&#x27; of each level.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//一级一级计算，从kobj本身开始，一直到/sys</span><br><span class="hljs-keyword">do</span> &#123;<br>length += <span class="hljs-built_in">strlen</span>(kobject_name(parent)) + <span class="hljs-number">1</span>;<br>parent = parent-&gt;parent;<br>&#125; <span class="hljs-keyword">while</span> (parent);<br><span class="hljs-keyword">return</span> length;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fill-kobj-path"><a href="#fill-kobj-path" class="headerlink" title="fill_kobj_path"></a>fill_kobj_path</h4><blockquote><p>填充<code>kobject</code>的路径，第二个参数<code>path</code>是申请好的内存空间，用以存放<code>kobject</code>的绝对路径</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fill_kobj_path</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> length)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> * <span class="hljs-title">parent</span>;</span><br><span class="hljs-comment">//length先减一，为何？</span><br>    <span class="hljs-comment">//因为length是长度，但是在下面的使用中，是当作下标来用的，长度和下标相差1，因此将其减掉</span><br>--length;<br>    <span class="hljs-comment">//从kobj开始，向其父节点遍历</span><br><span class="hljs-keyword">for</span> (parent = kobj; parent; parent = parent-&gt;parent) &#123;<br>        <span class="hljs-comment">//当前节点的kobj-&gt;k_name，注意，这个名字是没有&#x27;/&#x27;的</span><br><span class="hljs-type">int</span> cur = <span class="hljs-built_in">strlen</span>(kobject_name(parent));<br><span class="hljs-comment">/* back up enough to print this name with &#x27;/&#x27; */</span><br>        <span class="hljs-comment">//length-cur就是这个kobj-&gt;k_name应该在path字符串的第一个位置</span><br>length -= cur;<br>        <span class="hljs-comment">//在这个位置，放入当前kobj-&gt;k_name</span><br><span class="hljs-built_in">strncpy</span> (path + length, kobject_name(parent), cur);<br>        <span class="hljs-comment">//在这个name的前一个位置，放一个&#x27;/&#x27;</span><br>*(path + --length) = <span class="hljs-string">&#x27;/&#x27;</span>;<br>&#125;<br><br>pr_debug(<span class="hljs-string">&quot;%s: path = &#x27;%s&#x27;\n&quot;</span>,__FUNCTION__,path);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="to-kset"><a href="#to-kset" class="headerlink" title="to_kset"></a>to_kset</h4><blockquote><p>由kobj得到其对应的kset</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> kset * <span class="hljs-title function_">to_kset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-keyword">return</span> kobj ? container_of(kobj,<span class="hljs-keyword">struct</span> kset,kobj) : <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-get"><a href="#kset-get" class="headerlink" title="kset_get"></a>kset_get</h4><blockquote><p>若kset存在，递增这个kset-&gt;kobj的计数，并将其返回，否则返回NULL</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> kset * <span class="hljs-title function_">kset_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br><span class="hljs-keyword">return</span> k ? to_kset(kobject_get(&amp;k-&gt;kobj)) : <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-put"><a href="#kset-put" class="headerlink" title="kset_put"></a>kset_put</h4><blockquote><p>递减kset-&gt;kobj的计数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kset_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>kobject_put(&amp;k-&gt;kobj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-ktype"><a href="#get-ktype" class="headerlink" title="get_ktype"></a>get_ktype</h4><blockquote><p>如果这个kobj属于某个kset，并且这个kset有ktype，那么返回这个ktype，否则返回kobj-&gt;ktype</p></blockquote><blockquote><p>由此可以看到，优先返回kset的ktype，因为这一个kset的kobj类型一致</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> kobj_type * <span class="hljs-title function_">get_ktype</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * k)</span><br>&#123;<br><span class="hljs-keyword">if</span> (k-&gt;kset &amp;&amp; k-&gt;kset-&gt;ktype)<br><span class="hljs-keyword">return</span> k-&gt;kset-&gt;ktype;<br><span class="hljs-keyword">else</span> <br><span class="hljs-keyword">return</span> k-&gt;ktype;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h4><blockquote><p>将一个kobj从其kset中移除</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br>    <span class="hljs-comment">//如果kobj归属一个kset，就将其从kset的链表中删除，并且初始化entry</span><br><span class="hljs-keyword">if</span> (kobj-&gt;kset) &#123;<br>down_write(&amp;kobj-&gt;kset-&gt;subsys-&gt;rwsem);<br>list_del_init(&amp;kobj-&gt;entry);<br>up_write(&amp;kobj-&gt;kset-&gt;subsys-&gt;rwsem);<br>&#125;<br>    <span class="hljs-comment">//无论是否删除，都将这个kobj的计数减一</span><br>kobject_put(kobj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="to-kset-1"><a href="#to-kset-1" class="headerlink" title="to_kset"></a>to_kset</h4><blockquote><p>从kobj得到其kset</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> kset * <span class="hljs-title function_">to_kset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-keyword">return</span> kobj ? container_of(kobj,<span class="hljs-keyword">struct</span> kset,kobj) : <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-get-1"><a href="#kset-get-1" class="headerlink" title="kset_get"></a>kset_get</h4><blockquote><p>主要是递增kset中的kobj的引用计数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> kset * <span class="hljs-title function_">kset_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>    <span class="hljs-comment">//这里有一个注意的点，kobject_get的参数是k-&gt;kobj，代表kset的那个kobj，递增这个计数</span><br><span class="hljs-keyword">return</span> k ? to_kset(kobject_get(&amp;k-&gt;kobj)) : <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-put-1"><a href="#kset-put-1" class="headerlink" title="kset_put"></a>kset_put</h4><blockquote><p>递减kset中的kobj的引用计数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kset_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>kobject_put(&amp;k-&gt;kobj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobj-set-kset-s"><a href="#kobj-set-kset-s" class="headerlink" title="kobj_set_kset_s"></a>kobj_set_kset_s</h4><blockquote><p>为某个对象设置其kset为子系统的kset，这个obj是内嵌有一个kobj对象的结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kobj_set_kset_s(obj,subsys) \</span><br><span class="hljs-meta">(obj)-&gt;kobj.kset = &amp;(subsys).kset</span><br></code></pre></td></tr></table></figure><h4 id="kset-set-kset-s"><a href="#kset-set-kset-s" class="headerlink" title="kset_set_kset_s"></a>kset_set_kset_s</h4><blockquote><p>子系统下面也是可以有子系统的，这种就是设置子系统的子系统，比如，bus子系统下面有pci子系统，这个宏是为这个子系统内嵌的kset的kobj的上级kset设置为某个子系统的kset</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kset_set_kset_s(obj,subsys) \</span><br><span class="hljs-meta">(obj)-&gt;kset.kobj.kset = &amp;(subsys).kset</span><br></code></pre></td></tr></table></figure><h4 id="subsys-set-kset"><a href="#subsys-set-kset" class="headerlink" title="subsys_set_kset"></a>subsys_set_kset</h4><blockquote><p>设置这个对象的子系统的所属kset，一般用于注册总线</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> subsys_set_kset(obj,_subsys) \</span><br><span class="hljs-meta">(obj)-&gt;subsys.kset.kobj.kset = &amp;(_subsys).kset</span><br></code></pre></td></tr></table></figure><h4 id="subsys-get"><a href="#subsys-get" class="headerlink" title="subsys_get"></a>subsys_get</h4><blockquote><p>递增子系统的计数，其实就是子系统里面的kset的计数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">struct</span> subsystem * <span class="hljs-title function_">subsys_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> subsystem * s)</span><br>&#123;<br><span class="hljs-keyword">return</span> s ? container_of(kset_get(&amp;s-&gt;kset),<span class="hljs-keyword">struct</span> subsystem,kset) : <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="subsys-put"><a href="#subsys-put" class="headerlink" title="subsys_put"></a>subsys_put</h4><blockquote><p>递减子系统的计数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">subsys_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> subsystem * s)</span><br>&#123;<br>kset_put(&amp;s-&gt;kset);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-release"><a href="#kobject-release" class="headerlink" title="kobject_release"></a>kobject_release</h4><blockquote><p>回调函数，用来kobject_put时，如果计数变为0，将这个kobj资源释放</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">kobject_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kref *kref)</span><br>&#123;<br>kobject_cleanup(container_of(kref, <span class="hljs-keyword">struct</span> kobject, kref));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="decl-subsys"><a href="#decl-subsys" class="headerlink" title="decl_subsys"></a>decl_subsys</h4><blockquote><p>定义一个子系统</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> decl_subsys(_name,_type,_hotplug_ops) \</span><br><span class="hljs-meta">struct subsystem _name##_subsys = &#123; \</span><br><span class="hljs-meta">.kset = &#123; \</span><br><span class="hljs-meta">.kobj = &#123; .name = __stringify(_name) &#125;, \</span><br><span class="hljs-meta">.ktype = _type, \</span><br><span class="hljs-meta">.hotplug_ops =_hotplug_ops, \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="decl-subsys-name"><a href="#decl-subsys-name" class="headerlink" title="decl_subsys_name"></a>decl_subsys_name</h4><blockquote><p>定义一个子系统，但是子系统名字和kobj名字不一样</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> decl_subsys_name(_varname,_name,_type,_hotplug_ops) \</span><br><span class="hljs-meta">struct subsystem _varname##_subsys = &#123; \</span><br><span class="hljs-meta">.kset = &#123; \</span><br><span class="hljs-meta">.kobj = &#123; .name = __stringify(_name) &#125;, \</span><br><span class="hljs-meta">.ktype = _type, \</span><br><span class="hljs-meta">.hotplug_ops =_hotplug_ops, \</span><br><span class="hljs-meta">&#125; \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="kobject-get-path"><a href="#kobject-get-path" class="headerlink" title="kobject_get_path"></a>kobject_get_path</h4><blockquote><p>得到这个kobj的完整路径名</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">kobject_get_path</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject *kobj, <span class="hljs-type">int</span> gfp_mask)</span><br>&#123;<br><span class="hljs-type">char</span> *path;<br><span class="hljs-type">int</span> len;<br><br>len = get_kobj_path_length(kobj);<br>path = kmalloc(len, gfp_mask);<br><span class="hljs-keyword">if</span> (!path)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">memset</span>(path, <span class="hljs-number">0x00</span>, len);<br>fill_kobj_path(kobj, path, len);<br><br><span class="hljs-keyword">return</span> path;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-init"><a href="#kobject-init" class="headerlink" title="kobject_init"></a>kobject_init</h4><blockquote><p>部分初始化kobj</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//可以看到，这里只初始化了计数器，entry节点，若kobj有kset，那么递增其计数，否则设为NULL</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">kobject_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br>kref_init(&amp;kobj-&gt;kref);<br>INIT_LIST_HEAD(&amp;kobj-&gt;entry);<br>kobj-&gt;kset = kset_get(kobj-&gt;kset);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-get"><a href="#kobject-get" class="headerlink" title="kobject_get"></a>kobject_get</h4><blockquote><p>通用的获取kobj对象的方法，会递增其计数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> kobject * <span class="hljs-title function_">kobject_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-keyword">if</span> (kobj)<br>kref_get(&amp;kobj-&gt;kref);<br><span class="hljs-keyword">return</span> kobj;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-add"><a href="#kobject-add" class="headerlink" title="kobject_add"></a>kobject_add</h4><blockquote><p>增加一个kobj对象，也就是在sysfs的目录树中增加一个目录，这里很重要的一个动作是，赋值<code>kobj-&gt;k_name</code>，标识这个kobj是有效的，本函数也会构建好kobj和kset的层级关系</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kobject_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> * <span class="hljs-title">parent</span>;</span><br><br>    <span class="hljs-comment">//如果kobj为NULL，返回错误</span><br><span class="hljs-keyword">if</span> (!(kobj = kobject_get(kobj)))<br><span class="hljs-keyword">return</span> -ENOENT;<br>    <span class="hljs-comment">//如果k_name没有值，就将kobj-&gt;name赋给它，k_name表示这个kobj是否被分配出去了</span><br><span class="hljs-keyword">if</span> (!kobj-&gt;k_name)<br>kobj-&gt;k_name = kobj-&gt;name;<br>    <span class="hljs-comment">//得到kobj的parent，这个可以为NULL</span><br>parent = kobject_get(kobj-&gt;parent);<br><br>pr_debug(<span class="hljs-string">&quot;kobject %s: registering. parent: %s, set: %s\n&quot;</span>,<br> kobject_name(kobj), parent ? kobject_name(parent) : <span class="hljs-string">&quot;&lt;NULL&gt;&quot;</span>, <br> kobj-&gt;kset ? kobj-&gt;kset-&gt;kobj.name : <span class="hljs-string">&quot;&lt;NULL&gt;&quot;</span> );<br><span class="hljs-comment">//如果kobj属于一个kset</span><br><span class="hljs-keyword">if</span> (kobj-&gt;kset) &#123;<br>down_write(&amp;kobj-&gt;kset-&gt;subsys-&gt;rwsem);<br><span class="hljs-comment">//此时如果没有parent，就将kset作为其parent</span><br><span class="hljs-keyword">if</span> (!parent)<br>parent = kobject_get(&amp;kobj-&gt;kset-&gt;kobj);<br><br>        <span class="hljs-comment">//然后将kobj加入到kset的list中，表明这个kobj归属于这个kset</span><br>list_add_tail(&amp;kobj-&gt;entry,&amp;kobj-&gt;kset-&gt;<span class="hljs-built_in">list</span>);<br>up_write(&amp;kobj-&gt;kset-&gt;subsys-&gt;rwsem);<br>&#125;<br>    <span class="hljs-comment">//设置kobj的parent</span><br>kobj-&gt;parent = parent;<br><br>    <span class="hljs-comment">//在sysfs中创建kobj对应的目录（kobj对应目录，而不是文件！）</span><br>error = create_dir(kobj);<br>    <span class="hljs-comment">//如果创建失败，释放这个kobj</span><br><span class="hljs-keyword">if</span> (error) &#123;<br><span class="hljs-comment">/* unlink does the kobject_put() for us */</span><br>        <span class="hljs-comment">//注意这里调用unlink的节点，unlink里面有一个if判断，如果这个kobj有kset，那么将其从kset里面删除并重置entry，而kobj的引用计数都是要减一的</span><br>unlink(kobj);<span class="hljs-comment">//这里对应第七行的kobject_get，这里将其递减</span><br>        <span class="hljs-comment">//如果parent存在，也将其引用计数递减，注意想一下这里为何没有用unlink来处理parent，而是直接kobject_put，因为只是要清除本kobj，其kset的kset属于另一个kobj了</span><br><span class="hljs-keyword">if</span> (parent)<br>kobject_put(parent);<span class="hljs-comment">//对应23行的kobject_get</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//如果没有出错，那么注册kobj的热插拔功能</span><br>kobject_hotplug(kobj, KOBJ_ADD);<br>&#125;<br><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-register"><a href="#kobject-register" class="headerlink" title="kobject_register"></a>kobject_register</h4><blockquote><p>初始化并添加一个kobj对象到kset，并增加其对应的sysfs文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kobject_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//如果kobj为NULL，那么直接返回一个错误</span><br><span class="hljs-keyword">if</span> (kobj) &#123;<br>        <span class="hljs-comment">//否则，先初始化这个kobj的一部分，注意，kobject_init只初始化引用计数，entry，和kset</span><br>kobject_init(kobj);<br>        <span class="hljs-comment">//通过kobject_add来确实新增这个kobj，主要是设置kobj-&gt;k_name和设置层级关系，增加sysfs中的对应的目录</span><br>error = kobject_add(kobj);<br><span class="hljs-keyword">if</span> (error) &#123;<br>printk(<span class="hljs-string">&quot;kobject_register failed for %s (%d)\n&quot;</span>,<br>       kobject_name(kobj),error);<br>dump_stack();<br>&#125;<br>&#125; <span class="hljs-keyword">else</span><br>error = -EINVAL;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-set-name"><a href="#kobject-set-name" class="headerlink" title="kobject_set_name"></a>kobject_set_name</h4><blockquote><p>设置kobject对象的名字</p></blockquote><blockquote><p>这个函数为何要使用变参？</p><p>答：这涉及到操作系统中对kobj对象的命名，对应于device结构中的bus_id，它可能是一个设备名本身，也可能是设备名+ID，这个ID取决于该设备所属的总线分配方式，比如该总线上有五个同类型设备，那么这五个设备的名字可能是xxx0，xxx1，…，xxx4。</p><p>这意味着，kobj对象的name可能是多个部分构成的，那么一个可变参数的函数就很有必要了，它可以根据<code>fmt</code>的格式，拼凑出想要的字符串。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kobject_set_name</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * fmt, ...)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> limit = KOBJ_NAME_LEN;<br><span class="hljs-type">int</span> need;<br>va_list args;<span class="hljs-comment">//变参的必要部分</span><br><span class="hljs-type">char</span> * name;<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * First, try the static array </span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//看看这个名字能否放入数组kobj-&gt;name中</span><br>va_start(args,fmt);<br>need = vsnprintf(kobj-&gt;name,limit,fmt,args);<br>va_end(args);<br>    <span class="hljs-comment">//如果格式字串的总长度可以放入kobj-&gt;name中，那么用局部变量name指向它</span><br><span class="hljs-keyword">if</span> (need &lt; limit) <br>name = kobj-&gt;name;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Need more space? Allocate it and try again </span><br><span class="hljs-comment"> */</span><br>        <span class="hljs-comment">//否则需要动态申请一段空间，大小为need+1，标识字符串末尾还有&#x27;\0&#x27;</span><br>limit = need + <span class="hljs-number">1</span>;<br>name = kmalloc(limit,GFP_KERNEL);<br><span class="hljs-keyword">if</span> (!name) &#123;<br>error = -ENOMEM;<br><span class="hljs-keyword">goto</span> Done;<br>&#125;<br>        <span class="hljs-comment">//再将其放入动态申请的name中</span><br>va_start(args,fmt);<br>need = vsnprintf(name,limit,fmt,args);<br>va_end(args);<br><br><span class="hljs-comment">/* Still? Give up. */</span><br>        <span class="hljs-comment">//到这里是出了问题，一个兜底措施，如果need还大于等于limit，释放掉这段空间，防止内存泄漏</span><br><span class="hljs-keyword">if</span> (need &gt;= limit) &#123;<br>kfree(name);<br>error = -EFAULT;<br><span class="hljs-keyword">goto</span> Done;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Free the old name, if necessary. */</span><br>    <span class="hljs-comment">//释放旧名字，意味着这个kobj可能要变名称了，只有k_name表示该kobj的真实名字</span><br><span class="hljs-keyword">if</span> (kobj-&gt;k_name &amp;&amp; kobj-&gt;k_name != kobj-&gt;name)<br>kfree(kobj-&gt;k_name);<br><br><span class="hljs-comment">/* Now, set the new name */</span><br>    <span class="hljs-comment">//将新名字赋给k_name</span><br>kobj-&gt;k_name = name;<br> Done:<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-rename"><a href="#kobject-rename" class="headerlink" title="kobject_rename"></a>kobject_rename</h4><blockquote><p>重命名kobj</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kobject_rename</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj, <span class="hljs-type">char</span> *new_name)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//注意，kobj要用kobject_get来获取，使用结束后用kobject_put来释放</span><br>kobj = kobject_get(kobj);<br><span class="hljs-keyword">if</span> (!kobj)<br><span class="hljs-keyword">return</span> -EINVAL;<br>    <span class="hljs-comment">//将sysfs中的kobj的目录名进行修改</span><br>error = sysfs_rename_dir(kobj, new_name);<br>    <span class="hljs-comment">//释放kobj</span><br>kobject_put(kobj);<br><br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-del"><a href="#kobject-del" class="headerlink" title="kobject_del"></a>kobject_del</h4><blockquote><p>删除kobj对象，如果它在一个kset中，也将其从kset的list中删除</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kobject_del</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br>kobject_hotplug(kobj, KOBJ_REMOVE);<span class="hljs-comment">//热插拔的处理</span><br>sysfs_remove_dir(kobj);<span class="hljs-comment">//在sysfs中删除这个kobj</span><br>unlink(kobj);<span class="hljs-comment">//将这个kobj本身删除掉</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-unregister"><a href="#kobject-unregister" class="headerlink" title="kobject_unregister"></a>kobject_unregister</h4><blockquote><p>注销一个kobj对象</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kobject_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br>pr_debug(<span class="hljs-string">&quot;kobject %s: unregistering\n&quot;</span>,kobject_name(kobj));<br>kobject_del(kobj);<span class="hljs-comment">//删除kobj对象</span><br>kobject_put(kobj);<span class="hljs-comment">//递减其计数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-cleanup"><a href="#kobject-cleanup" class="headerlink" title="kobject_cleanup"></a>kobject_cleanup</h4><blockquote><p>释放kobj对象对应的资源，通过其注册时的<code>kobj-&gt;ktype-&gt;release</code>函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kobject_cleanup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobj_type</span> * <span class="hljs-title">t</span> =</span> get_ktype(kobj);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kset</span> * <span class="hljs-title">s</span> =</span> kobj-&gt;kset;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> * <span class="hljs-title">parent</span> =</span> kobj-&gt;parent;<br><br>pr_debug(<span class="hljs-string">&quot;kobject %s: cleaning up\n&quot;</span>,kobject_name(kobj));<br><span class="hljs-comment">//如果k_name ！= name，直接释放k_name，因为后面要将其置空，避免内存泄漏，那么可以想一想，如果这俩相等呢？</span><br>    <span class="hljs-comment">//如果相等，可以看看kobject_add和kobject_set_name这两个函数，此时，kobj-&gt;k_name就是指向kobj-&gt;name的指针，因此不用kfree</span><br>    <span class="hljs-keyword">if</span> (kobj-&gt;k_name != kobj-&gt;name)<br>kfree(kobj-&gt;k_name);<br>kobj-&gt;k_name = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//如果release存在，就调用其做一些该设备特殊的操作</span><br><span class="hljs-keyword">if</span> (t &amp;&amp; t-&gt;release)<br>t-&gt;release(kobj);<br>    <span class="hljs-comment">//如果这个kobj归属于某个kset，那么需要清除该kobj在这个kset中的痕迹</span><br><span class="hljs-keyword">if</span> (s)<br>kset_put(s);<br>    <span class="hljs-comment">//如果其parent存在，递减其parent的计数，因为递增一个kobj计数时，其parent的计数也要递增</span><br><span class="hljs-keyword">if</span> (parent) <br>kobject_put(parent);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kobject-put"><a href="#kobject-put" class="headerlink" title="kobject_put"></a>kobject_put</h4><blockquote><p>递减kobj的计数，如果降为0，调用kobject_release</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kobject_put</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kobject * kobj)</span><br>&#123;<br><span class="hljs-keyword">if</span> (kobj)<br>kref_put(&amp;kobj-&gt;kref, kobject_release);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-init"><a href="#kset-init" class="headerlink" title="kset_init"></a>kset_init</h4><blockquote><p>初始化一个kset</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kset_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>    <span class="hljs-comment">//初始化其内嵌的kobj</span><br>kobject_init(&amp;k-&gt;kobj);<br>    <span class="hljs-comment">//初始化其list，此时没有包含的kobj</span><br>INIT_LIST_HEAD(&amp;k-&gt;<span class="hljs-built_in">list</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-add"><a href="#kset-add" class="headerlink" title="kset_add"></a>kset_add</h4><blockquote><p>增加一个kset</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kset_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>    <span class="hljs-comment">//如果这个kset没有上级节点（parent和kset两重保障），并且这个kset归属于某个子系统，那么将其parent设置为子系统</span><br><span class="hljs-keyword">if</span> (!k-&gt;kobj.parent &amp;&amp; !k-&gt;kobj.kset &amp;&amp; k-&gt;subsys)<br>k-&gt;kobj.parent = &amp;k-&gt;subsys-&gt;kset.kobj;<br><span class="hljs-comment">//剩下的就是增加kobj了</span><br><span class="hljs-keyword">return</span> kobject_add(&amp;k-&gt;kobj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-register"><a href="#kset-register" class="headerlink" title="kset_register"></a>kset_register</h4><blockquote><p>注册kset</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kset_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>kset_init(k);<br><span class="hljs-keyword">return</span> kset_add(k);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-unregister"><a href="#kset-unregister" class="headerlink" title="kset_unregister"></a>kset_unregister</h4><blockquote><p>注销kset，其实就是注销kset中的kobj而已</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kset_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>kobject_unregister(&amp;k-&gt;kobj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="kset-find-obj"><a href="#kset-find-obj" class="headerlink" title="kset_find_obj"></a>kset_find_obj</h4><blockquote><p>在kset中搜索一个对象（遍历kset-&gt;list）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> kobject * <span class="hljs-title function_">kset_find_obj</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * kset, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * name)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> * <span class="hljs-title">entry</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> * <span class="hljs-title">ret</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//链表操作，使用信号量保护链表</span><br>down_read(&amp;kset-&gt;subsys-&gt;rwsem);<br>    <span class="hljs-comment">//遍历kset-&gt;list</span><br>list_for_each(entry,&amp;kset-&gt;<span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> * <span class="hljs-title">k</span> =</span> to_kobj(entry);<br>        <span class="hljs-comment">//第一个条件是判定这个kobj是否存在，第二个是看是否是查找的目标</span><br><span class="hljs-keyword">if</span> (kobject_name(k) &amp;&amp; !<span class="hljs-built_in">strcmp</span>(kobject_name(k),name)) &#123;<br>            <span class="hljs-comment">//如果找到了，递增这个kobj计数，然后跳出</span><br>ret = kobject_get(k);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>up_read(&amp;kset-&gt;subsys-&gt;rwsem);<br>    <span class="hljs-comment">//如果遍历完都没有找到，则这里返回的是NULL</span><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="subsystem-init"><a href="#subsystem-init" class="headerlink" title="subsystem_init"></a>subsystem_init</h4><blockquote><p>初始化一个子系统</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//子系统里面其实就一个读写信号量，一个kset，也就是初始化这俩就行</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">subsystem_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> subsystem * s)</span><br>&#123;<br>init_rwsem(&amp;s-&gt;rwsem);<br>kset_init(&amp;s-&gt;kset);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="subsystem-register"><a href="#subsystem-register" class="headerlink" title="subsystem_register"></a>subsystem_register</h4><blockquote><p>注册一个子系统</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//根据子系统的数据结构来看，注册一个子系统需要干些什么？</span><br><span class="hljs-comment">//注册时，需要填写其层级关系</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">subsystem_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> subsystem * s)</span><br>&#123;<br><span class="hljs-type">int</span> error;<br><br>subsystem_init(s);<br>    <span class="hljs-comment">//上一行的子系统初始化是没有赋值子系统的名字的，因此，这里注册子系统时，子系统的名字是用户提供</span><br>pr_debug(<span class="hljs-string">&quot;subsystem %s: registering\n&quot;</span>,s-&gt;kset.kobj.name);<br><span class="hljs-comment">//通过kset_add填写子系统的层级关系，如果填写成功</span><br><span class="hljs-keyword">if</span> (!(error = kset_add(&amp;s-&gt;kset))) &#123;<br>        <span class="hljs-comment">//如果这个子系统本身没有归属，就将其归属到其自身</span><br><span class="hljs-keyword">if</span> (!s-&gt;kset.subsys)<br>s-&gt;kset.subsys = s;<br>&#125;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="subsystem-unregister"><a href="#subsystem-unregister" class="headerlink" title="subsystem_unregister"></a>subsystem_unregister</h4><blockquote><p>注销子系统</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//直接注销kset即可</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">subsystem_unregister</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> subsystem * s)</span><br>&#123;<br>pr_debug(<span class="hljs-string">&quot;subsystem %s: unregistering\n&quot;</span>,s-&gt;kset.kobj.name);<br>kset_unregister(&amp;s-&gt;kset);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="subsys-create-file"><a href="#subsys-create-file" class="headerlink" title="subsys_create_file"></a>subsys_create_file</h4><blockquote><p>导出sysfs属性文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">subsys_create_file</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> subsystem * s, <span class="hljs-keyword">struct</span> subsys_attribute * a)</span><br>&#123;<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (subsys_get(s)) &#123;<br>        <span class="hljs-comment">//创建子系统的属性文件</span><br>error = sysfs_create_file(&amp;s-&gt;kset.kobj,&amp;a-&gt;attr);<br>subsys_put(s);<br>&#125;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="subsys-remove-file"><a href="#subsys-remove-file" class="headerlink" title="subsys_remove_file"></a>subsys_remove_file</h4><blockquote><p>移除sysfs属性文件</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">subsys_remove_file</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> subsystem * s, <span class="hljs-keyword">struct</span> subsys_attribute * a)</span><br>&#123;<br><span class="hljs-keyword">if</span> (subsys_get(s)) &#123;<br>sysfs_remove_file(&amp;s-&gt;kset.kobj,&amp;a-&gt;attr);<br>subsys_put(s);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、kobj体系流程梳理"><a href="#三、kobj体系流程梳理" class="headerlink" title="三、kobj体系流程梳理"></a>三、kobj体系流程梳理</h2><h3 id="子系统注册流程"><a href="#子系统注册流程" class="headerlink" title="子系统注册流程"></a>子系统注册流程</h3><p>在梳理注册流程时，需要谨记所涉及到的数据结构内容。</p><blockquote><p>注册最重要的功能就是为你新增的内容构建其层级关系</p></blockquote><p><code>subsystem_register</code>的参数是一个子系统结构体指针，其中有一个读写信号量和一个<code>kset</code>，因此在注册时，使用<code>subsystem_init</code>来先初始化这个子系统结构，其内容分别是初始化读写信号量和<code>kset</code>，这个<code>kset</code>是内嵌到子系统结构体中的，而<code>kset</code>中又内嵌了一个<code>kobj</code>表示其自身，因此这个<code>kobj</code>也要初始化，还有<code>kset</code>中的<code>list</code>链表结构，表示这个<code>kset</code>没有包含任何子节点。</p><p><code>kobj</code>的初始化则是初始化其计数器，表示<code>kobj</code>自身的链表结点，最后，重点来了，这个<code>kobj</code>如果有其上级节点，就将其上级节点的<code>kobj</code>计数加一，举个例子，比如一个<code>kset</code>含有5个<code>kobj</code>子节点，那么这个<code>kset</code> 本身的<code>kobj</code>的计数应该是6，包含<code>kset</code>本身。</p><p>此时<code>subsystem_init</code>的流程走完，<code>subsystem</code>结构的基础内容已被填充（其实主要是链表，信号量和计数的初始化），接下来，这个新增的子系统需要添加到<code>/sys</code>的树中，通过的就是<code>kset_add</code>，因为<code>subsystem</code>本身的存在是通过<code>kset</code>来表示的，这也是高版本中删除了<code>subsystem</code>的原因。</p><p><code>kset_add</code>中，会进行一个判断，如果你新增的这个<code>kset</code>没有<code>parent</code>，也没有上级<code>kset</code>，但是有所属的子系统，那么将这个<code>kset</code>的<code>parent</code>设置为这个子系统，注意，这里并没有为其上级<code>kset</code>赋值，这种情况一般对应于某个<code>kset</code>直接挂在子系统下，除了顶级子系统，其他节点都应该在树中的某个位置。</p><p>在初始化<code>devices</code>子系统时，其<code>parent</code>和上级<code>kset</code>均为NULL，但是，没有其所属子系统，因此顶级子系统是没有<code>parent</code>和<code>kset</code>的。</p><p>随后调用<code>kobject_add</code>，因为<code>kobj</code>是基石，整个模型是依据<code>kobj</code>构建的，对子系统，<code>kset</code>的操作，最终都会落到<code>kobj</code>上。<code>kobject_add</code>中最重要的操作，就是给<code>k_name</code>赋值，因为<code>kobj-&gt;name</code>一般是静态声明时写好的，但是注册是动态的，如何判断这个<code>kobj</code>已经注册了呢？就是在<code>kobject_add</code>中为<code>k_name</code>赋值的操作来声明，这个<code>kobj</code>已经注册了。</p><p>还要通过<code>kobject_get</code>来递增<code>kobj</code>的统计计数，如果其<code>parent</code>存在的话，也需要递增其计数。</p><p>然后，如果这个<code>kobj</code>归属于某个<code>kset</code>，就将这个<code>kobj</code>加到其所属<code>kset</code>的<code>list</code>链表中，此时，其所属<code>kset</code>就是这个<code>kobj</code>的<code>parent</code>，所以此时，如果之前其<code>parent</code>不存在的话，这里将其<code>parent</code>设置为其<code>kset</code>的<code>kobj</code>。</p><p>还记得之前说的<code>kobj</code>就是一个目录么？然后为这个<code>kobj</code>在<code>/sys</code>中创建对应的目录。</p><p>回到<code>subsystem_register</code>，如果创建<code>kset</code>成功，则error返回0，满足if的条件，那么如果这个子系统没有归属的子系统时，就将其子系统设置为其自身，至此，子系统注册流程结束。</p><blockquote><p>以devices子系统为例，在其注册完成后，其s-&gt;kset-&gt;kobj-&gt;parent&#x3D;NULL，s-&gt;kset-&gt;kobj-&gt;kset&#x3D;NULL，s-&gt;kset-&gt;subsys&#x3D;s。可以看到，顶级子系统没有parent，没有kset，但是有subsys</p></blockquote><h4 id="例子：devices-init"><a href="#例子：devices-init" class="headerlink" title="例子：devices_init"></a>例子：devices_init</h4><blockquote><p>设备子系统初始化，即一级目录devices</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __init <span class="hljs-title function_">devices_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> subsystem_register(&amp;devices_subsys);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里初始化一个设备子系统，其中的<code>devices_subsys</code>由宏生成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">decl_subsys(devices, &amp;ktype_device, &amp;device_hotplug_ops);<br></code></pre></td></tr></table></figure><p>它声明了一个子系统结构体，并将其kset进行赋值，分别是kset-&gt;kobj-&gt;name，kset-&gt;ktype，kset-&gt;hotplug_ops。</p><p>有一个值得注意的小细节，devices子系统是顶层子系统，因此没有上级节点，在注册时，这个子系统的<code>subsys-&gt;kset-&gt;kobj-&gt;parent=NULL</code>，作为对比，当注册<code>system</code>子系统时，由于该子系统归属于<code>devices</code>子系统， 因此在其注册时，这个区别会在kset_add时显示出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//声明system子系统</span><br>decl_subsys(system, &amp;ktype_sysdev, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">int</span> __init <span class="hljs-title function_">system_bus_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//这里注意，由于这个子系统存在上级子系统，那么其parent要设置好，而这个子系统归属于devices子系统，其parent就是devices_subsys.kset.kobj</span><br>system_subsys.kset.kobj.parent = &amp;devices_subsys.kset.kobj;<br><span class="hljs-keyword">return</span> subsystem_register(&amp;system_subsys);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">kset_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kset * k)</span><br>&#123;<br>    <span class="hljs-comment">//看这里的区别，如果其有上级节点，就不赋值parent，否则没有，但是有归属子系统，就将其上级节点设为这个子系统</span><br><span class="hljs-keyword">if</span> (!k-&gt;kobj.parent &amp;&amp; !k-&gt;kobj.kset &amp;&amp; k-&gt;subsys)<br>k-&gt;kobj.parent = &amp;k-&gt;subsys-&gt;kset.kobj;<br><br><span class="hljs-keyword">return</span> kobject_add(&amp;k-&gt;kobj);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bus-init"><a href="#bus-init" class="headerlink" title="bus_init"></a>bus_init</h4><blockquote><p>总线子系统初始化，即一级目录bus</p></blockquote><p>同<code>devices_init</code>差不多</p><h2 id="四、linux驱动模型"><a href="#四、linux驱动模型" class="headerlink" title="四、linux驱动模型"></a>四、linux驱动模型</h2><h3 id="driver-init——驱动模型初始化"><a href="#driver-init——驱动模型初始化" class="headerlink" title="driver_init——驱动模型初始化"></a>driver_init——驱动模型初始化</h3><p>linux的驱动初始化由<code>driver_init</code>开始，该函数准备好驱动框架，注册好一些<code>/sys</code>目录下的一级目录，比如<code>devices</code>，<code>bus</code>，<code>class</code>，等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">driver_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/* These are the core pieces */</span><br>devices_init(); <span class="hljs-comment">//devices目录</span><br>buses_init();  <span class="hljs-comment">//bus目录</span><br>classes_init(); <span class="hljs-comment">//class目录</span><br>firmware_init(); <span class="hljs-comment">//firmware目录</span><br><br><span class="hljs-comment">/* These are also core pieces, but must come after the</span><br><span class="hljs-comment"> * core core pieces.</span><br><span class="hljs-comment"> */</span><br>platform_bus_init(); <span class="hljs-comment">//platform目录</span><br>system_bus_init(); <span class="hljs-comment">//devices下的system目录</span><br>cpu_dev_init();  <span class="hljs-comment">//cpu目录</span><br>attribute_container_init();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>do_initcalls</code>里面进行具体某个驱动的注册。</p><h3 id="bus-register——总线注册"><a href="#bus-register——总线注册" class="headerlink" title="bus_register——总线注册"></a>bus_register——总线注册</h3><p>向系统注册一个总线，会被增加到<code>/sys/bus</code>目录中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bus_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bus_type * bus)</span><br>&#123;<br><span class="hljs-type">int</span> retval;<br><span class="hljs-comment">//这里其实就是设置总线内嵌的kobj的名字</span><br>retval = kobject_set_name(&amp;bus-&gt;subsys.kset.kobj, <span class="hljs-string">&quot;%s&quot;</span>, bus-&gt;name);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-comment">//这里是设置这个总线所属的kset，即：声明这个总线是属于总线子系统的！</span><br>    <span class="hljs-comment">//等价于bus-&gt;subsys-&gt;kset-&gt;kobj-&gt;kset = bus_subsys.kset</span><br>subsys_set_kset(bus, bus_subsys);<br>    <span class="hljs-comment">//向系统注册这个总线</span><br>retval = subsystem_register(&amp;bus-&gt;subsys);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-comment">//设置总线包含的device的名字（这里的devices是个kset，它还没有设置名字）</span><br>kobject_set_name(&amp;bus-&gt;devices.kobj, <span class="hljs-string">&quot;devices&quot;</span>);<br>    <span class="hljs-comment">//devices这个kset的子系统</span><br>bus-&gt;devices.subsys = &amp;bus-&gt;subsys;<br>    <span class="hljs-comment">//注册这个kset</span><br>retval = kset_register(&amp;bus-&gt;devices);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_devices_fail;<br><span class="hljs-comment">//同理，driver这个kset的设置</span><br>kobject_set_name(&amp;bus-&gt;drivers.kobj, <span class="hljs-string">&quot;drivers&quot;</span>);<br>bus-&gt;drivers.subsys = &amp;bus-&gt;subsys;<br>bus-&gt;drivers.ktype = &amp;ktype_driver;<br>retval = kset_register(&amp;bus-&gt;drivers);<br><span class="hljs-keyword">if</span> (retval)<br><span class="hljs-keyword">goto</span> bus_drivers_fail;<br>    <span class="hljs-comment">//增加这个总线的属性</span><br>bus_add_attrs(bus);<br><br>pr_debug(<span class="hljs-string">&quot;bus type &#x27;%s&#x27; registered\n&quot;</span>, bus-&gt;name);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bus_drivers_fail:<br>kset_unregister(&amp;bus-&gt;devices);<br>bus_devices_fail:<br>subsystem_unregister(&amp;bus-&gt;subsys);<br>out:<br><span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="device-register——设备注册"><a href="#device-register——设备注册" class="headerlink" title="device_register——设备注册"></a>device_register——设备注册</h3><p>向系统注册一个设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">device_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>    <span class="hljs-comment">//初始化这个设备</span><br>device_initialize(dev);<br>    <span class="hljs-comment">//将设备增加到某个总线中</span><br><span class="hljs-keyword">return</span> device_add(dev);<br>&#125;<br></code></pre></td></tr></table></figure><p>设备的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">device_initialize</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br>    <span class="hljs-comment">//首先，设置这个设备所属的kset，设备肯定要属于一个设备子系统</span><br>kobj_set_kset_s(dev, devices_subsys);<br>    <span class="hljs-comment">//初始化设备 内嵌的kobj</span><br>kobject_init(&amp;dev-&gt;kobj);<br>    <span class="hljs-comment">//初始化相关链表</span><br>INIT_LIST_HEAD(&amp;dev-&gt;node);<span class="hljs-comment">//用来串联兄弟设备</span><br>INIT_LIST_HEAD(&amp;dev-&gt;children);<span class="hljs-comment">//子设备挂在这个节点</span><br>INIT_LIST_HEAD(&amp;dev-&gt;driver_list);<span class="hljs-comment">//指向驱动链表</span><br>INIT_LIST_HEAD(&amp;dev-&gt;bus_list);<span class="hljs-comment">//指向同一总线的其他设备</span><br>INIT_LIST_HEAD(&amp;dev-&gt;dma_pools);<span class="hljs-comment">//DMA缓冲池链表的首部</span><br>&#125;<br></code></pre></td></tr></table></figure><p>增加一个设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">device_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> *<span class="hljs-title">parent</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> error = -EINVAL;<br><br>    <span class="hljs-comment">//递增计数器</span><br>dev = get_device(dev);<br>    <span class="hljs-comment">//判断bus_id是否存在，这是一个类似于k_name的结构，这个设备被注册后，会分配一个bus_id，这个id表明设备名字+编号，比如这个bus上挂了五个同类串口设备，那么这五个设备的bus_id可能是serial1,serial2,...</span><br><span class="hljs-keyword">if</span> (!dev || !<span class="hljs-built_in">strlen</span>(dev-&gt;bus_id))<br><span class="hljs-keyword">goto</span> Error;<br><span class="hljs-comment">//递增其父设备的计数</span><br>parent = get_device(dev-&gt;parent);<br><br>pr_debug(<span class="hljs-string">&quot;DEV: registering device: ID = &#x27;%s&#x27;\n&quot;</span>, dev-&gt;bus_id);<br><br><span class="hljs-comment">/* first, register with generic layer. */</span><br>    <span class="hljs-comment">//将bus_id的名字赋给这个设备内嵌的kobj</span><br>kobject_set_name(&amp;dev-&gt;kobj, <span class="hljs-string">&quot;%s&quot;</span>, dev-&gt;bus_id);<br>    <span class="hljs-comment">//如果存在父设备，就将其设备的kobj也设置父节点</span><br><span class="hljs-keyword">if</span> (parent)<br>dev-&gt;kobj.parent = &amp;parent-&gt;kobj;<br><br>    <span class="hljs-comment">//增加这个kobj</span><br><span class="hljs-keyword">if</span> ((error = kobject_add(&amp;dev-&gt;kobj)))<br><span class="hljs-keyword">goto</span> Error;<br>    <span class="hljs-comment">//电源管理相关</span><br><span class="hljs-keyword">if</span> ((error = device_pm_add(dev)))<br><span class="hljs-keyword">goto</span> PMError;<br>    <span class="hljs-comment">//让这个总线增加这个设备</span><br><span class="hljs-keyword">if</span> ((error = bus_add_device(dev)))<br><span class="hljs-keyword">goto</span> BusError;<br>down_write(&amp;devices_subsys.rwsem);<br>    <span class="hljs-comment">//如果存在父设备，就将这个设备加入到父设备的children的链表中</span><br><span class="hljs-keyword">if</span> (parent)<br>list_add_tail(&amp;dev-&gt;node, &amp;parent-&gt;children);<br>up_write(&amp;devices_subsys.rwsem);<br><br><span class="hljs-comment">/* notify platform of device entry */</span><br>    <span class="hljs-comment">//平台设备的通知链</span><br><span class="hljs-keyword">if</span> (platform_notify)<br>platform_notify(dev);<br> Done:<br>put_device(dev);<br><span class="hljs-keyword">return</span> error;<br> BusError:<br>device_pm_remove(dev);<br> PMError:<br>kobject_del(&amp;dev-&gt;kobj);<br> Error:<br><span class="hljs-keyword">if</span> (parent)<br>put_device(parent);<br><span class="hljs-keyword">goto</span> Done;<br>&#125;<br></code></pre></td></tr></table></figure><p>总线去增加这个设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bus_add_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device * dev)</span><br>&#123;<br>    <span class="hljs-comment">//得到这个设备的总线</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> * <span class="hljs-title">bus</span> =</span> get_bus(dev-&gt;bus);<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//如果这个总线存在，不存在就没啥操作了</span><br><span class="hljs-keyword">if</span> (bus) &#123;<br>down_write(&amp;dev-&gt;bus-&gt;subsys.rwsem);<br>pr_debug(<span class="hljs-string">&quot;bus %s: add device %s\n&quot;</span>, bus-&gt;name, dev-&gt;bus_id);<br>        <span class="hljs-comment">//将这个设备增加到该设备所属的总线的设备链表中</span><br>list_add_tail(&amp;dev-&gt;bus_list, &amp;dev-&gt;bus-&gt;devices.<span class="hljs-built_in">list</span>);<br>        <span class="hljs-comment">//关键点！</span><br>        <span class="hljs-comment">//让这个设备去搜寻其对应的设备驱动</span><br>device_attach(dev);<br>up_write(&amp;dev-&gt;bus-&gt;subsys.rwsem);<br>        <span class="hljs-comment">//增加这个设备对应的属性文件</span><br>device_add_attrs(bus, dev);<br>        <span class="hljs-comment">//增加符号链接</span><br>sysfs_create_link(&amp;bus-&gt;devices.kobj, &amp;dev-&gt;kobj, dev-&gt;bus_id);<br>&#125;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心函数——找一个驱动去匹配这个设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">device_attach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device * dev)</span><br>&#123;<br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> * <span class="hljs-title">bus</span> =</span> dev-&gt;bus;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> * <span class="hljs-title">entry</span>;</span><br><span class="hljs-type">int</span> error;<br><br>    <span class="hljs-comment">//如果这个设备本身有驱动，就直接将这个设备和其驱动绑定</span><br><span class="hljs-keyword">if</span> (dev-&gt;driver) &#123;<br>device_bind_driver(dev);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//走到这里，说明没有绑定的驱动，那么可以通过总线的match函数搜索驱动</span><br><span class="hljs-keyword">if</span> (bus-&gt;match) &#123;<br>        <span class="hljs-comment">//遍历这个总线的所有驱动</span><br>list_for_each(entry, &amp;bus-&gt;drivers.<span class="hljs-built_in">list</span>) &#123;<br>            <span class="hljs-comment">//得到这个驱动</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_driver</span> * <span class="hljs-title">drv</span> =</span> to_drv(entry);<br>            <span class="hljs-comment">//调用这个驱动去绑定设备</span><br>error = driver_probe_device(drv, dev);<br>            <span class="hljs-comment">//如果绑定成功，return 1</span><br><span class="hljs-keyword">if</span> (!error)<br><span class="hljs-comment">/* success, driver matched */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//否则，看是否是没有设备或者IO占用，报错</span><br><span class="hljs-keyword">if</span> (error != -ENODEV &amp;&amp; error != -ENXIO)<br><span class="hljs-comment">/* driver matched but the probe failed */</span><br>printk(KERN_WARNING<br>    <span class="hljs-string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,<br>    drv-&gt;name, dev-&gt;bus_id, error);<br>&#125;<br>&#125;<br><span class="hljs-comment">//return 0说明没有匹配成功</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>驱动去尝试probe设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">driver_probe_device</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_driver * drv, <span class="hljs-keyword">struct</span> device * dev)</span><br>&#123;<br>    <span class="hljs-comment">//如果这个设备所属的总线有match函数，那么调用这个match</span><br><span class="hljs-keyword">if</span> (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv))<br><span class="hljs-keyword">return</span> -ENODEV;<br><br>    <span class="hljs-comment">//给这个设备所属的驱动赋值，说明这个设备现在有对应的驱动了</span><br>dev-&gt;driver = drv;<br>    <span class="hljs-comment">//调用驱动的probe</span><br><span class="hljs-keyword">if</span> (drv-&gt;probe) &#123;<br><span class="hljs-type">int</span> error = drv-&gt;probe(dev);<br>        <span class="hljs-comment">//如果出错，就返回错误</span><br><span class="hljs-keyword">if</span> (error) &#123;<br>dev-&gt;driver = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br>&#125;<br><span class="hljs-comment">//否则到了这里，说明一级找到了设备对应的驱动，那么进行绑定</span><br>device_bind_driver(dev);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>设备绑定驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">device_bind_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device * dev)</span><br>&#123;<br>pr_debug(<span class="hljs-string">&quot;bound device &#x27;%s&#x27; to driver &#x27;%s&#x27;\n&quot;</span>,<br> dev-&gt;bus_id, dev-&gt;driver-&gt;name);<br>    <span class="hljs-comment">//这里做真正的绑定操作，将这个设备的链表节点加入到驱动的devices链表中</span><br>list_add_tail(&amp;dev-&gt;driver_list, &amp;dev-&gt;driver-&gt;devices);<br>sysfs_create_link(&amp;dev-&gt;driver-&gt;kobj, &amp;dev-&gt;kobj,<br>  kobject_name(&amp;dev-&gt;kobj));<br>sysfs_create_link(&amp;dev-&gt;kobj, &amp;dev-&gt;driver-&gt;kobj, <span class="hljs-string">&quot;driver&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="driver-register——驱动注册"><a href="#driver-register——驱动注册" class="headerlink" title="driver_register——驱动注册"></a>driver_register——驱动注册</h3><p>向系统注册一个驱动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">driver_register</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_driver * drv)</span><br>&#123;<br>    <span class="hljs-comment">//初始化链表，devices是这个驱动所能支持的设备</span><br>INIT_LIST_HEAD(&amp;drv-&gt;devices);<br>    <span class="hljs-comment">//初始化锁</span><br>init_MUTEX_LOCKED(&amp;drv-&gt;unload_sem);<br>    <span class="hljs-comment">//bus增加一个驱动</span><br><span class="hljs-keyword">return</span> bus_add_driver(drv);<br>&#125;<br></code></pre></td></tr></table></figure><p>向bus增加一个驱动，可以和bus增加一个设备比较一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bus_add_driver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_driver * drv)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> * <span class="hljs-title">bus</span> =</span> get_bus(drv-&gt;bus);<br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br>    <br><span class="hljs-comment">//如果bus存在</span><br><span class="hljs-keyword">if</span> (bus) &#123;<br>pr_debug(<span class="hljs-string">&quot;bus %s: add driver %s\n&quot;</span>, bus-&gt;name, drv-&gt;name);<br>        <span class="hljs-comment">//设置这个驱动的名字到驱动的kobj中</span><br>error = kobject_set_name(&amp;drv-&gt;kobj, <span class="hljs-string">&quot;%s&quot;</span>, drv-&gt;name);<br><span class="hljs-keyword">if</span> (error) &#123;<br>put_bus(bus);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br>        <span class="hljs-comment">//驱动的上级节点是这个总线的driver这个kset</span><br>drv-&gt;kobj.kset = &amp;bus-&gt;drivers;<br>        <span class="hljs-comment">//向系统注册这个驱动</span><br><span class="hljs-keyword">if</span> ((error = kobject_register(&amp;drv-&gt;kobj))) &#123;<br>put_bus(bus);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br><br>down_write(&amp;bus-&gt;subsys.rwsem);<br>        <span class="hljs-comment">//关键函数，驱动去找设备</span><br>driver_attach(drv);<br>up_write(&amp;bus-&gt;subsys.rwsem);<br>        <span class="hljs-comment">//模块相关</span><br>module_add_driver(drv-&gt;owner, drv);<br><span class="hljs-comment">//驱动增加属性文件</span><br>driver_add_attrs(bus, drv);<br>&#125;<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>驱动绑定设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">driver_attach</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device_driver * drv)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bus_type</span> * <span class="hljs-title">bus</span> =</span> drv-&gt;bus;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> * <span class="hljs-title">entry</span>;</span><br><span class="hljs-type">int</span> error;<br><br>    <span class="hljs-comment">//如果这个总线没有match函数，直接返回</span><br><span class="hljs-keyword">if</span> (!bus-&gt;match)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//遍历总线下的所有设备</span><br>list_for_each(entry, &amp;bus-&gt;devices.<span class="hljs-built_in">list</span>) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span> * <span class="hljs-title">dev</span> =</span> container_of(entry, <span class="hljs-keyword">struct</span> device, bus_list);<br>        <span class="hljs-comment">//如果这个设备还没有驱动（有设备的驱动就不用管了，人家有主了）</span><br><span class="hljs-keyword">if</span> (!dev-&gt;driver) &#123;<br>            <span class="hljs-comment">//仍旧是驱动probe设备</span><br>error = driver_probe_device(drv, dev);<br>            <span class="hljs-comment">//如果出错，并且错误不是没有设备（有其他令人发愁的错误出现了QAQ）</span><br><span class="hljs-keyword">if</span> (error &amp;&amp; (error != -ENODEV))<br><span class="hljs-comment">/* driver matched but the probe failed */</span><br>printk(KERN_WARNING<br>    <span class="hljs-string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,<br>    drv-&gt;name, dev-&gt;bus_id, error);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kojb</tag>
      
      <tag>device driver model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM64架构设备树初始化流程详解</title>
    <link href="/2025/01/06/ARM64%E6%9E%B6%E6%9E%84%E8%AE%BE%E5%A4%87%E6%A0%91%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/01/06/ARM64%E6%9E%B6%E6%9E%84%E8%AE%BE%E5%A4%87%E6%A0%91%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="ARM64架构设备树初始化流程"><a href="#ARM64架构设备树初始化流程" class="headerlink" title="ARM64架构设备树初始化流程"></a>ARM64架构设备树初始化流程</h1><h2 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h2><p>arm64架构的head.S中，有这样一句，其中的x21寄存器存放的是FDT的物理地址，从uboot&#x2F;ueft+grub等bootloader里面传过来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">str_lx21, __fdt_pointer, x5// Save FDT pointer<br></code></pre></td></tr></table></figure><p>这里的<code>__fdt_pointer</code>定义在<code>arch/arm64/kernel/setup.c</code>中，<code>__initdata</code>表明这个变量链接时放在初始化数据段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __initdata__section(.init.data)</span><br><span class="hljs-type">phys_addr_t</span> __fdt_pointer __initdata;<br></code></pre></td></tr></table></figure><p>此时FDT的物理地址就保存在了<code>__fdt_pointer</code>里面。</p><h2 id="由物理地址到虚拟地址"><a href="#由物理地址到虚拟地址" class="headerlink" title="由物理地址到虚拟地址"></a>由物理地址到虚拟地址</h2><p>来到<code>setup_arch</code>中，首先相关的第一个函数是<code>setup_machine_fdt</code>，它传入刚才的<code>__fdt_pointer</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_arch</span><span class="hljs-params">(<span class="hljs-type">char</span> **cmdline_p)</span> &#123;<br>    <span class="hljs-comment">//......</span><br>setup_machine_fdt(__fdt_pointer);<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，这里的<code>setup_machine_fdt</code>主要是为了将物理地址映射为内核可读的虚拟地址，因为此时已经开了MMU，物理地址不可读了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_machine_fdt</span><span class="hljs-params">(<span class="hljs-type">phys_addr_t</span> dt_phys)</span><br>&#123;<br><span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">//这里将物理地址映射到虚拟地址上，创建固定映射，fdt的大小会保存在size中</span><br><span class="hljs-type">void</span> *dt_virt = fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL);<br><br>    <span class="hljs-comment">//如果成功申请到了，就将这块地址保留下来</span><br><span class="hljs-keyword">if</span> (dt_virt)<br>memblock_reserve(dt_phys, size);<br><br>    <span class="hljs-comment">//如果没有成功申请到，或者设备树早期扫描失败，直接宕机</span><br><span class="hljs-keyword">if</span> (!dt_virt || !early_init_dt_scan(dt_virt)) &#123;<br>pr_crit(<span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-string">&quot;Error: invalid device tree blob at physical address %pa (virtual address 0x%p)\n&quot;</span><br><span class="hljs-string">&quot;The dtb must be 8-byte aligned and must not exceed 2 MB in size\n&quot;</span><br><span class="hljs-string">&quot;\nPlease check your bootloader.&quot;</span>,<br>&amp;dt_phys, dt_virt);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>cpu_relax();<br>&#125;<br><br><span class="hljs-comment">/* Early fixups are done, map the FDT as read-only now */</span><br>    <span class="hljs-comment">//重新将这段内存映射为只读的</span><br>fixmap_remap_fdt(dt_phys, &amp;size, PAGE_KERNEL_RO);<br><span class="hljs-comment">//功能无关，无需关注</span><br>dump_stack_set_arch_desc(<span class="hljs-string">&quot;%s (DT)&quot;</span>, of_flat_dt_get_machine_name());<br>&#125;<br></code></pre></td></tr></table></figure><p>首先看一下设备树早期扫描函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fdt_check_header</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *fdt)</span><br>&#123;<br><span class="hljs-keyword">if</span> (fdt_magic(fdt) == FDT_MAGIC) &#123;<br><span class="hljs-comment">/* Complete tree */</span><br><span class="hljs-keyword">if</span> (fdt_version(fdt) &lt; FDT_FIRST_SUPPORTED_VERSION)<br><span class="hljs-keyword">return</span> -FDT_ERR_BADVERSION;<br><span class="hljs-keyword">if</span> (fdt_last_comp_version(fdt) &gt; FDT_LAST_SUPPORTED_VERSION)<br><span class="hljs-keyword">return</span> -FDT_ERR_BADVERSION;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fdt_magic(fdt) == FDT_SW_MAGIC) &#123;<br><span class="hljs-comment">/* Unfinished sequential-write blob */</span><br><span class="hljs-keyword">if</span> (fdt_size_dt_struct(fdt) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> -FDT_ERR_BADSTATE;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> -FDT_ERR_BADMAGIC;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> __init <span class="hljs-title function_">early_init_dt_verify</span><span class="hljs-params">(<span class="hljs-type">void</span> *params)</span><br>&#123;<br><span class="hljs-keyword">if</span> (!params)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/* check device tree validity */</span><br>    <span class="hljs-comment">//设备树的有效性检测，魔数之类的</span><br><span class="hljs-keyword">if</span> (fdt_check_header(params))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">/* Setup flat device-tree pointer */</span><br>initial_boot_params = params;<br>    <span class="hljs-comment">//crc32的校验</span><br>of_fdt_crc32 = crc32_be(~<span class="hljs-number">0</span>, initial_boot_params,<br>fdt_totalsize(initial_boot_params));<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> __init <span class="hljs-title function_">early_init_dt_scan</span><span class="hljs-params">(<span class="hljs-type">void</span> *params)</span><br>&#123;<br><span class="hljs-type">bool</span> status;<br><br>status = early_init_dt_verify(params);<br>    <span class="hljs-comment">//由上面可以看到，基本上是fdt格式不对，或者crc校验不过，这里false返回</span><br><span class="hljs-keyword">if</span> (!status)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//否者就先扫描设备树的节点</span><br>early_init_dt_scan_nodes();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>早期设备树节点的扫描，这一步主要是获得设备树的<code>cells</code>，别名，可选属性，内存信息等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">early_init_dt_scan_nodes</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/* Retrieve various information from the /chosen node */</span><br>of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);<br><br><span class="hljs-comment">/* Initialize &#123;size,address&#125;-cells info */</span><br>of_scan_flat_dt(early_init_dt_scan_root, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">/* Setup memory, calling early_init_dt_add_memory_arch */</span><br>of_scan_flat_dt(early_init_dt_scan_memory, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>之后会来到解压设备树的部分，如果没有开启acpi，那么默认开始将dtb展开，完成将设备树转换为device_node的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __init <span class="hljs-title function_">setup_arch</span><span class="hljs-params">(<span class="hljs-type">char</span> **cmdline_p)</span> &#123;<br>    <span class="hljs-comment">//......</span><br><span class="hljs-keyword">if</span> (acpi_disabled)<br>unflatten_device_tree();<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么，解压设备树时需要传入几个参数，这些参数分别定义在哪里呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * unflatten_device_tree - create tree of device_nodes from flat blob</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * unflattens the device-tree passed by the firmware, creating the</span><br><span class="hljs-comment"> * tree of struct device_node. It also fills the &quot;name&quot; and &quot;type&quot;</span><br><span class="hljs-comment"> * pointers of the nodes so the normal device-tree walking functions</span><br><span class="hljs-comment"> * can be used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> __init <span class="hljs-title function_">unflatten_device_tree</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>__unflatten_device_tree(initial_boot_params, <span class="hljs-literal">NULL</span>, &amp;of_root,<br>early_init_dt_alloc_memory_arch, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">/* Get pointer to &quot;/chosen&quot; and &quot;/aliases&quot; nodes for use everywhere */</span><br>of_alias_scan(early_init_dt_alloc_memory_arch);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>initial_boot_param</code>定义在<code>drivers/of/fdt.c</code>中，并且在<code>early_init_dt_verify</code>中被赋予了fdt的虚拟地址值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *initial_boot_params;<br><span class="hljs-type">bool</span> __init <span class="hljs-title function_">early_init_dt_verify</span><span class="hljs-params">(<span class="hljs-type">void</span> *params)</span><br>&#123;<br><span class="hljs-comment">//.....</span><br><span class="hljs-comment">/* Setup flat device-tree pointer */</span><br>initial_boot_params = params;<br><span class="hljs-comment">//.....</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>of_root</code>则是系统中的根节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">of_root</span>;</span><br></code></pre></td></tr></table></figure><p>接下来是<code>__unflatten_device_tree</code>，这个函数用来实际创建device_node节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __unflatten_device_tree - create tree of device_nodes from flat blob</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * unflattens a device-tree, creating the</span><br><span class="hljs-comment"> * tree of struct device_node. It also fills the &quot;name&quot; and &quot;type&quot;</span><br><span class="hljs-comment"> * pointers of the nodes so the normal device-tree walking functions</span><br><span class="hljs-comment"> * can be used.</span><br><span class="hljs-comment"> * @blob: The blob to expand</span><br><span class="hljs-comment"> * @dad: Parent device node</span><br><span class="hljs-comment"> * @mynodes: The device_node tree created by the call</span><br><span class="hljs-comment"> * @dt_alloc: An allocator that provides a virtual address to memory</span><br><span class="hljs-comment"> * for the resulting tree</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Returns NULL on failure or the memory chunk containing the unflattened</span><br><span class="hljs-comment"> * device tree on success.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *__unflatten_device_tree(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *blob,<br>     <span class="hljs-keyword">struct</span> device_node *dad,<br>     <span class="hljs-keyword">struct</span> device_node **mynodes,<br>     <span class="hljs-type">void</span> *(*dt_alloc)(u64 size, u64 align),<br>     <span class="hljs-type">bool</span> detached)<br>&#123;<br><span class="hljs-type">int</span> size;<br><span class="hljs-type">void</span> *mem;<br><br>pr_debug(<span class="hljs-string">&quot; -&gt; unflatten_device_tree()\n&quot;</span>);<br><br>    <span class="hljs-comment">//blob是fdt的虚拟地址</span><br><span class="hljs-keyword">if</span> (!blob) &#123;<br>pr_debug(<span class="hljs-string">&quot;No device tree pointer\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>pr_debug(<span class="hljs-string">&quot;Unflattening device tree:\n&quot;</span>);<br>pr_debug(<span class="hljs-string">&quot;magic: %08x\n&quot;</span>, fdt_magic(blob));<br>pr_debug(<span class="hljs-string">&quot;size: %08x\n&quot;</span>, fdt_totalsize(blob));<br>pr_debug(<span class="hljs-string">&quot;version: %08x\n&quot;</span>, fdt_version(blob));<br><br>    <span class="hljs-comment">//fdt头的合法性检查</span><br><span class="hljs-keyword">if</span> (fdt_check_header(blob)) &#123;<br>pr_err(<span class="hljs-string">&quot;Invalid device tree blob header\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">/* First pass, scan for size */</span><br>    <span class="hljs-comment">//第一次调用，只获得其展开为node后的大小，而不实际展开</span><br>size = unflatten_dt_nodes(blob, <span class="hljs-literal">NULL</span>, dad, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//4字节对齐</span><br>size = ALIGN(size, <span class="hljs-number">4</span>);<br>pr_debug(<span class="hljs-string">&quot;  size is %d, allocating...\n&quot;</span>, size);<br><br><span class="hljs-comment">/* Allocate memory for the expanded device tree */</span><br>    <span class="hljs-comment">//为node分配内存空间，注意调用的是传入的回调函数，并且size多了四个字节，用来放魔数</span><br>mem = dt_alloc(size + <span class="hljs-number">4</span>, __alignof__(<span class="hljs-keyword">struct</span> device_node));<br><span class="hljs-keyword">if</span> (!mem)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, size);<br><br>    <span class="hljs-comment">//在这块内存最后放魔数</span><br>*(__be32 *)(mem + size) = cpu_to_be32(<span class="hljs-number">0xdeadbeef</span>);<br><br>pr_debug(<span class="hljs-string">&quot;  unflattening %p...\n&quot;</span>, mem);<br><br><span class="hljs-comment">/* Second pass, do actual unflattening */</span><br>    <span class="hljs-comment">//实际的展开dtb到node</span><br>unflatten_dt_nodes(blob, mem, dad, mynodes);<br>    <span class="hljs-comment">//超过边界了！！！</span><br><span class="hljs-keyword">if</span> (be32_to_cpup(mem + size) != <span class="hljs-number">0xdeadbeef</span>)<br>pr_warning(<span class="hljs-string">&quot;End of tree marker overwritten: %08x\n&quot;</span>,<br>   be32_to_cpup(mem + size));<br><span class="hljs-comment">//如果设置了detached并且mynodes存在，将这个设备树设置为detached状态</span><br><span class="hljs-keyword">if</span> (detached &amp;&amp; mynodes) &#123;<br>of_node_set_flag(*mynodes, OF_DETACHED);<br>pr_debug(<span class="hljs-string">&quot;unflattened tree is detached\n&quot;</span>);<br>&#125;<br><br>pr_debug(<span class="hljs-string">&quot; &lt;- unflatten_device_tree()\n&quot;</span>);<br><span class="hljs-keyword">return</span> mem;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以见到，核心函数是<code>unflatten_dt_nodes</code>，注意，在第一次执行该函数时，只获得其展开后的内存区域大小，这次调用，mem&#x3D;NULL，dad&#x3D;NULL，nodepp&#x3D;of_root</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * unflatten_dt_nodes - Alloc and populate a device_node from the flat tree</span><br><span class="hljs-comment"> * @blob: The parent device tree blob</span><br><span class="hljs-comment"> * @mem: Memory chunk to use for allocating device nodes and properties</span><br><span class="hljs-comment"> * @dad: Parent struct device_node</span><br><span class="hljs-comment"> * @nodepp: The device_node tree created by the call</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * It returns the size of unflattened device tree or error code</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">unflatten_dt_nodes</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *blob,</span><br><span class="hljs-params">      <span class="hljs-type">void</span> *mem,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> device_node *dad,</span><br><span class="hljs-params">      <span class="hljs-keyword">struct</span> device_node **nodepp)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">root</span>;</span><br><span class="hljs-type">int</span> offset = <span class="hljs-number">0</span>, depth = <span class="hljs-number">0</span>, initial_depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//节点最大嵌套深度</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FDT_MAX_DEPTH64</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fpsizes[FDT_MAX_DEPTH];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">nps</span>[<span class="hljs-title">FDT_MAX_DEPTH</span>];</span><br><span class="hljs-type">void</span> *base = mem;<br>    <span class="hljs-comment">//这里的dryrun只有在没有传入mem时为真，此时只返回设备树展开后的大小，而不是真的展开设备树</span><br><span class="hljs-type">bool</span> dryrun = !base;<br><br><span class="hljs-keyword">if</span> (nodepp)<br>*nodepp = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We&#x27;re unflattening device sub-tree if @dad is valid. There are</span><br><span class="hljs-comment"> * possibly multiple nodes in the first level of depth. We need</span><br><span class="hljs-comment"> * set @depth to 1 to make fdt_next_node() happy as it bails</span><br><span class="hljs-comment"> * immediately when negative @depth is found. Otherwise, the device</span><br><span class="hljs-comment"> * nodes except the first one won&#x27;t be unflattened successfully.</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-comment">//如果dad存在，那么是展开子树，将下面这两个变量赋初值</span><br><span class="hljs-keyword">if</span> (dad)<br>depth = initial_depth = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//循环的初始条件，这里的fpsizes存放节点名长度，nps存放这个节点指针</span><br>root = dad;<br>fpsizes[depth] = dad ? <span class="hljs-built_in">strlen</span>(of_node_full_name(dad)) : <span class="hljs-number">0</span>;<br>nps[depth] = dad;<br><br>    <span class="hljs-comment">//这个循环创建所有的node</span><br><span class="hljs-keyword">for</span> (offset = <span class="hljs-number">0</span>;<br>     offset &gt;= <span class="hljs-number">0</span> &amp;&amp; depth &gt;= initial_depth;<br>     offset = fdt_next_node(blob, offset, &amp;depth)) &#123;<br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(depth &gt;= FDT_MAX_DEPTH))<br><span class="hljs-keyword">continue</span>;<br><br>fpsizes[depth+<span class="hljs-number">1</span>] = populate_node(blob, offset, &amp;mem,<br> nps[depth],<br> fpsizes[depth],<br> &amp;nps[depth+<span class="hljs-number">1</span>], dryrun);<br><span class="hljs-keyword">if</span> (!fpsizes[depth+<span class="hljs-number">1</span>])<br><span class="hljs-keyword">return</span> mem - base;<br><br><span class="hljs-keyword">if</span> (!dryrun &amp;&amp; nodepp &amp;&amp; !*nodepp)<br>*nodepp = nps[depth+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (!dryrun &amp;&amp; !root)<br>root = nps[depth+<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span> &amp;&amp; offset != -FDT_ERR_NOTFOUND) &#123;<br>pr_err(<span class="hljs-string">&quot;Error %d processing FDT\n&quot;</span>, offset);<br><span class="hljs-keyword">return</span> -EINVAL;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Reverse the child list. Some drivers assumes node order matches .dts</span><br><span class="hljs-comment"> * node order</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!dryrun)<br>reverse_nodes(root);<br><br><span class="hljs-keyword">return</span> mem - base;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心函数是<code>populate_node</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">populate_node</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *blob, <span class="hljs-comment">//设备树地址</span></span><br><span class="hljs-params">  <span class="hljs-type">int</span> offset, <span class="hljs-comment">//本node的偏移</span></span><br><span class="hljs-params">  <span class="hljs-type">void</span> **mem, <span class="hljs-comment">//解压的node存放的地址</span></span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> device_node *dad, <span class="hljs-comment">//父节点</span></span><br><span class="hljs-params">  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fpsize, <span class="hljs-comment">//节点名长度</span></span><br><span class="hljs-params">  <span class="hljs-keyword">struct</span> device_node **pnp, <span class="hljs-comment">//生成的node</span></span><br><span class="hljs-params">  <span class="hljs-type">bool</span> dryrun)</span> <span class="hljs-comment">//是否进行预检</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">np</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> l, allocl;<br><span class="hljs-type">int</span> new_format = <span class="hljs-number">0</span>;<br><br>pathp = fdt_get_name(blob, offset, &amp;l);<br><span class="hljs-keyword">if</span> (!pathp) &#123;<br>*pnp = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>allocl = ++l;<br><br><span class="hljs-comment">/* version 0x10 has a more compact unit name here instead of the full</span><br><span class="hljs-comment"> * path. we accumulate the full path size using &quot;fpsize&quot;, we&#x27;ll rebuild</span><br><span class="hljs-comment"> * it later. We detect this because the first character of the name is</span><br><span class="hljs-comment"> * not &#x27;/&#x27;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((*pathp) != <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>new_format = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (fpsize == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* root node: special case. fpsize accounts for path</span><br><span class="hljs-comment"> * plus terminating zero. root node only has &#x27;/&#x27;, so</span><br><span class="hljs-comment"> * fpsize should be 2, but we want to avoid the first</span><br><span class="hljs-comment"> * level nodes to have two &#x27;/&#x27; so we use fpsize 1 here</span><br><span class="hljs-comment"> */</span><br>fpsize = <span class="hljs-number">1</span>;<br>allocl = <span class="hljs-number">2</span>;<br>l = <span class="hljs-number">1</span>;<br>pathp = <span class="hljs-string">&quot;&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* account for &#x27;/&#x27; and path size minus terminal 0</span><br><span class="hljs-comment"> * already in &#x27;l&#x27;</span><br><span class="hljs-comment"> */</span><br>fpsize += l;<br>allocl = fpsize;<br>&#125;<br>&#125;<br><br>np = unflatten_dt_alloc(mem, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> device_node) + allocl,<br>__alignof__(<span class="hljs-keyword">struct</span> device_node));<br><span class="hljs-keyword">if</span> (!dryrun) &#123;<br><span class="hljs-type">char</span> *fn;<br>of_node_init(np);<br>np-&gt;full_name = fn = ((<span class="hljs-type">char</span> *)np) + <span class="hljs-keyword">sizeof</span>(*np);<br><span class="hljs-keyword">if</span> (new_format) &#123;<br><span class="hljs-comment">/* rebuild full path for new format */</span><br><span class="hljs-keyword">if</span> (dad &amp;&amp; dad-&gt;parent) &#123;<br><span class="hljs-built_in">strcpy</span>(fn, dad-&gt;full_name);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-built_in">strlen</span>(fn) + l + <span class="hljs-number">1</span>) != allocl) &#123;<br>pr_debug(<span class="hljs-string">&quot;%s: p: %d, l: %d, a: %d\n&quot;</span>,<br>pathp, (<span class="hljs-type">int</span>)<span class="hljs-built_in">strlen</span>(fn),<br>l, allocl);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>fn += <span class="hljs-built_in">strlen</span>(fn);<br>&#125;<br>*(fn++) = <span class="hljs-string">&#x27;/&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">memcpy</span>(fn, pathp, l);<br><br><span class="hljs-keyword">if</span> (dad != <span class="hljs-literal">NULL</span>) &#123;<br>np-&gt;parent = dad;<br>np-&gt;sibling = dad-&gt;child;<br>dad-&gt;child = np;<br>&#125;<br>&#125;<br><br>populate_properties(blob, offset, mem, np, pathp, dryrun);<br><span class="hljs-keyword">if</span> (!dryrun) &#123;<br>np-&gt;name = of_get_property(np, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-literal">NULL</span>);<br>np-&gt;type = of_get_property(np, <span class="hljs-string">&quot;device_type&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">if</span> (!np-&gt;name)<br>np-&gt;name = <span class="hljs-string">&quot;&lt;NULL&gt;&quot;</span>;<br><span class="hljs-keyword">if</span> (!np-&gt;type)<br>np-&gt;type = <span class="hljs-string">&quot;&lt;NULL&gt;&quot;</span>;<br>&#125;<br><br>*pnp = np;<br><span class="hljs-keyword">return</span> fpsize;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，dtb的所有二进制都被展开成了节点device_node，但是还没有进行扫描，也就是说，这些节点还没有变成能被内核识别的设备</p><p>下面这个就是关键函数<code>of_platform_default_populate_init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_PPC</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">of_platform_default_populate_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device_node</span> *<span class="hljs-title">node</span>;</span><br><br><span class="hljs-keyword">if</span> (!of_have_populated_dt())<br><span class="hljs-keyword">return</span> -ENODEV;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Handle ramoops explicitly, since it is inside /reserved-memory,</span><br><span class="hljs-comment"> * which lacks a &quot;compatible&quot; property.</span><br><span class="hljs-comment"> */</span><br>node = of_find_node_by_path(<span class="hljs-string">&quot;/reserved-memory&quot;</span>);<br><span class="hljs-keyword">if</span> (node) &#123;<br>node = of_find_compatible_node(node, <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;ramoops&quot;</span>);<br><span class="hljs-keyword">if</span> (node)<br>of_platform_device_create(node, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">/* Populate everything else. */</span><br>of_platform_default_populate(<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>arch_initcall_sync(of_platform_default_populate_init);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>可以看到，除了PPC(Power PC)架构，其他架构都需要调用这个函数，而且是通过<code>arch_initcall_sync</code>来默认执行，该latecall的级别是3，而驱动的级别大多都是6，也就是说，内核常常是先注册设备，然后注册驱动，在注册驱动的时候进行probe，将已经挂载的设备进行激活</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>dts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kbuild那些事儿</title>
    <link href="/2025/01/06/Kbuild/"/>
    <url>/2025/01/06/Kbuild/</url>
    
    <content type="html"><![CDATA[<h1 id="Kbuild机制梳理"><a href="#Kbuild机制梳理" class="headerlink" title="Kbuild机制梳理"></a>Kbuild机制梳理</h1><h2 id="Makefile的执行顺序"><a href="#Makefile的执行顺序" class="headerlink" title="Makefile的执行顺序"></a>Makefile的执行顺序</h2><ol><li>读入所有include的makefile（include时会对include命令后面的变量与通配符进行扩展，然后试着读入该Makefile，如果成功就继续，如果失败就报告，并继续读取其余makefile。直到所有读取全部完成后，查看规则中是否有更新该Makefile的规则，如果有，就更新目标，然后重新读入该Makefile。不断重复以上流程，直到所有更新Makefile的规则都被执行后，仍不存在该Makefile，就报错退出）</li><li>初始化变量</li><li>分析规则，将其加入依赖链</li><li>根据依赖，决定哪些目标需要生成</li><li>执行生成命令</li></ol><h2 id="命令脚本初始化顺序"><a href="#命令脚本初始化顺序" class="headerlink" title="命令脚本初始化顺序"></a>命令脚本初始化顺序</h2><ol><li>读取命令脚本</li><li>扩展变量（执行的时候才会扩展，然而目标的变量扩展会在构建规则链时）</li><li>对Make表达式求值（宏被扩展时，会为每一行增加Tab）</li><li>执行</li></ol><ul><li>tips：注意区分Make表达式和shell表达式，shell表达式会在bash执行时求值</li></ul><h2 id="Kbuild相关文件的作用"><a href="#Kbuild相关文件的作用" class="headerlink" title="Kbuild相关文件的作用"></a>Kbuild相关文件的作用</h2><table><thead><tr><th align="center">文件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Makefile</td><td align="center">顶层Makefile，执行的根目录</td></tr><tr><td align="center">scritps&#x2F;basic&#x2F;Makefile</td><td align="center">词法分析fixdep</td></tr><tr><td align="center">scripts&#x2F;Kbuild.include</td><td align="center">常用函数</td></tr><tr><td align="center">scritps&#x2F;Makefile.userprogs</td><td align="center">用户程序处理</td></tr><tr><td align="center">scripts&#x2F;Makefile.lib</td><td align="center">常用变量的定义</td></tr><tr><td align="center">scripts&#x2F;Makefile.host</td><td align="center">本地程序编译HOSTCC</td></tr><tr><td align="center">arch&#x2F;x86&#x2F;Makefile</td><td align="center">架构Makefile</td></tr><tr><td align="center">arch&#x2F;x86&#x2F;boot&#x2F;Makefile</td><td align="center">架构的启动Makefile</td></tr><tr><td align="center">arch&#x2F;x86&#x2F;kernel&#x2F;Makefile</td><td align="center">单目录下的Makefile</td></tr><tr><td align="center">arch&#x2F;x86&#x2F;boot&#x2F;compressed&#x2F;Makefile</td><td align="center">压缩后的Makefile</td></tr></tbody></table><h2 id="prepare依赖关系"><a href="#prepare依赖关系" class="headerlink" title="prepare依赖关系"></a>prepare依赖关系</h2><pre><code class=" mermaid">graph LR;prepare--&gt;prepare0;prepare--&gt;prepare-objtool;prepare--&gt;prepare-resolve_btfids;prepare0--&gt;archprepare;archprepare--&gt;outputmakefile;outputmakefile--&gt;源码目录与输出目录不一致时启用;archprepare--&gt;archheaders;archheaders--&gt;产生系统调用表;archprepare--&gt;archscripts;archscripts--&gt;scripts_basic;archscripts--&gt;架构脚本相关;archprepare--&gt;scripts;scripts--&gt;执行scripts目录下的Makefile;scripts--&gt;scripts_basic;scripts--&gt;scripts_dtc;archprepare--&gt;include/config/kernel.release;include/config/kernel.release--&gt;内核发行版本信息;archprepare--&gt;asm-generic;asm-generic--&gt;内核通用头文件;archprepare--&gt;version_h;version_h--&gt;内核版本信息;archprepare--&gt;autoksyms_h;autoksyms_h--&gt;内核符号信息;archprepare--&gt;include/generated/utsrelease.h;include/generated/utsrelease.h--&gt;设备信息;archprepare--&gt;include/generated/autoconf.h;include/generated/autoconf.h--&gt;.config信息;</code></pre><h2 id="bzImage依赖关系"><a href="#bzImage依赖关系" class="headerlink" title="bzImage依赖关系"></a>bzImage依赖关系</h2><pre><code class=" mermaid">graph LR;bzImage--&gt;vmlinux;</code></pre><h1 id="一、config流程"><a href="#一、config流程" class="headerlink" title="一、config流程"></a>一、config流程</h1><p>构建内核，首先需要产生.config文件，.config文件需要在顶层makefile中设置config-build标志，注意区分config-build和need-config两个标志，config-build是构建.config文件，而need-config是指本次构建需要.config的参与，即需要.config中的配置项。</p><p>如果在本次构建中，还有其余目标，如clean目标，single目标，config目标等，则会设置mixed-build标志，即混合构建，此时make会通过__build_one_by_one依次去处理每个目标，而不是在本make中处理所有目标。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build_one_by_one:</span><br><span class="hljs-variable">$(Q)</span>set -e; \  <span class="hljs-comment">#出错就停止</span><br>for i in <span class="hljs-variable">$(MAKECMDGOALS)</span>; do \<span class="hljs-comment"># 遍历每个目标</span><br><span class="hljs-variable">$(MAKE)</span> -f <span class="hljs-variable">$(srctree)</span>/Makefile $$i; \<span class="hljs-comment">#用顶层makefile去处理每个目标</span><br>done<br></code></pre></td></tr></table></figure><p>而如果不需要混合构建，则进入了真正的重头戏，内核make每次的主要运行流程。</p><p>首先会包含Kbuild.include，这里面有一些通用的全局函数，如build，clean，if_changed等通用函数。dot-target，depfile等通用变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> scripts/Kbuild.<span class="hljs-keyword">include</span><br></code></pre></td></tr></table></figure><p>然后通过一个makefile文件来确认当前架构。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> scripts/subarch.<span class="hljs-keyword">include</span><br><span class="hljs-comment"># 其中的内容就一行，确定SUBARCH</span><br>SUBARCH := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \</span><br><span class="hljs-variable">  -e s/sun4u/sparc64/ \</span><br><span class="hljs-variable">  -e s/arm.*/arm/ -e s/sa110/arm/ \</span><br><span class="hljs-variable">  -e s/s390x/s390/ -e s/parisc64/parisc/ \</span><br><span class="hljs-variable">  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \</span><br><span class="hljs-variable">  -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ \</span><br><span class="hljs-variable">  -e s/riscv.*/riscv/)</span><br></code></pre></td></tr></table></figure><p>这里要注意一个特殊的架构，um架构，即user mode，UML这里不是统一建模语言，而是UserMode Linux的缩写，从字面上看，是在用户态运行linux内核，即将内核当作一个应用程序在跑，这样我们就可以用调试应用层程序的方法调试内核了，应用层的强大调试工具gdb就派上用场了。很多时候我们写内核代码，当遇到算法比较复杂但又不涉及底层结构的时候总是喜欢现在应用层实现并调试，然后在写到内核层。为什么，就是因为用户层调试比内核调试方便。但是UML的最大局限性就是不能调试硬件关联性强的代码，但是还是有很多方面可以应用的，比如调度算法、VFS等。</p><p><strong>可以看到，默认的架构是编译内核的架构</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ARCH?= <span class="hljs-variable">$(SUBARCH)</span><br><br><span class="hljs-comment"># Architecture as present in compile.h</span><br>UTS_MACHINE := <span class="hljs-variable">$(ARCH)</span><br>SRCARCH := <span class="hljs-variable">$(ARCH)</span><br></code></pre></td></tr></table></figure><blockquote><p>HOST：本地编译的一些工具，如HOSTCC，HOSTLD，HOSTCXX等，用来编译本机上的一些工具，如mkproggy，fixdep等</p></blockquote><hr><p>下面开始正式构建.config的流程，首先看.config的定义位置</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">KCONFIG_CONFIG?= .config<br><span class="hljs-keyword">export</span> KCONFIG_CONFIG<br></code></pre></td></tr></table></figure><p>可以看到，默认是由KCONFIG_CONFIG这个变量名字来定义.config的，并且通过export来使其他makefile文件可以使用本变量。</p><p>下面执行流到真正构建.config的过程，首先顶层makefile定义了一个过程，由ifdef config-build开始，else分支则是不构建.config的执行流程。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> config-build<br><span class="hljs-comment">## 则包含平台相关的makefile</span><br><span class="hljs-comment"># 构建.config肯定要使用架构相关的信息，因此首先包含架构中的Makefile文件</span><br><span class="hljs-keyword">include</span> arch/<span class="hljs-variable">$(SRCARCH)</span>/Makefile<br><span class="hljs-keyword">export</span> KBUILD_DEFCONFIG KBUILD_KCONFIG CC_VERSION_TEXT<br><span class="hljs-comment"># </span><br><span class="hljs-comment">## 这里是config和 %config的构建命令，其依赖于 scripts_basic outputmakefile</span><br><span class="hljs-section">config: outputmakefile scripts_basic FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br><br><span class="hljs-section">%config: outputmakefile scripts_basic FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br><br><span class="hljs-keyword">else</span> <span class="hljs-comment">#!config-build</span><br></code></pre></td></tr></table></figure><p>可以看到导出了三个变量，分别是</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">KBUILD_DEFCONFIG  <span class="hljs-comment">#在顶层makefile中定义，为export KBUILD_DEFCONFIG := defconfig，即默认的defconfig</span><br>KBUILD_KCONFIG <span class="hljs-comment"># 仅由scripts/kconfig中的Makefile文件使用，后文说明</span><br>CC_VERSION_TEXT <span class="hljs-comment">#gcc的版本信息</span><br><span class="hljs-comment"># CC_VERSION_TEXT = $(shell $(CC) --version 2&gt;/dev/null | head -n 1)</span><br></code></pre></td></tr></table></figure><p>make的特性，在include某个makefile时，会同步将其展开，因此这里会直接将arch&#x2F;$(SRCARCH)&#x2F;Makefile进行展开，并计算其中的变量和make操作。</p><p>以x86架构为例</p><p>首先根据真实架构确定使用的defconfig是哪个，即KBUILD_DEFCONFIG</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># select defconfig based on actual architecture</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(ARCH)</span>,x86)<br>  <span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -m)</span>,x86_64)<br>        KBUILD_DEFCONFIG := x86_64_defconfig<br>  <span class="hljs-keyword">else</span><br>        KBUILD_DEFCONFIG := i386_defconfig<br>  <span class="hljs-keyword">endif</span><br><span class="hljs-keyword">else</span><br>        KBUILD_DEFCONFIG := <span class="hljs-variable">$(ARCH)</span>_defconfig<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>接下来会定义一些架构相关的东西，和一些特定的功能，如FUNCTION_GRAPH_TRACER之类的，比较重要的是下面这些</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 架构相关的脚本</span><br><span class="hljs-section">archscripts: scripts_basic</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=arch/x86/tools relocs<br><br><span class="hljs-comment">###</span><br><span class="hljs-comment"># Syscall table generation</span><br><span class="hljs-comment"># 系统调用表</span><br><span class="hljs-section">archheaders:</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=arch/x86/entry/syscalls all<br></code></pre></td></tr></table></figure><p>指定boot目录</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">boot := arch/x86/boot<br><br>KBUILD_IMAGE := <span class="hljs-variable">$(boot)</span>/bzImage<br></code></pre></td></tr></table></figure><p>在x86架构下的默认动作是bzImage</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: bzImage</span><br><br><span class="hljs-comment"># bzImage会依赖vmlinux，注意这里的vmlinux没有指定前缀，那么这是顶层目录下的vmlinux</span><br><span class="hljs-section">bzImage: vmlinux</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CONFIG_X86_DECODER_SELFTEST)</span>,y)<br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=arch/x86/tools posttest<br><span class="hljs-keyword">endif</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$(boot)</span> <span class="hljs-variable">$(KBUILD_IMAGE)</span><br><span class="hljs-variable">$(Q)</span>mkdir -p <span class="hljs-variable">$(objtree)</span>/arch/<span class="hljs-variable">$(UTS_MACHINE)</span>/boot<br><span class="hljs-variable">$(Q)</span>ln -fsn ../../x86/boot/bzImage <span class="hljs-variable">$(objtree)</span>/arch/<span class="hljs-variable">$(UTS_MACHINE)</span>/boot/<span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>可以看到他的逻辑，不用管需要selftest的部分，首先使用一个make去执行boot目录下的makefile，并且指定目标是boot下的bzImage，然后在输出目录下建立boot目录，建立软链接，将输出目录下的bzImage和源码目录下产生的bzImage链接起来</p><p>上面的部分执行完，bzImage应该就顺利产生了，然而，本次的目标是构建.config文件，并没有all目标，这里可以注意到一个小细节，顶层makefile的默认目标是_all，而不是all，所以当执行.config的构建路径时，all目标并不会被执行。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># config是默认的config，%config是其他乱七八糟的config，如defconfig，i386_defconfig等</span><br><span class="hljs-comment"># 并且他们都有相同的依赖（prerequiries），outputmakefile和scripts_basic</span><br><span class="hljs-section">config: outputmakefile scripts_basic FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br><br><span class="hljs-section">%config: outputmakefile scripts_basic FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>其中，outputmakefile用来为源码目录和输出目录不一致时，为输出目录生成一份makeifle。scripts_basic用来生成词法分析器fixdep</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">outputmakefile:</span><br><span class="hljs-keyword">ifdef</span> building_out_of_srctree<br><span class="hljs-variable">$(Q)</span>if [ -f <span class="hljs-variable">$(srctree)</span>/.config -o \<br> -d <span class="hljs-variable">$(srctree)</span>/<span class="hljs-keyword">include</span>/config -o \<br> -d <span class="hljs-variable">$(srctree)</span>/arch/<span class="hljs-variable">$(SRCARCH)</span>/<span class="hljs-keyword">include</span>/generated ]; then \<br>echo &gt;&amp;2 <span class="hljs-string">&quot;***&quot;</span>; \<br>echo &gt;&amp;2 <span class="hljs-string">&quot;*** The source tree is not clean, please run &#x27;make$(if $(findstring command line, $(origin ARCH)), ARCH=<span class="hljs-variable">$(ARCH)</span>) mrproper&#x27;&quot;</span>; \<br>echo &gt;&amp;2 <span class="hljs-string">&quot;*** in <span class="hljs-variable">$(abs_srctree)</span>&quot;</span>;\<br>echo &gt;&amp;2 <span class="hljs-string">&quot;***&quot;</span>; \<br>false; \<br>fi<br><span class="hljs-comment">## 在当前目录创建一个符号链接</span><br><span class="hljs-comment">## 链接源码目录到输出目录下的source目录 -fsn是针对目录的，若已有符号链接，不跟随且覆盖原有定义</span><br><span class="hljs-variable">$(Q)</span>ln -fsn <span class="hljs-variable">$(srctree)</span> source<br><span class="hljs-comment">### mkmakefile在输出目录生成了一个Makefile，以使得输出目录可以编译</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(CONFIG_SHELL)</span> <span class="hljs-variable">$(srctree)</span>/scripts/mkmakefile <span class="hljs-variable">$(srctree)</span><br><span class="hljs-comment"># ## 若输出目录存在.gitignore则结束，否则创建.gitignore,并写入 *,即忽略输出目录的所有文件</span><br><span class="hljs-variable">$(Q)</span>test -e .gitignore || \<br>&#123; echo <span class="hljs-string">&quot;# this is build directory, ignore it&quot;</span>; echo <span class="hljs-string">&quot;*&quot;</span>; &#125; &gt; .gitignore<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>可以看到，只有源码目录和输出目录不一致时，才会在输出目录下生成makefile，否则outputmakefile只是一个空操作。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># scripts_basic则会使用一个子make，去scirpts/basic目录下去执行makefile</span><br>PHONY += scripts_basic<br><span class="hljs-section">scripts_basic:</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/basic<br><span class="hljs-variable">$(Q)</span>rm -f .tmp_quiet_recordmcount<br></code></pre></td></tr></table></figure><p>scripts&#x2F;basic目录下只有三个文件，一个.gitignore，一个fixdep.c，一个Makefile。</p><p>.gitignore不用管，只是版本控制文件，fixdep.c是词法分析器的c文件，使用HOSTCC进行编译，Makefile则是scripts_basic目标具体执行的命令，可以看到上面的命令，$(build)后面并没有执行具体的目标，那么Makefile.build则会执行默认目标，_build。</p><p>先看scripts&#x2F;basic中的Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">hostprogs-always-y+= fixdep<br></code></pre></td></tr></table></figure><p>可以看到，就是单纯的为hostprogs-always-y增加了fixdep</p><p>而这个hostprogs-always-y在Makefile.lib中有定义，Makefile.lib文件是提供Kbuild中的一些变量定义，如各种编译的flag，obj-y，obj-m，subdir-ym，hostprogs，always-y，extra-y等编译的目标（Makefile.lib会被包含到Makefile.build文件中）。</p><p>其中hostprogs定义如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">hostprogs += $(hostprogs-always-y) $(hostprogs-always-m)<br></code></pre></td></tr></table></figure><p>可以看到，fixdep最终被包含到hostprogs中，而hostprogs会在Makefile.build中被scripts&#x2F;Makefile.host处理</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 先包含Makefile.lib，获得hostprogs变量</span><br><span class="hljs-keyword">include</span> scripts/Makefile.lib<br><br><span class="hljs-comment"># Do not include hostprogs rules unless needed.</span><br><span class="hljs-comment"># $(sort ...) is used here to remove duplicated words and excessive spaces.</span><br><br><span class="hljs-comment">## 若需要编译host相关的目标，则引入Makefile.host</span><br>hostprogs := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(hostprogs)</span>)</span><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(hostprogs)</span>,)<br><span class="hljs-keyword">include</span> scripts/Makefile.host<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>上面提到过，make在include一个makefile的时候，会直接将其进行展开，Makefile.host中会对hostprogs分类进行处理</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># C code</span><br><span class="hljs-comment"># Executables compiled from a single .c file</span><br><span class="hljs-comment"># 从单个.c文件到可执行文件，看下面的代码，首先从hostprogs中获得某个成员，</span><br><span class="hljs-comment"># 如fixdep，然后查看fixdep-objs或者fixdep-cxxobjs是否存在，若存在则说明不是单个.c文件，若不存在，则将其加入到host-csingle中</span><br>host-csingle:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> m,<span class="hljs-variable">$(hostprogs)</span>, \</span><br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-variable">$(m)</span>-objs)</span>$(<span class="hljs-variable">$(m)</span>-cxxobjs),,<span class="hljs-variable">$(m)</span>))<br><br><span class="hljs-comment"># C executables linked based on several .o files</span><br><span class="hljs-comment"># 基于若干.o生成可执行c文件，看下面的代码</span><br><span class="hljs-comment"># 还是以fixdep为例，首先查看fixdep-cxxobjs是否存在，若存在则为空，若不存在，则看fixdep-objs是否存在，若存在就将其放入host-cmulti中，其实就是找到不在-cxxobjs，但在-objs中的变量，放入host-cmulti中</span><br>host-cmulti:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> m,<span class="hljs-variable">$(hostprogs)</span>,\</span><br><span class="hljs-variable">   $(<span class="hljs-built_in">if</span> $(<span class="hljs-variable">$(m)</span>-cxxobjs)</span>,,<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-variable">$(m)</span>-objs)</span>,<span class="hljs-variable">$(m)</span>)))<br><br><span class="hljs-comment"># Object (.o) files compiled from .c files</span><br><span class="hljs-comment"># 从.c编译到.o</span><br><span class="hljs-comment"># 查看代码，还是以fixdep为例，获取所有fixdep-objs的变量</span><br>host-cobjs:= <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">foreach</span> m,<span class="hljs-variable">$(hostprogs)</span>,$(<span class="hljs-variable">$(m)</span>-objs)</span>))<br><br><span class="hljs-comment"># C++ code</span><br><span class="hljs-comment"># C++ executables compiled from at least one .cc file</span><br><span class="hljs-comment"># and zero or more .c files</span><br><span class="hljs-comment"># 从.cc到可执行文件</span><br><span class="hljs-comment"># 找出所有存在-cxxobjs的变量，放入host-cxxmulti中</span><br>host-cxxmulti:= <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> m,<span class="hljs-variable">$(hostprogs)</span>,$(<span class="hljs-built_in">if</span> $(<span class="hljs-variable">$(m)</span>-cxxobjs)</span>,<span class="hljs-variable">$(m)</span>))<br><br><span class="hljs-comment"># C++ Object (.o) files compiled from .cc files</span><br><span class="hljs-comment"># 从.cc到.o</span><br><span class="hljs-comment"># 从host-cxxmulti中，找存在-cxxobjs的变量</span><br>host-cxxobjs:= <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">foreach</span> m,$(host-cxxmulti)</span>,$(<span class="hljs-variable">$(m)</span>-cxxobjs)))<br><span class="hljs-comment"># 以下是将其添加前缀</span><br>host-csingle:= <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/,$(host-csingle)</span>)<br>host-cmulti:= <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/,$(host-cmulti)</span>)<br>host-cobjs:= <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/,$(host-cobjs)</span>)<br>host-cxxmulti:= <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/,$(host-cxxmulti)</span>)<br>host-cxxobjs:= <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/,$(host-cxxobjs)</span>)<br></code></pre></td></tr></table></figure><p>以fixdep为例分析，通过以上流程，fixdep会被加入到host-csingle变量中，由host-csingle到可执行文件的代码如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">quiet_cmd_host-csingle = HOSTCC  <span class="hljs-variable">$@</span><br>      cmd_host-csingle= <span class="hljs-variable">$(HOSTCC)</span> <span class="hljs-variable">$(hostc_flags)</span> \<br>      <span class="hljs-variable">$(KBUILD_HOSTLDFLAGS)</span> -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span> \<br><span class="hljs-variable">$(KBUILD_HOSTLDLIBS)</span> $(HOSTLDLIBS_$(target-stem))<br><span class="hljs-section">$(host-csingle): <span class="hljs-variable">$(obj)</span>/%: <span class="hljs-variable">$(src)</span>/%.c FORCE</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed_dep,host-csingle)</span><br></code></pre></td></tr></table></figure><p>除非指定了V&#x3D;1，否则默认输出quiet_cmd_host-csingle，即显示在屏幕上的是HOSTCC …</p><p>还是以fixdep为例</p><ul><li>这里的$(host-csingle)会展开为fixdep</li><li><code>$(obj)/%: $(src)/%.c</code>是模式匹配语法，将<code>$(obj)</code>下面的文件全部替换成对应的.c文件，这里的obj是执行Makefile.build时传入的，即scripts&#x2F;basic，该目录下面只有三个文件，.gitignore是版本控制文件，不用管，Makefile是当前正在执行的Makefile，就还剩下fixdep.c文件，也就是说，这里就是指fixdep依赖fixdep.c文件</li><li>注意后面的FORCE，意味着，不论这个.c是否比目标更新，永远都会执行下面的命令，因为FORCE是伪目标，伪目标永远是最新的</li></ul><p>下面分析if_changed_dep</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Execute the command and also postprocess generated .d dependencies file.</span><br>if_changed_dep = <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(newer-prereqs)</span>\<br>$(cmd-check),<span class="hljs-variable">$(cmd_and_fixdep)</span>,@:)<br><br>cmd_and_fixdep = <span class="hljs-variable">$(cmd)</span>;\<br>scripts/basic/fixdep <span class="hljs-variable">$(depfile)</span> <span class="hljs-variable">$@</span> &#x27;$(make-cmd)&#x27; &gt; $(dot-target).cmd;\<br>rm -f <span class="hljs-variable">$(depfile)</span><br></code></pre></td></tr></table></figure><p>if_changed_dep首先会检查依赖是否比目标更新，然后查看本次执行和之前保存的.d文件中的命令是否一致，若这两个条件有一个满足，那么执行cmd_and_fixdep，否则执行<code>@:</code>，这里的<code>@:</code>只是占位符，表示啥也不做</p><p>cmd_and_fixdep首先会执行本次的命令，即<code>$(cmd)</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmd = @set -e; $(echo-cmd) $(cmd_$(1))<br><span class="hljs-comment">#cmd_host-csingle= $(HOSTCC) $(hostc_flags) \</span><br><span class="hljs-comment">#      $(KBUILD_HOSTLDFLAGS) -o $@ $&lt; \</span><br><span class="hljs-comment">#$(KBUILD_HOSTLDLIBS) $(HOSTLDLIBS_$(target-stem))</span><br><span class="hljs-comment">#$(host-csingle): $(obj)/%: $(src)/%.c FORCE</span><br><span class="hljs-comment">#    $(call if_changed_dep,host-csingle)</span><br></code></pre></td></tr></table></figure><p>根据调用处的代码，<code>$(1)</code>就是<code>host-csingle</code>，那么<code>$(cmd_$(1))</code>就是<code>cmd_host-csingle</code>，可以看到，就是用HOSTCC，也就是gcc进行了编译，输出是<code>$(host-csingle)</code>，即fixdep，输入是<code>$&lt;</code>，也就是第一个依赖，本例中是fixdep.c，那么到此时，fixdep就被HOST编译完成了。</p><p>再来看剩下的代码</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmd_and_fixdep = <span class="hljs-variable">$(cmd)</span>;\<br>scripts/basic/fixdep <span class="hljs-variable">$(depfile)</span> <span class="hljs-variable">$@</span> &#x27;$(make-cmd)&#x27; &gt; $(dot-target).cmd;\<br>rm -f <span class="hljs-variable">$(depfile)</span><br></code></pre></td></tr></table></figure><p>使用编译好的fixdep，将<code>$(depfile)</code>，<code>$@</code>，<code>$(make-cmd)</code>生成一个.cmd文件，也就是该文件上次编译的记录，用来对比本次编译和上次编译中，编译命令改变的部分，最后把临时文件<code>$(depfile)</code>删掉，这也是为什么fixdep叫词法分析器的原因，fixdep的c源码就不在此进行分析了，depfile是c文件的头文件依赖。</p><p>好了，现在谁还记得我们调用Makefile.build的时候没有指定目标，因此执行的默认目标_build，这也是Kbuild分析的难点，容易陷入到各种细节中去，回到我们的_build，由于内核在顶层Makefile中调用scripts&#x2F;basic下的Makefile时没有指定single-build，need-builtin和need-modorder，因此执行流直接来到下面的代码处</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build: $(if <span class="hljs-variable">$(KBUILD_BUILTIN)</span>, $(targets-for-builtin)) \</span><br> <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(KBUILD_MODULES)</span>, $(targets-for-modules)</span>) \<br> $(subdir-ym) $(always-y)<br>@:<br></code></pre></td></tr></table></figure><p>可以看到，脚本命令处只是占位符<code>@:</code>，因此这里_build目标的作用就是让后面的依赖生成，这里面KBUILD_BUILTIN和KBUILD_MODULES都为空，subdir-ym也为空，但是always-y不是空，因为在Makefile.lib中有如下定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">always-y += $(hostprogs-always-y) $(hostprogs-always-m)<br></code></pre></td></tr></table></figure><p>可以看到我们的fixdep被always-y包含进来了，因此这里要对always-y进行生成，<code>$(alwasy-y)</code>展开后就是fixdep，然后上面的fixdep已经被生成了，因此到这里，本次Makefile.build的流程结束，我们回到顶层Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%config: outputmakefile scripts_basic FORCE</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/kconfig <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>两个依赖都更新了，现在开始执行命令，还是build，但是现在目录是sripts&#x2F;kconfig了，还传进去一个参数，$@，就是我们的目标，%config</p><p>还是之前的分析方法，到scripts&#x2F;kconfig目录下找Makefile文件，这里可以注意一下，在Makefile.build中，会首先去读取该目录下的kbuild文件，如果没有才回去读取Makefile文件，在scripts&#x2F;kconfig目录下是没有kbuild文件的，因此直接读取Makefile</p><p>还记得前面定义的KBUILD_KCONFIG变量么，该变量会在这个Makefile中进行判定</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> KBUILD_KCONFIG<br>Kconfig := <span class="hljs-variable">$(KBUILD_KCONFIG)</span><br><span class="hljs-keyword">else</span><br>Kconfig := Kconfig<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>现在Kconfig变成了我们要输出的，也是内核构建最重要的.config了</p><p>以我们熟悉的i386_defconfig为例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%_defconfig: <span class="hljs-variable">$(obj)</span>/conf</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(silent)</span> --defconfig=arch/<span class="hljs-variable">$(SRCARCH)</span>/configs/<span class="hljs-variable">$@</span> <span class="hljs-variable">$(Kconfig)</span><br></code></pre></td></tr></table></figure><p>这个defconfig需要首先构建$(obj)&#x2F;conf，这个obj其实就是scripts&#x2F;kconfig，也就是构建scripts&#x2F;kconfig&#x2F;conf，conf也是一个需要用HOSTCC进行编译的程序，因为在本Makefile中也有如下定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">common-objs:= confdata.o expr.o lexer.lex.o parser.tab.o preprocess.o symbol.o util.o<br>hostprogs+= conf<br>conf-objs:= conf.o $(common-objs)<br></code></pre></td></tr></table></figure><p>可以看到conf被hostprogs包含了，并且还有conf-objs，结合前面对Makefile.host的分析，可以得到，conf是被host-cmulti处理的，展开如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">host-cmulti := conf<br>host-cobjs := $(conf-objs)<br><span class="hljs-comment"># 其中$(conf-objs)如上所示</span><br></code></pre></td></tr></table></figure><p>host-cmulti和host-cobjs最终会通过以下渠道被编译</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">quiet_cmd_host-cmulti= HOSTLD  <span class="hljs-variable">$@</span><br>      cmd_host-cmulti= <span class="hljs-variable">$(HOSTCC)</span> <span class="hljs-variable">$(KBUILD_HOSTLDFLAGS)</span> -o <span class="hljs-variable">$@</span> \<br>  <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/, $($(target-stem)</span>-objs)) \<br>  <span class="hljs-variable">$(KBUILD_HOSTLDLIBS)</span> $(HOSTLDLIBS_$(target-stem))<br><span class="hljs-section">$(host-cmulti): FORCE</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,host-cmulti)</span><br><br>quiet_cmd_host-cobjs= HOSTCC  <span class="hljs-variable">$@</span><br>      cmd_host-cobjs= <span class="hljs-variable">$(HOSTCC)</span> <span class="hljs-variable">$(hostc_flags)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">$(host-cobjs): <span class="hljs-variable">$(obj)</span>/%.o: <span class="hljs-variable">$(src)</span>/%.c FORCE</span><br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed_dep,host-cobjs)</span><br></code></pre></td></tr></table></figure><p>可知，host-cmulti是链接而成的，$(conf-objs)是一群.o文件，这些文件现在尚未生成，下面的$(host-cobjs)就是那群.o文件，通过模式匹配，host-cobjs的每一个.c文件都被编译为.o，最终conf被编译成功了。</p><p>接着回到scripts&#x2F;kconfig目录下的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%_defconfig: <span class="hljs-variable">$(obj)</span>/conf</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$(silent)</span> --defconfig=arch/<span class="hljs-variable">$(SRCARCH)</span>/configs/<span class="hljs-variable">$@</span> <span class="hljs-variable">$(Kconfig)</span><br></code></pre></td></tr></table></figure><p>conf已经生成了，下面执行命令，命令展开之后就是</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">conf --defconfig=arch/x86/configs/i386_defconfig .config<br></code></pre></td></tr></table></figure><p>conf程序源码就不仔细分析了，我们只需要知道，.config，auto.conf，autoconf.h都是在这里生成的，其中auto.conf给顶层Makefile使用，autoconf.h给Linux内核使用。</p><p>最后是一个小彩蛋，内核中经典的.config配置完成后的终端输出</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#</span><br><span class="hljs-comment"># configuration written to .config</span><br><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><p>来自于confdata.c中的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">conf_message(<span class="hljs-string">&quot;configuration written to %s&quot;</span>, name);<br></code></pre></td></tr></table></figure><p>其中name就是我们调用conf时传入的$(Kconfig)，也就是.config</p><h1 id="二、all的流程"><a href="#二、all的流程" class="headerlink" title="二、all的流程"></a>二、all的流程</h1><h3 id="1-all"><a href="#1-all" class="headerlink" title="1. __all"></a>1. __all</h3><p>顶层Makefile的默认目标是</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">PHONY := __all<br><span class="hljs-section">__all:</span><br></code></pre></td></tr></table></figure><h3 id="2-all"><a href="#2-all" class="headerlink" title="2. all"></a>2. all</h3><p>当不需要构建.config的时候，config-build变量不会被设置，因此走的是下面的分支</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">else</span> <span class="hljs-comment">#!config-build</span><br><span class="hljs-comment"># 把all加入到伪目标</span><br>PHONY += all<br></code></pre></td></tr></table></figure><p>然后，本流程我们关注内核buildin的内容，不关注模块的内容，因此</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># </span><br><span class="hljs-comment">## 当编译in-tree的代码时，默认的目标是伪目标all,all是只有在编译非外部模块才会用到的目标(语义上）</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(KBUILD_EXTMOD)</span>,)<br><span class="hljs-section">__all: all</span><br><span class="hljs-keyword">else</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">## 编译out-tree的代码时，默认的目标是伪目标modules,modules是在编译外部或非外部模块均有可能用到的目标</span><br><span class="hljs-section">__all: modules</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>我们看到，如果不是编译模块的话，默认的目标_all的依赖是all，也就是编译内核的最开始的目标</p><p>还记得我们上个流程编译的.config么？同时生成的还有auto.conf和autoconf.h，我们说过，auto.conf是用来给顶层Makefile使用的，下面他就来了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> need-config<br><span class="hljs-keyword">include</span> <span class="hljs-keyword">include</span>/config/auto.conf<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>看到need-config了么？只有当需要.config的时候，才会定义这个变量，然后包含auto.conf</p><p>然后定义一些需要链接到vmlinux中的子目录</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(KBUILD_EXTMOD)</span>,)<br><span class="hljs-comment"># Objects we will link into vmlinux / subdirs we need to visit</span><br>core-y:= init/ usr/<br>drivers-y:= drivers/ sound/<br>drivers-<span class="hljs-variable">$(CONFIG_SAMPLES)</span> += samples/<br>drivers-y+= net/ virt/<br>libs-y:= lib/<br><span class="hljs-keyword">endif</span> <span class="hljs-comment"># KBUILD_EXTMOD</span><br></code></pre></td></tr></table></figure><h3 id="3-vmlinux"><a href="#3-vmlinux" class="headerlink" title="3.vmlinux"></a>3.vmlinux</h3><p>vmlinux是顶层目录要生成的内核最重要的目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: vmlinux</span><br></code></pre></td></tr></table></figure><p>我们看到，all依赖vmlinux，vmlinux除了上面内核的子目录，还有架构中的内容，因此需要将架构中的Makefile也包含进来</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">include</span> arch/<span class="hljs-variable">$(SRCARCH)</span>/Makefile<br></code></pre></td></tr></table></figure><p>此时会有两种情况，nead-config表示此次构建需要auto.conf和autoconf.h，may-sync-config表示此次构建需要更新auto.conf和autoconf.h，也就是下面的代码</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> need-config<br><span class="hljs-keyword">ifdef</span> may-sync-config<br><br><span class="hljs-keyword">include</span> <span class="hljs-keyword">include</span>/config/auto.conf.cmd<br></code></pre></td></tr></table></figure><p>该代码表示，如果本次构建需要.config的内容，并且需要更新auto.conf和autoconf.h，既然要更新，那就要知道上一次构建的情况，这里的auto.conf.cmd就是上一次构建auto.conf的命令</p><p>如果.config直接不存在，直接报错，因为更新auto.conf是需要.config作为基础的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(KCONFIG_CONFIG)</span>:<br>@echo &gt;&amp;2 &#x27;***&#x27;<br>@echo &gt;&amp;2 &#x27;*** Configuration file <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> not found!&#x27;<br>@echo &gt;&amp;2 &#x27;***&#x27;<br>@echo &gt;&amp;2 &#x27;*** Please run some configurator (e.g. <span class="hljs-string">&quot;make oldconfig&quot;</span> or&#x27;<br>@echo &gt;&amp;2 &#x27;*** <span class="hljs-string">&quot;make menuconfig&quot;</span> or <span class="hljs-string">&quot;make xconfig&quot;</span>).&#x27;<br>@echo &gt;&amp;2 &#x27;***&#x27;<br>@/bin/false<br></code></pre></td></tr></table></figure><p>更新auto.conf的命令如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">quiet_cmd_syncconfig = SYNC    <span class="hljs-variable">$@</span><br>      cmd_syncconfig = <span class="hljs-variable">$(MAKE)</span> -f <span class="hljs-variable">$(srctree)</span>/Makefile syncconfig<br><span class="hljs-comment">## 这里是 如auto.conf.cmd的生成命令，实际上是执行 syncconfig，这个会匹配到当前文件的 %config</span><br>%/config/auto.conf %/config/auto.conf.cmd %/generated/autoconf.h: <span class="hljs-variable">$(KCONFIG_CONFIG)</span><br>+<span class="hljs-variable">$(<span class="hljs-built_in">call</span> cmd,syncconfig)</span><br></code></pre></td></tr></table></figure><p>可以看到，这三个文件都是依赖$(KCONFIG_CONFIG)，也就是.config的，如果.config不存在，那么就会打印echo的一堆错误信息</p><p>然后，执行分支到了这里</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">else</span> <span class="hljs-comment"># !may-sync-config</span><br></code></pre></td></tr></table></figure><p>也就是，下面的代码，不需要更新auto.conf和autoconf.h，只是需要.config存在</p><p>首先将auto.conf加入到伪目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">PHONY += <span class="hljs-keyword">include</span>/config/auto.conf<br><br><span class="hljs-section">include/config/auto.conf:</span><br><span class="hljs-variable">$(Q)</span>test -e <span class="hljs-keyword">include</span>/generated/autoconf.h -a -e <span class="hljs-variable">$@</span> || (\<br>echo &gt;&amp;2;\<br>echo &gt;&amp;2 <span class="hljs-string">&quot;  ERROR: Kernel configuration is invalid.&quot;</span>;\<br>echo &gt;&amp;2 <span class="hljs-string">&quot;         include/generated/autoconf.h or <span class="hljs-variable">$@</span> are missing.&quot;</span>;\<br>echo &gt;&amp;2 <span class="hljs-string">&quot;         Run &#x27;make oldconfig &amp;&amp; make prepare&#x27; on kernel src to fix it.&quot;</span>;\<br>echo &gt;&amp;2 ;\<br>/bin/false)<br></code></pre></td></tr></table></figure><p>看autoconf.h是否存在，不存在则报错</p><p>继续前进</p><p>顶层Makefile首先导出了两个默认的符号，一个是默认镜像名字，一个是默认安装路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> KBUILD_IMAGE ?= vmlinux<br><br><span class="hljs-keyword">export</span>INSTALL_PATH ?= /boot<br></code></pre></td></tr></table></figure><hr><p>&#x3D;&#x3D;分界线—–下面很重要&#x3D;&#x3D;</p><hr><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">PHONY += prepare0<br></code></pre></td></tr></table></figure><p>注意这个prepare0</p><p>还是只看内建信息的构建</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 非模块的构建</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(KBUILD_EXTMOD)</span>,)<br>core-y+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/<br><br>vmlinux-dirs:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %/,%,$(<span class="hljs-built_in">filter</span> %/, \</span><br><span class="hljs-variable">     $(core-y)</span> $(core-m) $(drivers-y) $(drivers-m) \<br>     $(libs-y) $(libs-m)))<br><br>vmlinux-alldirs:= <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(vmlinux-dirs)</span> Documentation \<br>     <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %/,%,$(<span class="hljs-built_in">filter</span> %/, $(core-)</span> \<br>$(drivers-) $(libs-))))<br><br>subdir-modorder := <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> modules.order,$(<span class="hljs-built_in">filter</span> %/, \</span><br><span class="hljs-variable">$(core-y)</span> $(core-m) $(libs-y) $(libs-m) \<br>$(drivers-y) $(drivers-m)))<br><br>build-dirs:= $(vmlinux-dirs)<br>clean-dirs:= $(vmlinux-alldirs)<br></code></pre></td></tr></table></figure><p>首先执行流是builtin内容的构建</p><p>需要链接到vmlinux的子目录加到core-y中来，注意这里为何要放在这里，因为内核模块构建需要的内容与其不同</p><p>接着定义了三个经典变量vmlinux-dirs，vmlinux-alldirs，subdir-modorder，subdir-modorder暂时不管，那是构建模块的，vmlinux-dirs是所有需要包含在内核内建内容中的目录，vmlinux-alldirs是所有的目录，不论是否包含在builtin中，build-dirs就是构建目录，clean-dirs就是执行make clean时需要递归的目录</p><p>下面开始，是两个重要的变量，由link-vmlinux.sh使用</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">KBUILD_VMLINUX_OBJS := $(head-y) <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %/,%/built-in.a, $(core-y)</span>)<br>KBUILD_VMLINUX_OBJS += <span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> built-in.a, $(<span class="hljs-built_in">filter</span> %/, $(libs-y)</span>))<br>KBUILD_VMLINUX_LIBS := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %/,%/lib.a, $(libs-y)</span>)<br>KBUILD_VMLINUX_OBJS += <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %/,%/built-in.a, $(drivers-y)</span>)<br><span class="hljs-comment"># 将这两个变量导出，使得其他文件可以使用这两个变量</span><br><span class="hljs-keyword">export</span> KBUILD_VMLINUX_OBJS KBUILD_VMLINUX_LIBS<br></code></pre></td></tr></table></figure><p>可以看到，这个KBUILD_VMLINUX_OBJS包含了head-y的内容，还有core-y，libs-y中的目录，添加built-in.a后缀，还有drivers-y的built-in.a，除了head-y中的内容，剩下的全是各个目录中的built-in.a文件，这是一个归档文件，由该目录下所有的目标文件使用AR归档而成。</p><p>然后指定了KBUILD的链接脚本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">export</span> KBUILD_LDS          := arch/<span class="hljs-variable">$(SRCARCH)</span>/kernel/vmlinux.lds<br></code></pre></td></tr></table></figure><h3 id="4-vmlinux-deps"><a href="#4-vmlinux-deps" class="headerlink" title="4.vmlinux-deps"></a>4.vmlinux-deps</h3><p>还有vmlinux的所有依赖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">## 这个是编译vmlinux的依赖文件 这里都是.a,不同版本的问题</span><br><span class="hljs-comment">## vmlinux-deps: arch/arm64/kernel/vmlinux.lds arch/arm64/kernel/head.o  init/built-in.a ...  arch/arm64/lib/lib.a  lib/lib.a</span><br><span class="hljs-comment">## vmlinux的依赖是链接脚本，各种built-in.a和各种lib.a</span><br><br>vmlinux-deps := <span class="hljs-variable">$(KBUILD_LDS)</span> <span class="hljs-variable">$(KBUILD_VMLINUX_OBJS)</span> <span class="hljs-variable">$(KBUILD_VMLINUX_LIBS)</span><br><br><span class="hljs-comment"># 根据vmlinux的编译规则可知，其一共包含三个依赖项:</span><br><span class="hljs-comment">#    1.scripts/link-vmlinux.sh: 这是编译命令中具体执行的脚本,其没什么规则，必须存在</span><br><span class="hljs-comment">#    2.autoksyms_recursive: 若要drop没有用到的内核和模块的导出符号，则此目标中会有命令</span><br><span class="hljs-comment">#    3.$(vmlinux-deps): 包括arch相关的vmlinux链接脚本(如arch/arm64/kernel/vmlinux.lds),各种built-in.a和各种lib.a文件</span><br><span class="hljs-comment">#    对于依赖来说，其中最主要的是，若想编译vmlinux，那其前提就是$(vmlinux-deps)中的所有目标(vmlinux.lds, */built-in.a, */lib.a)都要编译先编译出来(这些目录名的规则见下).</span><br><span class="hljs-comment">#   而其编译命令一共有两条:</span><br><span class="hljs-comment">#    1.执行scripts/link-vmlinux.sh编译vmlinux</span><br><span class="hljs-comment">#    2.若平台存在Makefile.postlink，则在构建vmlinux后执行make -f Makefile.postlink</span><br></code></pre></td></tr></table></figure><p>接下来到vmlinux的构建</p><p>还记得我们前面说过all目标的依赖是vmlinux么？下面他来了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmd_link-vmlinux =                                                 \<br><span class="hljs-variable">$(CONFIG_SHELL)</span> <span class="hljs-variable">$&lt;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(LD)</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(KBUILD_LDFLAGS)</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(LDFLAGS_vmlinux)</span>&quot;</span>;    \<br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(ARCH_POSTLINK)</span>, <span class="hljs-variable">$(MAKE)</span> -f <span class="hljs-variable">$(ARCH_POSTLINK)</span> <span class="hljs-variable">$@</span>, true)</span><br><br><span class="hljs-section">vmlinux: scripts/link-vmlinux.sh autoksyms_recursive $(vmlinux-deps) FORCE</span><br>+<span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,link-vmlinux)</span><br></code></pre></td></tr></table></figure><p>vmlinux会依赖link-vmlinux.sh，vmlinux-deps，这里的autoksyms_recursive暂时先不管，也就是说，要想生成vmlinux，首先要生成link-vmlinux.sh和vmlinux-deps，其中link-vmlinux.sh就是scripts目录下的文件，就是现成的，vmlinux-deps我们前面说过，它是要组建vmlinux的built-in.a和lib.a，我们一个个看。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(vmlinux-deps)</span> $(subdir-modorder)): descend ;<br></code></pre></td></tr></table></figure><p>暂时不用管后面的subdir-modorder，那是模块编译的内容，这里可知，首先会将vmlinux-deps中的变量排序去重，他们共同的依赖是descend</p><h3 id="5-descend"><a href="#5-descend" class="headerlink" title="5.descend"></a>5.descend</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">descend: $(build-dirs)</span><br></code></pre></td></tr></table></figure><p>build-dirs也是前面说过的，它是所有要编译进vmlinux的目录名字，没有后面的’&#x2F;‘</p><h3 id="6-prepare"><a href="#6-prepare" class="headerlink" title="6.prepare"></a>6.prepare</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">$(build-dirs): prepare</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$@</span> \<br>single-build=<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span>-out <span class="hljs-variable">$@</span>/, $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/%, <span class="hljs-variable">$(KBUILD_SINGLE_TARGETS)</span>)</span>),1) \<br>need-builtin=1 need-modorder=1<br></code></pre></td></tr></table></figure><p>这后面的依赖，prepare，是进行具体编译的前置准备，非常重要</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">prepare: prepare0 prepare-objtool prepare-resolve_btfids</span><br></code></pre></td></tr></table></figure><p>共有三个依赖，prepare0，prepare-objtools，prepare-resolve_btfids，prepare0前面已经出现过，并被声明成伪目标，下面是prepare0的依赖</p><h3 id="7-prepare0"><a href="#7-prepare0" class="headerlink" title="7.prepare0"></a>7.prepare0</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">prepare0: archprepare</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=scripts/mod<br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=.<br><br><span class="hljs-section">archprepare: outputmakefile archheaders archscripts scripts include/config/kernel.release \</span><br>asm-generic <span class="hljs-variable">$(version_h)</span> <span class="hljs-variable">$(autoksyms_h)</span> <span class="hljs-keyword">include</span>/generated/utsrelease.h \<br><span class="hljs-keyword">include</span>/generated/autoconf.h<br></code></pre></td></tr></table></figure><p>东西很多，但是没办法，一个一个看吧</p><p>首先是<code>outputmakefile</code></p><p>这个变量是源码目录和输出目录不一致时用到的，作用是在输出目录产生一个顶层Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">outputmakefile:</span><br><span class="hljs-comment"># 如果定义了在源码目录外进行构建</span><br><span class="hljs-keyword">ifdef</span> building_out_of_srctree<br><span class="hljs-comment"># 如果源码目录不干净（进行过编译），就显示需要进行make mrproper</span><br><span class="hljs-variable">$(Q)</span>if [ -f <span class="hljs-variable">$(srctree)</span>/.config -o \<br> -d <span class="hljs-variable">$(srctree)</span>/<span class="hljs-keyword">include</span>/config -o \<br> -d <span class="hljs-variable">$(srctree)</span>/arch/<span class="hljs-variable">$(SRCARCH)</span>/<span class="hljs-keyword">include</span>/generated ]; then \<br>echo &gt;&amp;2 <span class="hljs-string">&quot;***&quot;</span>; \<br>echo &gt;&amp;2 <span class="hljs-string">&quot;*** The source tree is not clean, please run &#x27;make$(if $(findstring command line, $(origin ARCH)), ARCH=<span class="hljs-variable">$(ARCH)</span>) mrproper&#x27;&quot;</span>; \<br>echo &gt;&amp;2 <span class="hljs-string">&quot;*** in <span class="hljs-variable">$(abs_srctree)</span>&quot;</span>;\<br>echo &gt;&amp;2 <span class="hljs-string">&quot;***&quot;</span>; \<br>false; \<br>fi<br><span class="hljs-comment"># 设置源码目录的软链接source</span><br><span class="hljs-variable">$(Q)</span>ln -fsn <span class="hljs-variable">$(srctree)</span> source<br><span class="hljs-comment"># 在输出目录下重新生成一个Makefile</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(CONFIG_SHELL)</span> <span class="hljs-variable">$(srctree)</span>/scripts/mkmakefile <span class="hljs-variable">$(srctree)</span><br><span class="hljs-comment"># 生成.gitignore</span><br><span class="hljs-variable">$(Q)</span>test -e .gitignore || \<br>&#123; echo <span class="hljs-string">&quot;# this is build directory, ignore it&quot;</span>; echo <span class="hljs-string">&quot;*&quot;</span>; &#125; &gt; .gitignore<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>目标<code>archheaders</code>是架构Makefile中的，以x86为例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">###</span><br><span class="hljs-comment"># Syscall table generation</span><br><br><span class="hljs-section">archheaders:</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=arch/x86/entry/syscalls all<br></code></pre></td></tr></table></figure><p>就是生成系统调用表</p><p>目标<code>archscripts</code>也是架构Makefile中的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">archscripts: scripts_basic</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=arch/x86/tools relocs<br></code></pre></td></tr></table></figure><p>其以scripts_basic为基础，也就是需要fixdep功能，然后去执行arch&#x2F;x86&#x2F;tools目录下Makefile文件的relocs目标</p><p>目标<code>scripts</code>是构建scripts目录下的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">scripts: scripts_basic scripts_dtc</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=$(@)<br></code></pre></td></tr></table></figure><p>而后面的<code>asm-generic</code>则是生成一些公共的头文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">asm-generic := -f <span class="hljs-variable">$(srctree)</span>/scripts/Makefile.asm-generic obj<br><br><span class="hljs-section">asm-generic: uapi-asm-generic</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> $(asm-generic)=arch/<span class="hljs-variable">$(SRCARCH)</span>/<span class="hljs-keyword">include</span>/generated/asm \<br>generic=<span class="hljs-keyword">include</span>/asm-generic<br><br><span class="hljs-section">uapi-asm-generic:</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> $(asm-generic)=arch/<span class="hljs-variable">$(SRCARCH)</span>/<span class="hljs-keyword">include</span>/generated/uapi/asm \<br>generic=<span class="hljs-keyword">include</span>/uapi/asm-generic<br></code></pre></td></tr></table></figure><p>注意，这里的asm-generic是单独调用Makefile.asm-generic进行生成的，而不是传统的$(build)，首先看uapi-asm-generic目标，在这个过程中，obj被设置为arch&#x2F;x86&#x2F;include&#x2F;generated&#x2F;uapi&#x2F;asm，还有一个变量，generic被设置为include&#x2F;upai&#x2F;asm-generic，接下来我们到Makefile.asm-generic里面去瞅瞅</p><hr><blockquote><p>Makefile.asm-generic</p></blockquote><hr><p>这个Makefile中有一个默认的目标，all</p><p>如果没有指定目标，那么就会执行这个默认目标</p><p>我们前面说过，这个Makefile的obj目标被设为了arch&#x2F;x86&#x2F;include&#x2F;generated&#x2F;uapi&#x2F;asm，</p><p>然后他就在下面被处理了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src := <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> /generated,,<span class="hljs-variable">$(obj)</span>)</span><br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(src)</span>/Kbuild<br></code></pre></td></tr></table></figure><p>obj中的&#x2F;generated被换成了空，然后赋给src，src是arch&#x2F;x86&#x2F;include&#x2F;uapi&#x2F;asm</p><p>然后看$(src)目录下是否有Kbuild，如果有，就include进来，没有也不报错，因为可能有的架构中是没有这一项的，好在在x86中有这个Kbuild，内容如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">generated-y += unistd_32.h<br>generated-y += unistd_64.h<br>generated-y += unistd_x32.h<br></code></pre></td></tr></table></figure><p>这三个.h文件，是系统调用相关的内容，被加入到generated-y变量中</p><p>回到Makefile.asm-generic</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(SRCARCH)</span>,um)<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(generic)</span>/Kbuild<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>判断当前架构是不是um架构，也就是前面说过的user mode架构，若不是，将generic路径下的Kbuild包含进来，generic变量前面提到过，是include&#x2F;upai&#x2F;asm-generic，不是架构下的，而是include目录下的，该目录下的Kbuild</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefile">mandatory-y += auxvec.h<br>mandatory-y += bitsperlong.h<br>mandatory-y += bpf_perf_event.h<br>mandatory-y += byteorder.h<br>mandatory-y += errno.h<br>mandatory-y += fcntl.h<br>mandatory-y += ioctl.h<br>mandatory-y += ioctls.h<br>mandatory-y += ipcbuf.h<br>mandatory-y += mman.h<br>mandatory-y += msgbuf.h<br>mandatory-y += param.h<br>mandatory-y += poll.h<br>mandatory-y += posix_types.h<br>mandatory-y += ptrace.h<br>mandatory-y += resource.h<br>mandatory-y += sembuf.h<br>mandatory-y += setup.h<br>mandatory-y += shmbuf.h<br>mandatory-y += sigcontext.h<br>mandatory-y += siginfo.h<br>mandatory-y += signal.h<br>mandatory-y += socket.h<br>mandatory-y += sockios.h<br>mandatory-y += stat.h<br>mandatory-y += statfs.h<br>mandatory-y += swab.h<br>mandatory-y += termbits.h<br>mandatory-y += termios.h<br>mandatory-y += types.h<br>mandatory-y += unistd.h<br></code></pre></td></tr></table></figure><p>包含了一堆需要强制包含的头文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: $(generic-y)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(unwanted)</span>,$(<span class="hljs-built_in">call</span> cmd,remove)</span>)<br>@:<br></code></pre></td></tr></table></figure><p>默认的all目标是要依赖generic-y目标</p><p>要理解这里，需要对make的语法有一定的了解，知道其变量展开的顺序</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># redundant表示冗余的，即选出在generic-y中，但是不在mandatory-y和generated-y中的变量</span><br>redundant := <span class="hljs-variable">$(<span class="hljs-built_in">filter</span> $(mandatory-y)</span> $(generated-y), $(generic-y))<br>redundant += <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f, $(generic-y)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(srctree)</span>/<span class="hljs-variable">$(src)</span>/<span class="hljs-variable">$(f)</span>)</span>,<span class="hljs-variable">$(f)</span>))<br>redundant := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(redundant)</span>)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(redundant)</span>,\</span><br><span class="hljs-variable">$(<span class="hljs-built_in">warning</span> redundant generic-y found in <span class="hljs-variable">$(src)</span>/Kbuild: <span class="hljs-variable">$(redundant)</span>)</span>)<br></code></pre></td></tr></table></figure><p>由于本次是执行的uapi-asm-generic分支，generic-y在此时还是为空，因此redundant也为空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">mandatory-y := <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out $(generated-y)</span>, $(mandatory-y))<br>generic-y   += <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f, $(mandatory-y)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(srctree)</span>/<span class="hljs-variable">$(src)</span>/<span class="hljs-variable">$(f)</span>)</span>,,<span class="hljs-variable">$(f)</span>))<br><br>generic-y   := <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/, $(generic-y)</span>)<br>generated-y := <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/, $(generated-y)</span>)<br></code></pre></td></tr></table></figure><p>mandatory-y中取消掉已经在generated-y中的内容，现在开始定义generic-y，其内容为，在mandatory-y中的变量，如果其源文件已经存在，就不加入generic-y，如果不存在，就加入到generic-y中，（现在知道generic-y是用来做什么的了么？就是接下来要产生的文件的集合），然后为其加上路径前缀，而这里的generated-y则是源码中已经有了的文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># obj目录下已经有了的.h文件</span><br>old-headers := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(obj)</span>/*.h)</span><br><span class="hljs-comment"># 已经有了的.h文件，去除掉将要产生和已经产生的，即是要废弃的</span><br>unwanted    := <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out $(generic-y)</span> $(generated-y),$(old-headers))<br></code></pre></td></tr></table></figure><p>分析完变量，接着来看命令了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile">quiet_cmd_wrap = WRAP    <span class="hljs-variable">$@</span><br>      cmd_wrap = echo <span class="hljs-string">&quot;\#include &lt;asm-generic/<span class="hljs-variable">$*</span>.h&gt;&quot;</span> &gt; <span class="hljs-variable">$@</span><br><br>quiet_cmd_remove = REMOVE  <span class="hljs-variable">$(unwanted)</span><br>      cmd_remove = rm -f <span class="hljs-variable">$(unwanted)</span><br><br><span class="hljs-section">all: $(generic-y)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(unwanted)</span>,$(<span class="hljs-built_in">call</span> cmd,remove)</span>)<br>@:<br><br><span class="hljs-variable">$(obj)</span>/%.h:<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> cmd,wrap)</span><br><br><span class="hljs-comment"># 如果没有老目录，就产生对应目录，免得生成对应.h的时候目录不存在而报错</span><br><span class="hljs-keyword">ifeq</span> ($(old-headers),)<br><span class="hljs-variable">$(<span class="hljs-built_in">shell</span> mkdir -p <span class="hljs-variable">$(obj)</span>)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>默认目标all依赖$(generic-y)，generic-y是强制目标mandatory-y中仍没有生成的部分，generic-y是源码目录下不存在的，那么就要在输出目录，也就是obj目录下生成，即目录（arch&#x2F;x86&#x2F;include&#x2F;generated&#x2F;uapi&#x2F;asm）下的，这也是为啥generic-y要加obj前缀的原因，因为要在obj目录下生成，src目录是没有generated的(arch&#x2F;x86&#x2F;include&#x2F;uapi&#x2F;asm)</p><p>最后，具体的.h文件，通过wrap命令进行生成，其实就是在obj目录下生成了一个对应的.h文件，里面有一句#include &lt;asm-generic&#x2F;***.h&gt;</p><p>看出来了吧，其实对应的.h都已经在include&#x2F;asm-generic&#x2F;下面放好了，只是针对对应架构，放入到一个可以被用户包含的头文件目录里面而已，也就是uapi目录喽</p><p>uapi-asm-generic目标已经更新，那么回到asm-generic目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">asm-generic: uapi-asm-generic</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> $(asm-generic)=arch/<span class="hljs-variable">$(SRCARCH)</span>/<span class="hljs-keyword">include</span>/generated/asm \<br>generic=<span class="hljs-keyword">include</span>/asm-generic<br></code></pre></td></tr></table></figure><p>可以看到，还是Makefile.asm-generic，只不过我们传入的obj和generic变量都没有了uapi这个部分，也就是，这一次产生的，是一些内核用的头文件</p><p>还是先会将obj变量的generated去掉赋值给src，然后包含src对应目录下的Kbuild</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">generated-y += syscalls_32.h<br>generated-y += syscalls_64.h<br>generated-y += unistd_32_ia32.h<br>generated-y += unistd_64_x32.h<br>generated-y += xen-hypercalls.h<br><br>generic-y += early_ioremap.h<br>generic-y += <span class="hljs-keyword">export</span>.h<br>generic-y += mcs_spinlock.h<br></code></pre></td></tr></table></figure><p>是不是对比uapi目录下的Kbuild多了一些东西，起码我们有一个默认的generic-y了，而uapi是没有的，和之前的分析过程一样，就不多言了，这次我们在arch&#x2F;x86&#x2F;include&#x2F;generated&#x2F;asm目录下生成了很多.h文件，这些文件里面都是一句话，将include&#x2F;asm-generic目录下的某个.h文件包含进来。</p><hr><p>最后则是一些共有的文件，他们都有各自的规则进行生成</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#include/config/kernel.release: FORCE</span><br><span class="hljs-comment">#$(call filechk,kernel.release)</span><br><span class="hljs-keyword">include</span>/config/kernel.release<br><span class="hljs-comment">#$(version_h): FORCE</span><br><span class="hljs-comment">#$(call filechk,version.h)</span><br><span class="hljs-comment">#$(Q)rm -f $(old_version_h)</span><br><span class="hljs-variable">$(version_h)</span><br><span class="hljs-variable">$(autoksyms_h)</span><br><span class="hljs-comment">#include/generated/utsrelease.h: include/config/kernel.release FORCE</span><br><span class="hljs-comment">#$(call filechk,utsrelease.h)</span><br><span class="hljs-keyword">include</span>/generated/utsrelease.h<br><span class="hljs-comment"># .config流程里面通过conf生成</span><br><span class="hljs-keyword">include</span>/generated/autoconf.h<br></code></pre></td></tr></table></figure><p>那么到此为止，archprepare目标已经更新完成，prepare0只有这一个依赖，因此prepare0也更新完成，prepare-objtool prepare-resolve_btfids两个本次流程不用管，因此prepare目标已经更新完毕啦！！！</p><p>我们的旅途继续~</p><hr><h3 id="番外：Makefile-build-Kbuild-include-Makefile-lib"><a href="#番外：Makefile-build-Kbuild-include-Makefile-lib" class="headerlink" title="番外：Makefile.build Kbuild.include Makefile.lib"></a>番外：Makefile.build Kbuild.include Makefile.lib</h3><p>Makefile.build是Kbuild系统的核心机制，就在这里整体将它捋透吧</p><p>在Makefile.build中，首先会清空构建目标的各种定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-y :=<br>obj-m :=<br>lib-y :=<br>lib-m :=<br>always :=<br>always-y :=<br>always-m :=<br>targets :=<br>subdir-y :=<br>subdir-m :=<br>EXTRA_AFLAGS   :=<br>EXTRA_CFLAGS   :=<br>EXTRA_CPPFLAGS :=<br>EXTRA_LDFLAGS  :=<br>asflags-y  :=<br>ccflags-y  :=<br>cppflags-y :=<br>ldflags-y  :=<br><br>subdir-asflags-y :=<br>subdir-ccflags-y :=<br></code></pre></td></tr></table></figure><p>在Makefile.build中，如果obj目录有Kbuild，那么优先使用Kbuild</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src := <span class="hljs-variable">$(obj)</span><br><br>kbuild-dir := <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> /%,<span class="hljs-variable">$(src)</span>)</span>,<span class="hljs-variable">$(src)</span>,<span class="hljs-variable">$(srctree)</span>/<span class="hljs-variable">$(src)</span>)<br>kbuild-file := <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">wildcard</span> $(kbuild-<span class="hljs-built_in">dir</span>)</span>/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)<br><span class="hljs-comment"># 对应目录中需要构建的对象在这里被包含进来，如obj-y等</span><br><span class="hljs-keyword">include</span> $(kbuild-file)<br><span class="hljs-comment"># 包含Makefile.lib，整理具体要编译的对象，以及编译的flag</span><br><span class="hljs-keyword">include</span> scripts/Makefile.lib<br></code></pre></td></tr></table></figure><p>Makefile.build会包含Makefile.lib，这里面会根据need-modorder和need-builtin两个变量对可构建目标进行整理，得到要编译的目标，比如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> need-builtin<br>obj-y:= <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %/, %/built-in.a, $(obj-y)</span>)<br><span class="hljs-keyword">else</span><br>obj-y:= <span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out %/, $(obj-y)</span>)<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>obj-y目标会被定义为对应目录下的built-in.a</p><p>然后根据是否为多重目标，进一步定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># If $(foo-objs), $(foo-y), $(foo-m), or $(foo-) exists, foo.o is a composite object</span><br>multi-used-y := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">foreach</span> m,$(obj-y)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">strip</span> $($(m:.o=-objs)</span>) $($(m:.o=-y)) $($(m:.o=-))), <span class="hljs-variable">$(m)</span>)))<br>multi-used-m := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">foreach</span> m,$(obj-m)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">strip</span> $($(m:.o=-objs)</span>) $($(m:.o=-y)) $($(m:.o=-m)) $($(m:.o=-))), <span class="hljs-variable">$(m)</span>)))<br>multi-used   := $(multi-used-y) $(multi-used-m)<br><br><span class="hljs-comment"># Replace multi-part objects by their individual parts,</span><br><span class="hljs-comment"># including built-in.a from subdirectories</span><br>real-obj-y := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> m, $(obj-y)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">strip</span> $($(m:.o=-objs)</span>) $($(m:.o=-y)) $($(m:.o=-))),$($(m:.o=-objs)) $($(m:.o=-y)),<span class="hljs-variable">$(m)</span>))<br>real-obj-m := <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> m, $(obj-m)</span>, <span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">strip</span> $($(m:.o=-objs)</span>) $($(m:.o=-y)) $($(m:.o=-m)) $($(m:.o=-))),$($(m:.o=-objs)) $($(m:.o=-y)) $($(m:.o=-m)),<span class="hljs-variable">$(m)</span>))<br></code></pre></td></tr></table></figure><p>这里的real-obj-y等变量则是真正要参与编译的</p><p>回到Makefile.build，在该Makefile中，会根据real-obj-y等变量进行处理</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">subdir-builtin := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">filter</span> %/built-in.a, $(real-obj-y)</span>))<br>subdir-modorder := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">filter</span> %/modules.order, $(obj-m)</span>))<br></code></pre></td></tr></table></figure><p>得到了subdir-builtin等变量，这里的sort是为了去重，这样subdir-builtin中包含的是各个obj-y目录下的built-in.a</p><p>重点来了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets-for-builtin := $(extra-y)<br></code></pre></td></tr></table></figure><p>这个targets-for-builtin变量，表示要编译到内核中的内容，extra-y则是表示要额外处理的变量，即编译vmlinux需要，但是不合入vmlinux，举例而言就是x86下实模式的代码</p><p>接着，将需要编译的目标都加入到targets-for-builtin中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> need-builtin<br>targets-for-builtin += <span class="hljs-variable">$(obj)</span>/built-in.a<br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>而这些目标最后都会包括在targets目标中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">targets += $(targets-for-builtin) $(targets-for-modules)<br></code></pre></td></tr></table></figure><p>这个targets是非常重要的变量，后面我们会介绍他的意义</p><p>接下来是具体文件对应的编译规则</p><p>比如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># vmlinux.lds.S --&gt; vmlinux.lds</span><br>quiet_cmd_cpp_lds_S = LDS     <span class="hljs-variable">$@</span><br>      cmd_cpp_lds_S = <span class="hljs-variable">$(CPP)</span> <span class="hljs-variable">$(cpp_flags)</span> -P -U<span class="hljs-variable">$(ARCH)</span> \<br>                  -D__ASSEMBLY__ -DLINKER_SCRIPT -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(obj)</span>/%.lds: <span class="hljs-variable">$(src)</span>/%.lds.S FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed_dep,cpp_lds_S)</span><br><br><span class="hljs-comment"># 将目录下的.o归档为built-in.a</span><br>quiet_cmd_ar_builtin = AR      <span class="hljs-variable">$@</span><br>      cmd_ar_builtin = rm -f <span class="hljs-variable">$@</span>; <span class="hljs-variable">$(AR)</span> cDPrST <span class="hljs-variable">$@</span> $(real-prereqs)<br><br><span class="hljs-variable">$(obj)</span>/built-in.a: $(real-obj-y) FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,ar_builtin)</span><br></code></pre></td></tr></table></figure><p>剩下的规则就不赘述了</p><p>来看__build目标，这是Makefile.build的默认目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build: $(if <span class="hljs-variable">$(KBUILD_BUILTIN)</span>, $(targets-for-builtin)) \</span><br> <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(KBUILD_MODULES)</span>, $(targets-for-modules)</span>) \<br> $(subdir-ym) $(always-y)<br>@:<br></code></pre></td></tr></table></figure><p>可以看到，__build目标的命令是空@:，单纯是为了更新他的依赖，KBUILD_BUILTIN是在顶层Makefile中定义的，如果是1的话，那么targets-for-builtin里面的目标都会被更新，然后subdir-ym和always-y默认会被编译，subdir-ym里面是一些子目录，需要进去递归执行的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Descending</span><br><span class="hljs-comment"># ---------------------------------------------------------------------------</span><br><br>PHONY += $(subdir-ym)<br><span class="hljs-section">$(subdir-ym):</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$@</span> \<br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/, <span class="hljs-variable">$(KBUILD_SINGLE_TARGETS)</span>)</span>,single-build=) \<br>need-builtin=<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/built-in.a, $(subdir-builtin)</span>),1) \<br>need-modorder=<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/modules.order, $(subdir-modorder)</span>),1)<br></code></pre></td></tr></table></figure><p>可以看到，还是调用Makefile.build，一样的逻辑，递归到所有目标编译完成</p><p>最后，还记得那个targets么？</p><p>他来了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">existing-targets := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> $(<span class="hljs-built_in">sort</span> <span class="hljs-variable">$(targets)</span>)</span>)<br><br><span class="hljs-keyword">-include</span> <span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> f,$(existing-targets)</span>,<span class="hljs-variable">$(<span class="hljs-built_in">dir</span> <span class="hljs-variable">$(f)</span>)</span>.<span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> <span class="hljs-variable">$(f)</span>)</span>.cmd)<br></code></pre></td></tr></table></figure><p>所有的targets去重后，若有通配符就将其展开，得到existing-targets，然后把对应的.cmd当作Makefile文件包含进来，这也是if_changed系列函数的基础，若没有这个，if_changed系列函数将不起作用</p><hr><h3 id="8-build-dirs"><a href="#8-build-dirs" class="headerlink" title="8.$(build-dirs)"></a>8.$(build-dirs)</h3><p>prepare更新完成之后，我们的准备工作已经完成，开始真正的内核编译啦~</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">$(build-dirs): prepare</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$@</span> \<br>single-build=<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span>-out <span class="hljs-variable">$@</span>/, $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/%, <span class="hljs-variable">$(KBUILD_SINGLE_TARGETS)</span>)</span>),1) \<br>need-builtin=1 need-modorder=1<br></code></pre></td></tr></table></figure><p>看其内容，针对其需要编译进内核的每一个目录，使用Makefile.build作为Makefile文件，obj变量为该需要编译的目录名</p><p>single-build由KBUILD_SINGLE_TARGETS决定，本次流程中为空，因此single-build&#x3D;0</p><p>由于架构目录下的Makefile在顶层Makefile中被包含，因此架构Makefile中的core-y也被加入到build-dirs里面，比如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">core-y += arch/x86/<br></code></pre></td></tr></table></figure><p>让我们以这个目录为例子，捋一遍build-dirs的构建流程</p><p>首先，Makefile文件被指定为Makefile.build，obj变量为arch&#x2F;x86，single-build&#x3D;0，need-builtin&#x3D;1，need-modorder&#x3D;1，没有指定目标，因此使用默认目标__build</p><p>arch&#x2F;x86目录下的Kbuild里面只有obj-y和obj-m</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs makefile">obj-y += entry/<br><br>obj-<span class="hljs-variable">$(CONFIG_PERF_EVENTS)</span> += events/<br><br>obj-<span class="hljs-variable">$(CONFIG_KVM)</span> += kvm/<br><br><span class="hljs-comment"># Xen paravirtualization support</span><br>obj-<span class="hljs-variable">$(CONFIG_XEN)</span> += xen/<br><br>obj-<span class="hljs-variable">$(CONFIG_PVH)</span> += platform/pvh/<br><br><span class="hljs-comment"># Hyper-V paravirtualization support</span><br>obj-<span class="hljs-variable">$(<span class="hljs-built_in">subst</span> m,y,<span class="hljs-variable">$(CONFIG_HYPERV)</span>)</span> += hyperv/<br><br>obj-y += realmode/<br>obj-y += kernel/<br>obj-y += mm/<br><br>obj-y += crypto/<br><br>obj-<span class="hljs-variable">$(CONFIG_IA32_EMULATION)</span> += ia32/<br><br>obj-y += platform/<br>obj-y += net/<br><br>obj-<span class="hljs-variable">$(CONFIG_KEXEC_FILE)</span> += purgatory/<br></code></pre></td></tr></table></figure><p>进入Makefile.build之后，该文件会包含Makefile.lib，在Makefile.lib中，会对obj-变量进行处理，针对其由单个还是多个目标文件构成，归类到real-obj-y，multi-used-y等变量中</p><p>real-obj-y是真正需要编译的目标集合，其中含有归档文件built-in.a</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># real-obj-y中的built-in.a都过滤出来，然后去重</span><br>subdir-builtin := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">filter</span> %/built-in.a, $(real-obj-y)</span>))<br>subdir-modorder := <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">filter</span> %/modules.order, $(obj-m)</span>))<br><span class="hljs-comment"># 将subdir-builtin中的/built-in.a去掉</span><br><span class="hljs-section">$(subdir-builtin): <span class="hljs-variable">$(obj)</span>/%/built-in.a: <span class="hljs-variable">$(obj)</span>/% ;</span><br><span class="hljs-comment"># subdir-ym是需要递归的目录，没有后面的/</span><br><span class="hljs-comment"># 如果subdir-builtin中含有对应目录下的built-in.a，即$@/built-in.a</span><br><span class="hljs-comment"># 就将need-builtin置一</span><br>PHONY += $(subdir-ym)<br><span class="hljs-section">$(subdir-ym):</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$@</span> \<br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/, <span class="hljs-variable">$(KBUILD_SINGLE_TARGETS)</span>)</span>,single-build=) \<br>need-builtin=<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/built-in.a, $(subdir-builtin)</span>),1) \<br>need-modorder=<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/modules.order, $(subdir-modorder)</span>),1)<br></code></pre></td></tr></table></figure><p>当这个__build目标更新过后，这个目录下的所有子目录都被编译完成了</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">__build: $(if <span class="hljs-variable">$(KBUILD_BUILTIN)</span>, $(targets-for-builtin)) \</span><br> <span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(KBUILD_MODULES)</span>, $(targets-for-modules)</span>) \<br> $(subdir-ym) $(always-y)<br>@:<br></code></pre></td></tr></table></figure><p>回到顶层Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">descend: $(build-dirs)</span><br><span class="hljs-section">$(build-dirs): prepare</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$@</span> \<br>single-build=<span class="hljs-variable">$(<span class="hljs-built_in">if</span> $(<span class="hljs-built_in">filter</span>-out <span class="hljs-variable">$@</span>/, $(<span class="hljs-built_in">filter</span> <span class="hljs-variable">$@</span>/%, <span class="hljs-variable">$(KBUILD_SINGLE_TARGETS)</span>)</span>),1) \<br>need-builtin=1 need-modorder=1<br></code></pre></td></tr></table></figure><p>这里build-dirs是所有需要编译的目录，执行完成后，descend目标被更新</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(vmlinux-deps)</span> $(subdir-modorder)): descend ;<br></code></pre></td></tr></table></figure><p>然后所有的vmlinux-deps目标也被更新了，因为这个规则没有命令</p><p>一层一层回归</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">cmd_link-vmlinux =                                                 \<br><span class="hljs-variable">$(CONFIG_SHELL)</span> <span class="hljs-variable">$&lt;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(LD)</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(KBUILD_LDFLAGS)</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(LDFLAGS_vmlinux)</span>&quot;</span>;    \<br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> <span class="hljs-variable">$(ARCH_POSTLINK)</span>, <span class="hljs-variable">$(MAKE)</span> -f <span class="hljs-variable">$(ARCH_POSTLINK)</span> <span class="hljs-variable">$@</span>, true)</span><br><br><span class="hljs-section">vmlinux: scripts/link-vmlinux.sh autoksyms_recursive $(vmlinux-deps) FORCE</span><br>+<span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,link-vmlinux)</span><br></code></pre></td></tr></table></figure><p>最终调用link-vmlinux.sh脚本将所有的归档文件都链接为vmlinux，这样就生成了一个原始的内核，这是一个elf文件，不能被直接加载</p><h1 id="三、bzImage流程"><a href="#三、bzImage流程" class="headerlink" title="三、bzImage流程"></a>三、bzImage流程</h1><p>我们都知道，在顶层Makefile里面，会包含架构中的Makefile，在包含架构Makefile之前，会有一个all:vmlinux</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: vmlinux</span><br>.......<br><span class="hljs-keyword">include</span> arch/<span class="hljs-variable">$(SRCARCH)</span>/Makefile<br></code></pre></td></tr></table></figure><p>其中，架构的Makefile中，也有一个all目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all: bzImage</span><br></code></pre></td></tr></table></figure><p>根据Make的语法，all目标会先更新第一个出现的依赖，也就是顶层目录下的vmlinux，然后找到第二个依赖，也就是bzImage</p><p>下面我们来看bzImage的构建流程</p><p>首先</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">bzImage: vmlinux</span><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CONFIG_X86_DECODER_SELFTEST)</span>,y)<br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=arch/x86/tools posttest<br><span class="hljs-keyword">endif</span><br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$(boot)</span> <span class="hljs-variable">$(KBUILD_IMAGE)</span><br><span class="hljs-variable">$(Q)</span>mkdir -p <span class="hljs-variable">$(objtree)</span>/arch/<span class="hljs-variable">$(UTS_MACHINE)</span>/boot<br><span class="hljs-variable">$(Q)</span>ln -fsn ../../x86/boot/bzImage   \   <span class="hljs-variable">$(objtree)</span>/arch/<span class="hljs-variable">$(UTS_MACHINE)</span>/boot/<span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>不用看ifeq宏包裹的部分，可知，bzImage依赖vmlinux，这个vmlinux没有前缀，说明它是顶层目录的vmlinux，也就是我们上一个流程生成的vmlinux</p><p>然后会以boot目录作为obj，Makefile.build为Makefile文件，进去执行，相关定义如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">boot := arch/x86/boot<br><br>KBUILD_IMAGE := <span class="hljs-variable">$(boot)</span>/bzImage<br></code></pre></td></tr></table></figure><p>进入到boot目录下之后，我们之前说过，Makefile.build会优先找Kbuild文件，然后才是Makefile文件，但是boot目录下没有Kbuild，因此将boot目录下的Makefile包含进来</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">quiet_cmd_image = BUILD   <span class="hljs-variable">$@</span><br>silent_redirect_image = &gt;/dev/null<br>cmd_image = <span class="hljs-variable">$(obj)</span>/tools/build <span class="hljs-variable">$(obj)</span>/setup.bin <span class="hljs-variable">$(obj)</span>/vmlinux.bin \<br>       <span class="hljs-variable">$(obj)</span>/zoffset.h <span class="hljs-variable">$@</span> $(<span class="hljs-variable">$(quiet)</span>redirect_image)<br><br><span class="hljs-variable">$(obj)</span>/bzImage: <span class="hljs-variable">$(obj)</span>/setup.bin <span class="hljs-variable">$(obj)</span>/vmlinux.bin <span class="hljs-variable">$(obj)</span>/tools/build FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,image)</span><br>@<span class="hljs-variable">$(kecho)</span> &#x27;Kernel: <span class="hljs-variable">$@</span> is ready&#x27; &#x27; (<span class="hljs-comment">#&#x27;`cat .version`&#x27;)&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，bzImage依赖boot目录下的setup.bin，vmlinux.bin，和boot目录下子目录tools里面的build，这个build是个.c文件</p><p>来一个一个看吧，首先是setup.bin</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 还记得么？subdir-变量会在Makefile.lib中处理为要递归编译的目录</span><br>subdir-:= compressed<br><span class="hljs-comment"># setup变量，x86架构下实模式的代码</span><br>setup-y+= a20.o bioscall.o cmdline.o copy.o cpu.o cpuflags.o cpucheck.o<br>setup-y+= early_serial_console.o edd.o header.o main.o memory.o<br>setup-y+= pm.o pmjump.o printf.o regs.o string.o tty.o video.o<br>setup-y+= video-mode.o version.o<br>setup-<span class="hljs-variable">$(CONFIG_X86_APM_BOOT)</span> += apm.o<br><br><span class="hljs-comment"># The link order of the video-*.o modules can matter.  In particular,</span><br><span class="hljs-comment"># video-vga.o *must* be listed first, followed by video-vesa.o.</span><br><span class="hljs-comment"># Hardware-specific drivers should follow in the order they should be</span><br><span class="hljs-comment"># probed, and video-bios.o should typically be last.</span><br>setup-y+= video-vga.o<br>setup-y+= video-vesa.o<br>setup-y+= video-bios.o<br><br>SETUP_OBJS = <span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> <span class="hljs-variable">$(obj)</span>/,$(setup-y)</span>)<br><br><span class="hljs-comment"># 使用setup.ld为链接脚本，链接实模式的代码</span><br>LDFLAGS_setup.elf:= -m elf_i386 -T<br><span class="hljs-variable">$(obj)</span>/setup.elf: <span class="hljs-variable">$(src)</span>/setup.ld <span class="hljs-variable">$(SETUP_OBJS)</span> FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,ld)</span><br><br><span class="hljs-comment"># 简洁明了，setup.bin就是setup.elf通过objcopy变为二进制文件了</span><br>OBJCOPYFLAGS_setup.bin:= -O binary<br><span class="hljs-variable">$(obj)</span>/setup.bin: <span class="hljs-variable">$(obj)</span>/setup.elf FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,objcopy)</span><br></code></pre></td></tr></table></figure><p>接下来是vmlinux.bin</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJCOPYFLAGS_vmlinux.bin := -O binary -R .note -R .comment -S<br><span class="hljs-variable">$(obj)</span>/vmlinux.bin: <span class="hljs-variable">$(obj)</span>/compressed/vmlinux FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,objcopy)</span><br><br><span class="hljs-variable">$(obj)</span>/compressed/vmlinux: FORCE<br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$(obj)</span>/compressed <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>vmlinux.bin依赖boot&#x2F;compressed目录下的vmlinux，而boot&#x2F;compressed&#x2F;vmlinux则需要使用Makefile.build到compressed目录下去执行boot&#x2F;compressed&#x2F;vmlinux目标，注意，指定目标了哦，不再是__build默认目标了</p><p>现在到compressed目录下，这个目录下也是只有Makefile，没有Kbuild文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 到了compressed目录下，obj变成$(boot)/compressed了哦</span><br><span class="hljs-variable">$(obj)</span>/vmlinux: $(vmlinux-objs-y) $(efi-obj-y) FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,ld)</span><br></code></pre></td></tr></table></figure><p>看到compressed&#x2F;vmlinux依赖vmlinux-objs-y和efi-obj-y，并调用链接工具将其组合为compressed&#x2F;vmlinux</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">vmlinux-objs-y := <span class="hljs-variable">$(obj)</span>/vmlinux.lds <span class="hljs-variable">$(obj)</span>/kernel_info.o <span class="hljs-variable">$(obj)</span>/head_<span class="hljs-variable">$(BITS)</span>.o \<br><span class="hljs-variable">$(obj)</span>/misc.o <span class="hljs-variable">$(obj)</span>/string.o <span class="hljs-variable">$(obj)</span>/cmdline.o <span class="hljs-variable">$(obj)</span>/error.o \<br><span class="hljs-variable">$(obj)</span>/piggy.o <span class="hljs-variable">$(obj)</span>/cpuflags.o<br><span class="hljs-comment"># 还有其他一些vmlinux-objs-y变量，这里不一一列出了</span><br></code></pre></td></tr></table></figure><p>注意一个小细节，vmlinux.lds是放在第一个的，原因是</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile">LDFLAGS_vmlinux := -pie <span class="hljs-variable">$(<span class="hljs-built_in">call</span> ld-option, --no-dynamic-linker)</span><br><span class="hljs-keyword">ifdef</span> CONFIG_LD_ORPHAN_WARN<br>LDFLAGS_vmlinux += --orphan-handling=warn<br><span class="hljs-keyword">endif</span><br>LDFLAGS_vmlinux += -T<br></code></pre></td></tr></table></figure><p>看到最后那个-T了么，LDFLAGS_vmlinux是ld_flags的末尾，其后紧跟着就是要链接的变量，这样-T就能直接跟着vmlinux.lds了，巧妙地指定了压缩目录下的链接脚本</p><p>vmlinux-objs-y里面的目标大多有对应的源文件，直接编译就好，但是需要特别注意以下一个目标——piggy.o，他没有对应的源文件，但是有对应的规则</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">quiet_cmd_mkpiggy = MKPIGGY <span class="hljs-variable">$@</span><br>      cmd_mkpiggy = <span class="hljs-variable">$(obj)</span>/mkpiggy <span class="hljs-variable">$&lt;</span> &gt; <span class="hljs-variable">$@</span><br><br>targets += piggy.S<br><span class="hljs-variable">$(obj)</span>/piggy.S: <span class="hljs-variable">$(obj)</span>/vmlinux.bin.$(suffix-y) <span class="hljs-variable">$(obj)</span>/mkpiggy FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,mkpiggy)</span><br></code></pre></td></tr></table></figure><p>这里依赖的mkpiggy是hostprogs变量，由Makefile.host提前编译好了</p><p>我们发现他的依赖是compressed目录下的vmlinux.bin.$(suffix-y)，这个suffix-y是压缩方式，这里我们用gz格式压缩</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(obj)</span>/vmlinux.bin.gz: $(vmlinux.bin.all-y) FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,gzip)</span><br></code></pre></td></tr></table></figure><p>现在依赖是vmlinux.bin.all-y</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">vmlinux.bin.all-y := <span class="hljs-variable">$(obj)</span>/vmlinux.bin<br></code></pre></td></tr></table></figure><p>注意，这个vmlinux.bin.all-y就是compressed目录下的vmlinux.bin</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJCOPYFLAGS_vmlinux.bin :=  -R .comment -S<br><span class="hljs-variable">$(obj)</span>/vmlinux.bin: vmlinux FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,objcopy)</span><br></code></pre></td></tr></table></figure><p>哦豁，是不是回来了，原来compressed目录下的vmlinux.bin就是根目录下的vmlinux通过objcopy生成的</p><p>现在，所有的依赖都更新了，compressed目录下的vmlinux已经生成，现在我们要返回boot目录下的Makefile文件了</p><p>还记得我们要回到哪里么？</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(obj)</span>/compressed/vmlinux: FORCE<br><span class="hljs-variable">$(Q)</span><span class="hljs-variable">$(MAKE)</span> <span class="hljs-variable">$(build)</span>=<span class="hljs-variable">$(obj)</span>/compressed <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>就是这里，我们现在的compressed&#x2F;vmlinux已经生成，也就是说，它可以通过objcopy变为boot目录下的vmlinux.bin啦</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">OBJCOPYFLAGS_vmlinux.bin := -O binary -R .note -R .comment -S<br><span class="hljs-variable">$(obj)</span>/vmlinux.bin: <span class="hljs-variable">$(obj)</span>/compressed/vmlinux FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,objcopy)</span><br></code></pre></td></tr></table></figure><p>于是，我们的bzImage流程也到了最后</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile">quiet_cmd_image = BUILD   <span class="hljs-variable">$@</span><br>silent_redirect_image = &gt;/dev/null<br>cmd_image = <span class="hljs-variable">$(obj)</span>/tools/build <span class="hljs-variable">$(obj)</span>/setup.bin <span class="hljs-variable">$(obj)</span>/vmlinux.bin \<br>       <span class="hljs-variable">$(obj)</span>/zoffset.h <span class="hljs-variable">$@</span> $(<span class="hljs-variable">$(quiet)</span>redirect_image)<br><br><span class="hljs-variable">$(obj)</span>/bzImage: <span class="hljs-variable">$(obj)</span>/setup.bin <span class="hljs-variable">$(obj)</span>/vmlinux.bin <span class="hljs-variable">$(obj)</span>/tools/build FORCE<br><span class="hljs-variable">$(<span class="hljs-built_in">call</span> if_changed,image)</span><br>@<span class="hljs-variable">$(kecho)</span> &#x27;Kernel: <span class="hljs-variable">$@</span> is ready&#x27; &#x27; (<span class="hljs-comment">#&#x27;`cat .version`&#x27;)&#x27;</span><br></code></pre></td></tr></table></figure><p>这里的$(obj)&#x2F;tools&#x2F;build有对应的.c文件，这个build文件也是在hostprogs里面通过Makefile.host生成的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">hostprogs:= tools/build<br></code></pre></td></tr></table></figure><p>现在，bzImage已经生成，并且在控制台显示出了</p><blockquote><p>‘Kernel: $@ is ready’ ‘ (#’<code>cat .version</code>‘)’</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Kbuild</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Make语言详解</title>
    <link href="/2025/01/01/Make/"/>
    <url>/2025/01/01/Make/</url>
    
    <content type="html"><![CDATA[<h1 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h1><h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><p><code>=</code>：赋值，将右值赋给左值</p><p><code>?=</code>：条件赋值，如果变量没有初始化，就用右边初始化左边</p><p><code>:=</code>：直接赋值，不过展开方式不同</p><p><code>::=</code>：与<code>:=</code>一致</p><p><code>+=</code>：追加赋值</p><p><code>!=</code>：右值为一条shell命令，shell命令的输出赋给左值</p><div class="note note-info">            <p><code>!=</code>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">var != <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span>  <span class="hljs-comment">#此处var的值就是hello</span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">var := <span class="hljs-variable">$&#123;shell echo &quot;hello&quot;&#125;</span> <span class="hljs-comment">#这里的shell是Make的内建函数，表示后面接的参数是shell命令，并且返回该命令的结果</span><br></code></pre></td></tr></table></figure><p>在Makefile中使用<code>$</code>，要用<code>$$</code>表示，shell中用<code>\$</code></p>          </div><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的扩展方式"><a href="#变量的扩展方式" class="headerlink" title="变量的扩展方式"></a>变量的扩展方式</h3><h4 id="简单扩展"><a href="#简单扩展" class="headerlink" title="简单扩展"></a>简单扩展</h4><p>赋值时就确定了变量的值，不管它是否引用了其他变量，<code>:=</code>，<code>::=</code>，<code>!=</code>都是简单扩展</p><h4 id="循环递归扩展"><a href="#循环递归扩展" class="headerlink" title="循环递归扩展"></a>循环递归扩展</h4><p>在赋值时不确定，如果引用了其他变量，make会先确定其他变量，然后再确定该变量，<code>=</code>，<code>?=</code>属于循环变量</p><h4 id="直接扩展"><a href="#直接扩展" class="headerlink" title="直接扩展"></a>直接扩展</h4><p><code>+=</code>属于直接扩展，原变量是啥，左边就是啥</p><h3 id="创建私有变量"><a href="#创建私有变量" class="headerlink" title="创建私有变量"></a>创建私有变量</h3><p>默认是全局变量，若要使用私有变量，使用<code>private</code></p><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>删除变量使用<code>unset</code></p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p><code>$@</code>：表示所有目标</p><p><code>$&lt;</code>：依赖中的第一个依赖</p><p><code>$^</code>：依赖列表中的所有文件</p><p><code>$?</code>：依赖列表中所有更新的文件</p><p><code>$*</code>：在模式中，该变量代表茎，也就是<code>%</code>的部分</p><p><code>~</code>：用户家目录</p><p><code>./</code>：Make的当前目录</p><p><code>@</code>：禁止命令回显</p><p><code>-</code>：出错则忽略，而不是报错退出</p><p><code>+</code>：当<code>make -n</code>时，只有带<code>+</code>号的会执行</p><p><code>@:</code>：占位符，防止<code>make</code>出现<code>Nothing to be done</code></p><div class="note note-info">            <p>变量可以定义在命令行中，会覆盖掉<code>make</code>自带的变量</p><p>override：让make采用Makefile的赋值</p><p>make启动时，所有来自环境的变量都成为make变量</p><p>make会在执行一个规则的命令脚本之前，立刻创建自动变量</p>          </div><h2 id="常用Make变量"><a href="#常用Make变量" class="headerlink" title="常用Make变量"></a>常用Make变量</h2><p><code>VPATH</code>：搜文件的路径</p><p><code>MAKEFLAGS</code>：Make的参数</p><p><code>MAKELEVEL</code>：Make的嵌套层数</p><p><code>MAKECMDGOALS</code>：工作目标的列表</p><p><code>CURDIR</code>：当前工作目录</p><p><code>MAKEFILE_LIST</code>：读取的Makefile列表，最后一个是当前的Makefile</p><p><code>MAKE_VERSION</code>：make的版本</p><p><code>VARIABLES</code>：make从各个Makefile读进的变量列表，不含工作目标</p><h2 id="变量扩展规则"><a href="#变量扩展规则" class="headerlink" title="变量扩展规则"></a>变量扩展规则</h2><ol><li>对于变量赋值，make会立即扩展其左边</li><li>对于<code>=</code>，<code>?=</code>，其右边会被延后到变量使用时进行扩展，在分析依存图时进行</li><li><code>:=</code>的右边会立即被扩展</li><li>如果<code>+=</code>的左边是一个简单变量，<code>+=</code>的右边会被立即扩展，否则，其求值会被延后</li><li>对于宏定义，其宏名会被立即扩展，宏体会被延后扩展</li><li>对于规则，工作目标和依赖总是被立即扩展，命令则总是被延时扩展</li></ol><h2 id="工作目标的专属变量"><a href="#工作目标的专属变量" class="headerlink" title="工作目标的专属变量"></a>工作目标的专属变量</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">target... : variable =, :=, ?=, += value<br></code></pre></td></tr></table></figure><p>专属变量的定义会附加在工作目标之上，且只在该工作目标以及相应的任何必要条件被处理时才会发生作用</p><div class="note note-info">            <p>此类变量的赋值动作会在处理工作目标时进行</p>          </div><h2 id="make参数"><a href="#make参数" class="headerlink" title="make参数"></a>make参数</h2><p><code>-f</code>：指定一个文件作为Makefile</p><p><code>-k</code>：遇到错误不停止，一次发现所有的编译错误</p><p><code>-n</code>：输出将要执行的步骤，而不真的执行</p><p><code>-c</code>：切换到指定目录，执行该目录下的Makefile</p><p><code>-l</code>：指定make去寻找的链接库<code>libName.so</code>或<code>libName.a</code></p><p><code>-s</code>：静默输出</p><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p><code>.PHONY</code>：指示不要将一个目标当作文件来处理</p><div class="note note-info">            <p>伪目标总是最新的</p>          </div><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id=""><a href="#" class="headerlink" title="*"></a>*</h3><p><code>*</code>匹配任何东西，包括空</p><h3 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h3><p>通常在依赖中，匹配所有更新的目标</p><div class="note note-info">            <p>使用通配符本身时，需要使用转义字符<code>\</code></p><p>如果使用<code>OBJ = *.o</code>，一般情况下，会匹配通配符，但是若当前目录下没有可匹配的文件，就会将<code>*.o</code>这个字符串赋给<code>OBJ</code></p>          </div><h3 id="通配符函数"><a href="#通配符函数" class="headerlink" title="通配符函数"></a>通配符函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefie">$&#123;wildcard *.o&#125;<br></code></pre></td></tr></table></figure><p>其好处是，如果没有匹配的文件，那么赋给左边的将是一个空</p><h2 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h2><p>模式规则类似于普通规则，模式规则中包含模式字符<code>%</code>，包含有模式字符<code>%</code>的目标被用来匹配一个文件名，<code>%</code>可以匹配任何非空字符串，依赖中的<code>%</code>取值依赖于目标的<code>%</code></p><h3 id="静态模式规则"><a href="#静态模式规则" class="headerlink" title="静态模式规则"></a>静态模式规则</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">目标...:目标模式:依赖模式</span><br>命令<br>...<br></code></pre></td></tr></table></figure><h3 id="另一种常用语法"><a href="#另一种常用语法" class="headerlink" title="另一种常用语法"></a>另一种常用语法</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">$&#123;OBJ : per-pattern=pattern&#125;<br><br><span class="hljs-section">e.g:</span><br><span class="hljs-section">$&#123;OBJ:%.c = %.o&#125;</span><br></code></pre></td></tr></table></figure><p>将OBJ中所有<code>.c</code>后缀文件替换为<code>.o</code>后缀</p><div class="note note-info">            <p>当模式出现在目标和依赖时，由make进行扩展</p><p>当模式出现在命令中时，由shell进行扩展</p>          </div><h2 id="Makefile的执行顺序"><a href="#Makefile的执行顺序" class="headerlink" title="Makefile的执行顺序"></a>Makefile的执行顺序</h2><ol><li>读入所有的Makefile</li><li>初始化变量</li><li>分析规则，若有显式规则，则加入依赖库，若没有，则分析隐式规则</li><li>根据依赖关系，决定哪些目标需要更新</li><li>执行命令</li></ol><h2 id="命令脚本初始化的顺序"><a href="#命令脚本初始化的顺序" class="headerlink" title="命令脚本初始化的顺序"></a>命令脚本初始化的顺序</h2><ol><li>读取程序代码</li><li>扩展变量</li><li>对make表达式求值</li><li>执行命令</li></ol><div class="note note-info">            <ol><li>命令脚本的求值会被延后的执行的时候</li><li>ifdef的处理会在读入的时候</li><li>在执行之前，首先会看是否有可扩展的变量和可求值的表达式</li><li>宏被扩展时，会为每一行增加tab</li></ol>          </div><h2 id="Make内置函数"><a href="#Make内置函数" class="headerlink" title="Make内置函数"></a>Make内置函数</h2><p>调用方式：<code>$&#123;&lt;function_name&gt; &lt;arguments&gt;&#125;</code>，参数之间以逗号comma分割，函数名和参数之间以空格分割</p><h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h3><h4 id="subst——字符串替换"><a href="#subst——字符串替换" class="headerlink" title="subst——字符串替换"></a>subst——字符串替换</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> &lt;from&gt;, &lt;to&gt;, &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>返回替换过后的字符串</p><h4 id="patsubst——模式字符串替换"><a href="#patsubst——模式字符串替换" class="headerlink" title="patsubst——模式字符串替换"></a>patsubst——模式字符串替换</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>查找<code>text</code>中的单词（以空白符分割）是否符合<code>pattern</code>，如匹配则以<code>replacement</code>替换，如果<code>replacement</code>中含有<code>%</code>，则与<code>pattern</code>中的<code>%</code>含义一致</p><p>返回被替换后的字符串</p><h4 id="strip——去空格函数"><a href="#strip——去空格函数" class="headerlink" title="strip——去空格函数"></a>strip——去空格函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">strip</span> &lt;string&gt;)</span><br></code></pre></td></tr></table></figure><p>去掉<code>string</code>中开头和结尾的空格</p><p>返回去掉首位空格后的字符串</p><h4 id="findstring——查找字符串"><a href="#findstring——查找字符串" class="headerlink" title="findstring——查找字符串"></a>findstring——查找字符串</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">findstring</span> &lt;find&gt;,&lt;in&gt;)</span><br></code></pre></td></tr></table></figure><p>在<code>in</code>中查找<code>find</code>子串</p><p>如果找到，返回<code>find</code>，否则返回空</p><h4 id="filter——过滤函数"><a href="#filter——过滤函数" class="headerlink" title="filter——过滤函数"></a>filter——过滤函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span> &lt;pattern...&gt;, &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>以<code>pattern</code>模式过滤<code>text</code>字符串中的单词，保留符合<code>pattern</code>模式的单词，可以有多个模式</p><p>返回符合<code>pattern</code>模式的子串</p><h4 id="filter-out——反过滤函数"><a href="#filter-out——反过滤函数" class="headerlink" title="filter-out——反过滤函数"></a>filter-out——反过滤函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">filter</span>-out &lt;pattern&gt;, &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>去掉符合<code>pattern</code>模式的子串，可以有多个模式</p><p>返回不符合<code>pattern</code>模式的子串</p><h4 id="sort——排序函数"><a href="#sort——排序函数" class="headerlink" title="sort——排序函数"></a>sort——排序函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">sort</span> &lt;list&gt;)</span><br></code></pre></td></tr></table></figure><p>给<code>list</code>中的单词进行排序（升序），</p><p>返回排序后的字符串，会去掉重复单词</p><h4 id="word——取单词函数"><a href="#word——取单词函数" class="headerlink" title="word——取单词函数"></a>word——取单词函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">word</span> &lt;n&gt;, &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>取字串<code>text</code>中的第<code>n</code>个单词，从1开始</p><p>返回<code>text</code>中的第<code>n</code>个单词，如果<code>n</code>比<code>text</code> 中的单词数大，则返回空</p><h4 id="wordlist——取单词串函数"><a href="#wordlist——取单词串函数" class="headerlink" title="wordlist——取单词串函数"></a>wordlist——取单词串函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">wordlist</span> &lt;ss&gt;, &lt;e&gt;, &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>从<code>text</code>中取从<code>ss</code>到<code>e</code>的单词</p><p>返回子串，若<code>ss</code>比末尾大，返回空</p><h4 id="words——单词个数统计函数"><a href="#words——单词个数统计函数" class="headerlink" title="words——单词个数统计函数"></a>words——单词个数统计函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(words &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>统计<code>text</code>中单词个数</p><p>返回数量</p><h4 id="firstword——首单词函数"><a href="#firstword——首单词函数" class="headerlink" title="firstword——首单词函数"></a>firstword——首单词函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">firstword</span> &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>取<code>text</code>中第一个单词</p><p>返回单词字串</p><h3 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h3><h4 id="dir——取目录函数"><a href="#dir——取目录函数" class="headerlink" title="dir——取目录函数"></a>dir——取目录函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">dir</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><p>从文件名序列中取出目录部分，目录部分是指最后一个<code>/</code>之前的部分，如果没有<code>/</code>，则返回<code>./</code></p><p>返回目录名</p><h4 id="notdir——取文件名函数"><a href="#notdir——取文件名函数" class="headerlink" title="notdir——取文件名函数"></a>notdir——取文件名函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">notdir</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><p>从字符串序列中取出文件名，指最后一个<code>/</code>之后的内容</p><p>返回文件名</p><h4 id="suffix——取后缀函数"><a href="#suffix——取后缀函数" class="headerlink" title="suffix——取后缀函数"></a>suffix——取后缀函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">suffix</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><p>返回后缀，若无后缀返回空</p><h4 id="basename——取前缀函数"><a href="#basename——取前缀函数" class="headerlink" title="basename——取前缀函数"></a>basename——取前缀函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">basename</span> &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><p>返回前缀，若无则返回空</p><h4 id="addsuffix——加后缀函数"><a href="#addsuffix——加后缀函数" class="headerlink" title="addsuffix——加后缀函数"></a>addsuffix——加后缀函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addsuffix</span> &lt;<span class="hljs-built_in">suffix</span>&gt;, &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><p>把后缀<code>suffix</code>加到<code>names</code>的每个单词后面</p><p>返回加了后缀的字符串</p><h4 id="addprefix——加前缀函数"><a href="#addprefix——加前缀函数" class="headerlink" title="addprefix——加前缀函数"></a>addprefix——加前缀函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">addprefix</span> &lt;prefix&gt;, &lt;names...&gt;)</span><br></code></pre></td></tr></table></figure><p>把前缀<code>prefix</code>加到<code>names</code>的每个单词前面</p><p>返回加了前缀的字符串</p><h4 id="join——连接函数"><a href="#join——连接函数" class="headerlink" title="join——连接函数"></a>join——连接函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">join</span> &lt;list1&gt;, &lt;list2&gt;)</span><br></code></pre></td></tr></table></figure><p>将<code>list2</code>对应连接到<code>list1</code>后面，若<code>list1</code>长，<code>list1</code>中多出来的保持原样，<code>list2</code>长，则复制到<code>list1</code>后面</p><p>返回连接后的字符串</p><h4 id="realpath——取真实路径函数"><a href="#realpath——取真实路径函数" class="headerlink" title="realpath——取真实路径函数"></a>realpath——取真实路径函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">realpath</span> names...)</span><br></code></pre></td></tr></table></figure><p>对<code>names</code>中的每个文件名，反会规范的绝对路径，规范名指的是不含<code>.</code>，<code>..</code>，也不包含任何重复路径，分隔符，符号链接</p><p>返回路径，失败返回空</p><h4 id="abspath——取绝对路径"><a href="#abspath——取绝对路径" class="headerlink" title="abspath——取绝对路径"></a>abspath——取绝对路径</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">abspath</span> names...)</span><br></code></pre></td></tr></table></figure><p>对<code>names</code>中的每个文件名，返回一个不含<code>.</code>，<code>..</code>的绝对路径，也不含重复路径，与<code>realpath</code>相比，<code>abspath</code>不解析符号链接，也不要求文件名<code>names</code>引用现有的文件或目录，使用通配符函数来测试函数是否存在，如果目标不存在，也返回绝对地址</p><p>返回绝对地址</p><h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><h4 id="foreach——循环遍历"><a href="#foreach——循环遍历" class="headerlink" title="foreach——循环遍历"></a>foreach——循环遍历</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">foreach</span> &lt;var&gt;, &lt;list&gt;, &lt;text&gt;)</span><br></code></pre></td></tr></table></figure><p>将<code>list</code>中的单词逐个放入<code>var</code>指定的变量中，然后执行<code>text</code>中的表达式，结果放入返回值中</p><div class="note note-info">            <p><code>var</code>是个临时变量，作用域只在<code>foreach</code>里</p>          </div><h4 id="if——条件判断"><a href="#if——条件判断" class="headerlink" title="if——条件判断"></a>if——条件判断</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">if</span> &lt;condition&gt;, &lt;then-part&gt;)</span><br><span class="hljs-variable">$(<span class="hljs-built_in">if</span> &lt;condition&gt;, &lt;then-part&gt;, &lt;else-part&gt;)</span><br></code></pre></td></tr></table></figure><p>判断<code>condition</code>，如果为真，执行<code>then-part</code>，否则，执行<code>else-part</code>（若存在）</p><h4 id="call——调用某函数"><a href="#call——调用某函数" class="headerlink" title="call——调用某函数"></a>call——调用某函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">call</span> &lt;expression&gt;, &lt;param1&gt;, &lt;param2&gt;, ..., &lt;paramn&gt;)</span><br></code></pre></td></tr></table></figure><p>唯一一个可以调用创建的新函数，<code>param*</code>会取代<code>expression</code>中的变量</p><p><code>call</code>处理参数时，第二个及之后的参数会保留空格</p><h4 id="origin——参数来源"><a href="#origin——参数来源" class="headerlink" title="origin——参数来源"></a>origin——参数来源</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">origin</span> &lt;variable&gt;)</span><br></code></pre></td></tr></table></figure><p>判断这个变量来自哪里</p><p>可能的返回值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">undefined   <span class="hljs-comment">#未定义</span><br>default<span class="hljs-comment">#默认</span><br>environment<span class="hljs-comment">#环境变量，且-e没有打开</span><br>file<span class="hljs-comment">#该变量被定义在makefile中</span><br>command line<span class="hljs-comment">#命令行定义</span><br><span class="hljs-keyword">override</span><span class="hljs-comment">#该变量被重写</span><br>automatic<span class="hljs-comment">#该变量是一个自动化变量</span><br></code></pre></td></tr></table></figure><h4 id="shell——运行shell命令"><a href="#shell——运行shell命令" class="headerlink" title="shell——运行shell命令"></a>shell——运行shell命令</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">shell</span> &lt;func&gt; ...)</span><br></code></pre></td></tr></table></figure><p>与’&#96;’相同，其会启动一个子shell，然后运行命令，将结果赋给左边的变量</p><h4 id="error——报错函数"><a href="#error——报错函数" class="headerlink" title="error——报错函数"></a>error——报错函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">error</span> &lt;text...&gt;)</span><br></code></pre></td></tr></table></figure><p>产生一个致命错误，<code>text</code>是其输出信息</p><h4 id="warn——警告函数"><a href="#warn——警告函数" class="headerlink" title="warn——警告函数"></a>warn——警告函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(warn &lt;text...&gt;)</span><br></code></pre></td></tr></table></figure><p>产生一个警告，<code>text</code>是其输出信息</p><h4 id="eval——二次命令"><a href="#eval——二次命令" class="headerlink" title="eval——二次命令"></a>eval——二次命令</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">eval</span> sources:=foo.c bar.c)</span><br></code></pre></td></tr></table></figure><p>将文本直接放入make的解析器中</p><p>简单而言，<code>eval</code>会将后面的求值结果，当作make命令再执行一次</p><h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifdef</span> variable-name<br><span class="hljs-keyword">ifndef</span> variable-name<br></code></pre></td></tr></table></figure><p>执行上述指令时，<code>variable-name</code>不需要用<code>$()</code>包裹</p><div class="note note-info">            <p>条件指令可以用于宏定义和命令脚本中</p>          </div><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> test<br><span class="hljs-keyword">ifneq</span> test<br></code></pre></td></tr></table></figure><p><code>test</code>可以表示为<code>&quot;a&quot;</code> <code>&quot;b&quot;</code>或<code>(a, b)</code></p><div class="note note-info">            <p>这里的<code>test</code>有点微妙，如果采用<code>()</code>的形式，逗号comma后的空格会被忽略，逗号comma之前的会被保留</p>          </div><h2 id="引入指令"><a href="#引入指令" class="headerlink" title="引入指令"></a>引入指令</h2><p>也就是<code>include</code></p><p>引入指令流程：</p><ol><li>当make看到include时，首先对通配符及变量进行扩展，然后试着引入该文件</li><li>如果该文件存在，则流程继续，如果该文件不存在，make产生报告，并继续读取其余Makefile</li><li>当所有读取完成，make会从规则库中找出任何可用来更新引入文件的规则，如果找到了一个相符的规则，就更新工作目标，如果任何一个引入文件规则被更新，make会清除其内部数据，并重新引入该Makefile</li><li>如重复以上流程后，仍有引入文件不存在，则make报错</li></ol>]]></content>
    
    
    <categories>
      
      <category>脚本语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>脚本语言</tag>
      
      <tag>make</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clangd配置</title>
    <link href="/2025/01/01/clangd/"/>
    <url>/2025/01/01/clangd/</url>
    
    <content type="html"><![CDATA[<h1 id="clangd"><a href="#clangd" class="headerlink" title="clangd"></a>clangd</h1><h2 id="安装clangd"><a href="#安装clangd" class="headerlink" title="安装clangd"></a>安装clangd</h2><h3 id="x86-64平台直接下载二进制"><a href="#x86-64平台直接下载二进制" class="headerlink" title="x86-64平台直接下载二进制"></a>x86-64平台直接下载二进制</h3><p>clangd的源码地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">https://github.com/clangd/clangd/tags<br></code></pre></td></tr></table></figure><p>选最新的下载即可</p><p>可以直接下载zip包，然后解压，将bin目录中的clangd放在&#x2F;usr&#x2F;bin&#x2F;下面，将lib目录下面的放在&#x2F;usr&#x2F;lib&#x2F;下面</p><h3 id="其他平台需要自己编译"><a href="#其他平台需要自己编译" class="headerlink" title="其他平台需要自己编译"></a>其他平台需要自己编译</h3><p>llvm-project编译方法：</p><ol><li>git地址</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/llvm/llvm-project.git<br></code></pre></td></tr></table></figure><ol start="2"><li>新建一个目录<code>build</code>，用来存放编译的文件，并进入该目录</li><li>使用cmake进行编译</li></ol><blockquote><p>这里的<code>$LLVM_ROOT</code>是该项目的安装目录</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake $LLVM_ROOT/llvm/ -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra&quot;<br></code></pre></td></tr></table></figure><ol start="4"><li>可以使用ninja来编译，会比make快n倍！！！</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在cmake中增加 -G Ninja</span><br></code></pre></td></tr></table></figure><ol start="5"><li>编译clangd</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake --build $LLVM_ROOT/build --target clangd<br></code></pre></td></tr></table></figure><ol start="6"><li>检查是否编译成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">check-clangd<br></code></pre></td></tr></table></figure><ol start="7"><li>在<code>build/bin</code>中即可发现clangd的二进制</li></ol><h2 id="安装llvm全家桶（仅限debian系）"><a href="#安装llvm全家桶（仅限debian系）" class="headerlink" title="安装llvm全家桶（仅限debian系）"></a>安装llvm全家桶（仅限debian系）</h2><p>添加llvm的官方源，可以从中安装最新的llvm和clang</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">wget https:<span class="hljs-comment">//apt.llvm.org/llvm.sh</span><br>chmod +x llvm.sh<br>sudo ./llvm.sh<br></code></pre></td></tr></table></figure><p>添加了新的软件源后，自由安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt install clang-18 libclang-18-dev<br>sudo apt install clang-format #按你想要安装的版本来，不加版本号的话，看你的发行版默认版本，Ubuntu20.04默认是10，22.04默认是14<br></code></pre></td></tr></table></figure><h2 id="vscode安装clangd插件"><a href="#vscode安装clangd插件" class="headerlink" title="vscode安装clangd插件"></a>vscode安装clangd插件</h2><p>直接在插件中搜索clangd，安装即可</p><p>还可以安装<code>clang-format</code>，也是直接插件安装即可</p><h2 id="配置clangd"><a href="#配置clangd" class="headerlink" title="配置clangd"></a>配置clangd</h2><h3 id="vscode的settings-json"><a href="#vscode的settings-json" class="headerlink" title="vscode的settings.json"></a>vscode的settings.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;files.exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;**/.git&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/.svn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/.hg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/CVS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/.DS_Store&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/Thumbs.db&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/*.a&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/*.o&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/*.cmd&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;**/*.order&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;**/arch/alpha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/arc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/arm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/arm64&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/csky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/h8300&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/hexagon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/ia64&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/m68k&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/microblaze&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/mips&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/nds32&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/nios2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/openrisc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/parisc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/powerpc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/riscv&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/s390&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/sh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/sparc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/um&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/x86&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;**/arch/xtensa&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;search.exclude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;**/node_modules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/bower_components&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/*.code-search&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/alpha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/arc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/arm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/arm64&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/csky&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/h8300&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/hexagon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/ia64&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/m68k&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/microblaze&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/mips&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/nds32&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/nios2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/openrisc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/parisc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/powerpc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/riscv&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/s390&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/sh&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/sparc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/um&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/x86&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;**/arch/xtensa&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;C_Cpp.intelliSenseEngine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;clangd.path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;clangd&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;clangd.arguments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;--pretty&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 输出的 JSON 文件更美观</span><br>                <span class="hljs-string">&quot;--compile-commands-dir=$&#123;workspaceFolder&#125;/&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;--query-driver=$&#123;workspaceFolder&#125;/../toolchains/gcc-chushi-12.2.0-2023.06-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//指定编译器路径</span><br>                <span class="hljs-string">&quot;--log=verbose&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">// 让 Clangd 生成更详细的日志</span><br>                <span class="hljs-string">&quot;--background-index&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//后台分析并保存索引</span><br>             <span class="hljs-string">&quot;--all-scopes-completion&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 全局补全(补全建议会给出在当前作用域不可见的索引,插入后自动补充作用域标识符),例如在main()中直接写cout,即使没有`#include &lt;iostream&gt;`,也会给出`std::cout`的建议,配合&quot;--header-insertion=iwyu&quot;,还可自动插入缺失的头文件</span><br>             <span class="hljs-string">&quot;--clang-tidy&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 启用 Clang-Tidy 以提供「静态检查」</span><br>            <span class="hljs-string">&quot;--clang-tidy-checks=performance-*, bugprone-*, misc-*, google-*, modernize-*, readability-*, portability-*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;--completion-parse=auto&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 当 clangd 准备就绪时，用它来分析建议</span><br>            <span class="hljs-string">&quot;--completion-style=detailed&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 建议风格：打包(重载函数只会给出一个建议);还可以设置为 detailed</span><br>            <span class="hljs-comment">// 启用配置文件(YAML格式)</span><br>        <span class="hljs-string">&quot;--enable-config&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;--fallback-style=Webkit&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 默认格式化风格: 在没找到 .clang-format 文件时采用,可用的有 LLVM, Google, Chromium, Mozilla, Webkit, Microsoft, GNU</span><br>        <span class="hljs-string">&quot;--function-arg-placeholders=true&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 补全函数时，将会给参数提供占位符，键入后按 Tab 可以切换到下一占位符，乃至函数末</span><br>        <span class="hljs-string">&quot;--header-insertion-decorators&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 输入建议中，已包含头文件的项与还未包含头文件的项会以圆点加以区分</span><br>        <span class="hljs-string">&quot;--header-insertion=iwyu&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 插入建议时自动引入头文件 iwyu</span><br>        <span class="hljs-string">&quot;--include-cleaner-stdlib&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 为标准库头文件启用清理功能(不成熟!!!)</span><br>            <span class="hljs-string">&quot;--pch-storage=memory&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// pch 优化的位置(Memory 或 Disk,前者会增加内存开销，但会提升性能)</span><br>            <span class="hljs-string">&quot;--ranking-model=decision_forest&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 建议的排序方案：hueristics (启发式), decision_forest (决策树)</span><br>        <span class="hljs-string">&quot;-j=12&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 同时开启的任务数量</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 找不到编译数据库(compile_flags.json 文件)时使用的编译器选项,这样的缺陷是不能直接索引同一项目的不同文件,只能分析系统头文件、当前文件和被include的文件</span><br>    <span class="hljs-attr">&quot;clangd.fallbackFlags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;-pedantic&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wall&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wextra&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wcast-align&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wdouble-promotion&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wformat=2&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wimplicit-fallthrough&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wmisleading-indentation&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wnon-virtual-dtor&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wnull-dereference&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wold-style-cast&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Woverloaded-virtual&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wpedantic&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wshadow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-Wunused&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-pthread&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-fuse-ld=lld&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-fsanitize=address&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-fsanitize=undefined&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-string">&quot;-stdlib=libc++&quot;</span><br>            <span class="hljs-comment">//这里可以包含额外的头文件路径</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;clangd.checkUpdates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自动检测 clangd 更新</span><br>    <span class="hljs-attr">&quot;clangd.onConfigChanged&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;restart&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 重启 clangd 时重载配置,具体方法: F1 + Fn 打开命令面板，然后搜索“clangd: restart&quot;</span><br>    <span class="hljs-attr">&quot;clangd.serverCompletionRanking&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 借助网上的信息排序建议</span><br>    <span class="hljs-attr">&quot;clangd.detectExtensionConflicts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 当其它拓展与 clangd 冲突时警告并建议禁用</span><br>    <span class="hljs-attr">&quot;editor.suggest.snippetsPreventQuickSuggestions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// clangd的snippets有很多的跳转点，不用这个就必须手动触发Intellisense了</span><br>        <span class="hljs-attr">&quot;editor.formatOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;editor.formatOnType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;editor.formatOnPaste&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;clang-format.executable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clang-format&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;files.associations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;*.h&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;c&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>注意的要点：</p><ol><li>编译时使用bear产生compile_commands.json文件，放在<code>--compile-commands-dir</code>指定的目录中。</li><li>使用cmake时，可以指定<code>cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1</code>来产生compile_commands.json。</li><li>将vscode中的c&#x2F;c++的智能补全禁用掉（或者就不要安装微软的c&#x2F;cpp扩展），即<code>&quot;C_Cpp.intelliSenseEngine&quot;: &quot;disabled&quot;</code></li></ol><h3 id="clangd的config-yaml"><a href="#clangd的config-yaml" class="headerlink" title="clangd的config.yaml"></a>clangd的config.yaml</h3><p>clangd的配置采用YAML格式，包括用户配置（全局）和项目配置</p><p>其中，用户配置在<code>~/.config/clangd/config.yaml</code>里面，项目配置在项目根目录的<code>.clangd</code>中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Diagnostics:</span> <span class="hljs-comment">#诊断</span><br>  <span class="hljs-attr">ClangTidy:</span><br>    <span class="hljs-attr">Add:</span> [<span class="hljs-string">&quot;*&quot;</span>]<br>    <span class="hljs-attr">Remove:</span><br>      [<br>        <span class="hljs-string">abseil*</span>,<br>        <span class="hljs-string">fuchsia*</span>,<br>        <span class="hljs-string">llvmlib*</span>,<br>        <span class="hljs-string">zircon*</span>,<br>        <span class="hljs-string">altera*</span>,<br>        <span class="hljs-string">google-readability-todo</span>,<br>        <span class="hljs-string">readability-braces-around-statements</span>,<br>        <span class="hljs-string">hicpp-braces-around-statements</span>,<br>        <span class="hljs-string">modernize-use-trailing-return-type</span>, <span class="hljs-comment"># 不要每个都加上尾返回值类型</span><br>        <span class="hljs-string">readability-identifier-length</span>, <span class="hljs-comment"># 不检查变量名长度</span><br>        <span class="hljs-string">cppcoreguidelines-avoid-magic-numbers</span>, <span class="hljs-comment"># 不检查魔法数字</span><br>        <span class="hljs-string">readability-magic-numbers</span>, <span class="hljs-comment">#同上</span><br>      ]<br><span class="hljs-attr">Index:</span> <span class="hljs-comment">#索引</span><br>  <span class="hljs-attr">Background:</span> <span class="hljs-string">Build</span><br><span class="hljs-attr">CompileFlags:</span> <span class="hljs-comment"># 编译选项</span><br>  <span class="hljs-attr">Add:</span> [<span class="hljs-string">-std=c++20</span>, <span class="hljs-string">-Wall</span>, <span class="hljs-string">-xc++</span>]<br>  <span class="hljs-comment"># Add里面也可以增加你想要包含的头文件路径</span><br>  <span class="hljs-attr">Compiler:</span> <span class="hljs-string">clang++</span><br></code></pre></td></tr></table></figure><h3 id="clang-format"><a href="#clang-format" class="headerlink" title="clang-format"></a>clang-format</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#基于那个配置文件</span><br><span class="hljs-attr">BasedOnStyle:</span> <span class="hljs-string">Google</span><br><span class="hljs-attr">Language:</span> <span class="hljs-string">Cpp</span><br><span class="hljs-comment"># 标准: Cpp03, Cpp11, Auto</span><br><span class="hljs-attr">Standard:</span> <span class="hljs-string">c++20</span><br><span class="hljs-attr">ColumnLimit:</span> <span class="hljs-number">120</span><br><span class="hljs-attr">BraceWrapping:</span><br>  <span class="hljs-comment"># case标签后面</span><br>  <span class="hljs-attr">AfterCaseLabel:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># class定义后面</span><br>  <span class="hljs-attr">AfterClass:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 控制语句后面</span><br>  <span class="hljs-attr">AfterControlStatement:</span> <span class="hljs-string">Never</span><br>  <span class="hljs-comment"># enum定义后面</span><br>  <span class="hljs-attr">AfterEnum:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 函数定义后面</span><br>  <span class="hljs-attr">AfterFunction:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 命名空间定义后面</span><br>  <span class="hljs-attr">AfterNamespace:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># ObjC定义后面</span><br>  <span class="hljs-attr">AfterObjCDeclaration:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># struct定义后面</span><br>  <span class="hljs-attr">AfterStruct:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># union定义后面</span><br>  <span class="hljs-attr">AfterUnion:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment">#ExternBlock定义后面</span><br>  <span class="hljs-attr">AfterExternBlock:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># catch之前</span><br>  <span class="hljs-attr">BeforeCatch:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># else之前</span><br>  <span class="hljs-attr">BeforeElse:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># lambda块之前</span><br>  <span class="hljs-attr">BeforeLambdaBody:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># while之前</span><br>  <span class="hljs-attr">BeforeWhile:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 缩进大括号</span><br>  <span class="hljs-attr">IndentBraces:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment"># 分割空函数</span><br>  <span class="hljs-attr">SplitEmptyFunction:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 分割空记录</span><br>  <span class="hljs-attr">SplitEmptyRecord:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># 分割空命名空间</span><br>  <span class="hljs-attr">SplitEmptyNamespace:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 在 @property 后面添加空格, \@property (readonly) 而不是 \@property(readonly).</span><br><span class="hljs-attr">ObjCSpaceAfterProperty:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 访问说明符(public、private等)的偏移</span><br><span class="hljs-attr">AccessModifierOffset:</span> <span class="hljs-number">-4</span><br><br><span class="hljs-comment"># 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)</span><br><span class="hljs-attr">AlignAfterOpenBracket:</span> <span class="hljs-string">Align</span><br><span class="hljs-comment"># 连续赋值时，对齐所有等号</span><br><span class="hljs-attr">AlignConsecutiveAssignments:</span> <span class="hljs-string">Consecutive</span><br><span class="hljs-comment"># 连续声明时，对齐所有声明的变量名</span><br><span class="hljs-attr">AlignConsecutiveDeclarations:</span> <span class="hljs-string">Consecutive</span><br><span class="hljs-comment"># 连续宏声明时，对齐空格 #clang-format-10 可用</span><br><span class="hljs-attr">AlignConsecutiveMacros:</span> <span class="hljs-string">Consecutive</span><br><span class="hljs-comment"># 对齐连接符: DontAlign(不对齐)， Left(左对齐), Right(右对齐)</span><br><span class="hljs-attr">AlignEscapedNewlines:</span> <span class="hljs-string">Left</span><br><span class="hljs-comment"># 水平对齐二元和三元表达式的操作数</span><br><span class="hljs-attr">AlignOperands:</span> <span class="hljs-string">Align</span><br><span class="hljs-comment"># 对齐连续的尾随的注释</span><br><span class="hljs-attr">AlignTrailingComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 允许函数调用的所有参数在放在下一行</span><br><span class="hljs-attr">AllowAllArgumentsOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 允许函数声明的所有参数在放在下一行</span><br><span class="hljs-attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 允许短的块放在同一行</span><br><span class="hljs-attr">AllowShortBlocksOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-comment"># 允许短的case标签放在同一行</span><br><span class="hljs-attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 允许短的枚举放在同一行</span><br><span class="hljs-attr">AllowShortEnumsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All</span><br><span class="hljs-attr">AllowShortFunctionsOnASingleLine:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 允许短的if语句保持在同一行</span><br><span class="hljs-attr">AllowShortIfStatementsOnASingleLine:</span> <span class="hljs-string">Never</span><br><span class="hljs-comment"># 允许短的Lambdas语句保持在同一行</span><br><span class="hljs-attr">AllowShortLambdasOnASingleLine:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 允许短的循环保持在同一行</span><br><span class="hljs-attr">AllowShortLoopsOnASingleLine:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 总是在定义返回类型后换行(deprecated)</span><br><span class="hljs-attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数),</span><br><span class="hljs-comment">#   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)</span><br><span class="hljs-attr">AlwaysBreakAfterReturnType:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 总是在多行string字面量前换行</span><br><span class="hljs-attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 总是在template声明后换行</span><br><span class="hljs-attr">AlwaysBreakTemplateDeclarations:</span> <span class="hljs-literal">Yes</span><br><span class="hljs-comment"># false表示函数实参要么都在同一行，要么都各自一行</span><br><span class="hljs-attr">BinPackArguments:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># false表示所有形参要么都在同一行，要么都各自一行</span><br><span class="hljs-attr">BinPackParameters:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效</span><br><span class="hljs-comment"># 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)</span><br><span class="hljs-attr">BreakBeforeBinaryOperators:</span> <span class="hljs-string">NonAssignment</span><br><span class="hljs-comment"># 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似),</span><br><span class="hljs-comment">#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似),</span><br><span class="hljs-comment">#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom</span><br><span class="hljs-comment">#   注：这里认为语句块也属于函数</span><br><span class="hljs-attr">BreakBeforeBraces:</span> <span class="hljs-string">Custom</span><br><span class="hljs-comment"># 在三元运算符前换行</span><br><span class="hljs-attr">BreakBeforeTernaryOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 在构造函数的初始化列表的逗号前换行</span><br><span class="hljs-attr">BreakConstructorInitializersBeforeComma:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">BreakConstructorInitializers:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-comment"># 在类声明继承列表的逗号前换行</span><br><span class="hljs-attr">BreakInheritanceList:</span> <span class="hljs-string">BeforeColon</span><br><span class="hljs-attr">BreakAfterJavaFieldAnnotations:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 允许中断长字符串</span><br><span class="hljs-attr">BreakStringLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变</span><br><span class="hljs-attr">CommentPragmas:</span> <span class="hljs-string">&#x27;^ IWYU pragma:&#x27;</span><br><span class="hljs-comment"># 允许连续的名称空间声明将在同一行</span><br><span class="hljs-attr">CompactNamespaces:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 构造函数的初始化列表的缩进宽度</span><br><span class="hljs-attr">ConstructorInitializerIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-comment"># 延续的行的缩进宽度</span><br><span class="hljs-attr">ContinuationIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-comment"># 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格</span><br><span class="hljs-attr">Cpp11BracedListStyle:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 继承最常用的指针和引用的对齐方式</span><br><span class="hljs-attr">DerivePointerAlignment:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 关闭格式化</span><br><span class="hljs-attr">DisableFormat:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 修饰符后放置空行</span><br><span class="hljs-attr">EmptyLineAfterAccessModifier:</span> <span class="hljs-string">Never</span><br><span class="hljs-comment"># 修饰符前放置空行</span><br><span class="hljs-attr">EmptyLineBeforeAccessModifier:</span> <span class="hljs-string">LogicalBlock</span><br><span class="hljs-comment"># 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)</span><br><span class="hljs-attr">ExperimentalAutoDetectBinPacking:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 修正命名空间注释</span><br><span class="hljs-attr">FixNamespaceComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 需要被解读为foreach循环而不是函数调用的宏</span><br><span class="hljs-attr">ForEachMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">foreach</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Q_FOREACH</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">BOOST_FOREACH</span><br><span class="hljs-comment"># 需要解读为if的函数</span><br><span class="hljs-attr">IfMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">KJ_IF_MAYBE</span><br><span class="hljs-attr">IncludeBlocks:</span> <span class="hljs-string">Regroup</span><br><span class="hljs-comment"># 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，</span><br><span class="hljs-comment">#   可以定义负数优先级从而保证某些#include永远在最前面</span><br><span class="hljs-attr">IncludeCategories:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span> <span class="hljs-string">&#x27;^&lt;ext/.*\.h&gt;&#x27;</span><br>    <span class="hljs-attr">Priority:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">SortPriority:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">CaseSensitive:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span> <span class="hljs-string">&#x27;^&lt;.*\.h&gt;&#x27;</span><br>    <span class="hljs-attr">Priority:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">SortPriority:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">CaseSensitive:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span> <span class="hljs-string">&#x27;^&lt;.*&#x27;</span><br>    <span class="hljs-attr">Priority:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">SortPriority:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">CaseSensitive:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Regex:</span> <span class="hljs-string">&#x27;.*&#x27;</span><br>    <span class="hljs-attr">Priority:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">SortPriority:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">CaseSensitive:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># include块排序</span><br><span class="hljs-attr">IncludeIsMainRegex:</span> <span class="hljs-string">&#x27;([-_](test|unittest))?$&#x27;</span><br><span class="hljs-comment"># 缩进修饰符</span><br><span class="hljs-attr">IndentAccessModifiers:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 缩进case块</span><br><span class="hljs-attr">IndentCaseBlocks:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 缩进case标签</span><br><span class="hljs-attr">IndentCaseLabels:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 缩进goto标签</span><br><span class="hljs-attr">IndentGotoLabels:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 预处理缩进</span><br><span class="hljs-attr">IndentPPDirectives:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 缩进extern块</span><br><span class="hljs-attr">IndentExternBlock:</span> <span class="hljs-string">AfterExternBlock</span><br><span class="hljs-comment"># 缩进宽度</span><br><span class="hljs-attr">IndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-comment"># 函数返回类型换行时，缩进函数声明或函数定义的函数名</span><br><span class="hljs-attr">IndentWrappedFunctionNames:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 添加尾部注释</span><br><span class="hljs-attr">InsertTrailingCommas:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 保留在块开始处的空行</span><br><span class="hljs-attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># Lambda块缩进</span><br><span class="hljs-attr">LambdaBodyIndentation:</span> <span class="hljs-string">Signature</span><br><span class="hljs-comment"># 开始一个块的宏的正则表达式</span><br><span class="hljs-attr">MacroBlockBegin:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment"># 结束一个块的宏的正则表达式</span><br><span class="hljs-attr">MacroBlockEnd:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment"># 连续空行的最大数量</span><br><span class="hljs-attr">MaxEmptyLinesToKeep:</span> <span class="hljs-number">1</span><br><span class="hljs-comment"># 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All</span><br><span class="hljs-attr">NamespaceIndentation:</span> <span class="hljs-string">None</span><br><span class="hljs-comment"># 使用ObjC块时缩进宽度</span><br><span class="hljs-attr">ObjCBlockIndentWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-comment"># 在ObjC的protocol列表前添加一个空格</span><br><span class="hljs-attr">ObjCSpaceBeforeProtocolList:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 使用的包构造函数初始化式样式</span><br><span class="hljs-attr">PackConstructorInitializers:</span> <span class="hljs-string">NextLine</span><br><span class="hljs-comment"># 在call(后对函数调用换行的penalty</span><br><span class="hljs-attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="hljs-number">19</span><br><span class="hljs-comment"># 在一个注释中引入换行的penalty</span><br><span class="hljs-attr">PenaltyBreakComment:</span> <span class="hljs-number">300</span><br><span class="hljs-comment"># 第一次在&lt;&lt;前换行的penalty</span><br><span class="hljs-attr">PenaltyBreakFirstLessLess:</span> <span class="hljs-number">120</span><br><span class="hljs-comment"># 在一个字符串字面量中引入换行的penalty</span><br><span class="hljs-attr">PenaltyBreakString:</span> <span class="hljs-number">1000</span><br><span class="hljs-comment"># 对于每个在行字符数限制之外的字符的penalty</span><br><span class="hljs-attr">PenaltyExcessCharacter:</span> <span class="hljs-number">1000000</span><br><span class="hljs-comment"># 将函数的返回类型放到它自己的行的penalty</span><br><span class="hljs-attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="hljs-number">200</span><br><span class="hljs-comment"># 指针和引用的对齐: Left, Right, Middle</span><br><span class="hljs-attr">PointerAlignment:</span> <span class="hljs-string">Left</span><br><span class="hljs-attr">PPIndentWidth:</span> <span class="hljs-number">-1</span><br><span class="hljs-attr">RawStringFormats:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Language:</span> <span class="hljs-string">Cpp</span><br>    <span class="hljs-attr">Delimiters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cc</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CC</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">cpp</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">Cpp</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CPP</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;c++&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;C++&#x27;</span><br>    <span class="hljs-attr">CanonicalDelimiter:</span> <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-attr">BasedOnStyle:</span> <span class="hljs-string">google</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">Language:</span> <span class="hljs-string">TextProto</span><br>    <span class="hljs-attr">Delimiters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">pb</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PB</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">proto</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PROTO</span><br>    <span class="hljs-attr">EnclosingFunctions:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">EqualsProto</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">EquivToProto</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PARSE_PARTIAL_TEXT_PROTO</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PARSE_TEST_PROTO</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PARSE_TEXT_PROTO</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ParseTextOrDie</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ParseTextProtoOrDie</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ParseTestProto</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ParsePartialTestProto</span><br>    <span class="hljs-attr">CanonicalDelimiter:</span> <span class="hljs-string">pb</span><br>    <span class="hljs-attr">BasedOnStyle:</span> <span class="hljs-string">google</span><br><span class="hljs-comment"># 引用对齐</span><br><span class="hljs-attr">ReferenceAlignment:</span> <span class="hljs-string">Pointer</span><br><span class="hljs-comment"># 允许重新排版注释</span><br><span class="hljs-attr">ReflowComments:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 允许排序#include</span><br><span class="hljs-attr">SortIncludes:</span> <span class="hljs-string">CaseSensitive</span><br><span class="hljs-comment"># 允许排序声明</span><br><span class="hljs-attr">SortUsingDeclarations:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 单独的定义块</span><br><span class="hljs-attr">SeparateDefinitionBlocks:</span> <span class="hljs-string">Always</span><br><span class="hljs-comment"># 在C风格类型转换后添加空格</span><br><span class="hljs-attr">SpaceAfterCStyleCast:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 在赋值运算符之前添加空格</span><br><span class="hljs-attr">SpaceBeforeAssignmentOperators:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 在逻辑非操作符之后插入一个空格</span><br><span class="hljs-attr">SpaceAfterLogicalNot:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 在&#x27; template &#x27;关键字之后会插入一个空格</span><br><span class="hljs-attr">SpaceAfterTemplateKeyword:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 在用于初始化对象的c++ 11带括号的列表之前(在前面的标识符或类型之后)将插入一个空格</span><br><span class="hljs-attr">SpaceBeforeCpp11BracedList:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 构造函数初始化式冒号前的空格将被删除</span><br><span class="hljs-attr">SpaceBeforeCtorInitializerColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 在继承冒号前添加空格</span><br><span class="hljs-attr">SpaceBeforeInheritanceColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 控制括号前的单独空格。</span><br><span class="hljs-attr">SpaceBeforeParens:</span> <span class="hljs-string">ControlStatements</span><br><span class="hljs-comment"># 开圆括号之前添加一个空格</span><br><span class="hljs-attr">SpaceBeforeParensOptions:</span><br>  <span class="hljs-attr">AfterControlStatements:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterForeachMacros:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterFunctionDefinitionName:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">AfterFunctionDeclarationName:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">AfterIfMacros:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">AfterOverloadedOperator:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">BeforeNonEmptyParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 在空的圆括号中添加空格</span><br><span class="hljs-attr">SpaceInEmptyParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 在基于冒号的范围循环之前 添加空格</span><br><span class="hljs-attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 在尾随的评论前添加的空格数(只适用于//)</span><br><span class="hljs-attr">SpacesBeforeTrailingComments:</span> <span class="hljs-number">2</span><br><span class="hljs-comment"># 在尖括号的&lt;后和&gt;前添加空格</span><br><span class="hljs-attr">SpacesInAngles:</span> <span class="hljs-string">Never</span><br><span class="hljs-comment"># 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格</span><br><span class="hljs-attr">SpacesInContainerLiterals:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment"># 在C风格类型转换的括号中添加空格</span><br><span class="hljs-attr">SpacesInCStyleCastParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 在圆括号的(后和)前添加空格</span><br><span class="hljs-attr">SpacesInParentheses:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响</span><br><span class="hljs-attr">SpacesInSquareBrackets:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># tab宽度</span><br><span class="hljs-attr">TabWidth:</span> <span class="hljs-number">4</span><br><span class="hljs-comment"># 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always</span><br><span class="hljs-attr">UseTab:</span> <span class="hljs-string">Always</span><br><span class="hljs-attr">DeriveLineEnding:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">UseCRLF:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">WhitespaceSensitiveMacros:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">STRINGIZE</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">PP_STRINGIZE</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">BOOST_PP_STRINGIZE</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">NS_SWIFT_NAME</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">CF_SWIFT_NAME</span><br><br></code></pre></td></tr></table></figure><h2 id="使用Clang编译linux内核"><a href="#使用Clang编译linux内核" class="headerlink" title="使用Clang编译linux内核"></a>使用Clang编译linux内核</h2><h3 id="直接编译"><a href="#直接编译" class="headerlink" title="直接编译"></a>直接编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make CC=clang defconfig<br>make CC=clang<br></code></pre></td></tr></table></figure><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make CC=clang ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-<br></code></pre></td></tr></table></figure><h2 id="使用LLVM编译"><a href="#使用LLVM编译" class="headerlink" title="使用LLVM编译"></a>使用LLVM编译</h2><h3 id="直接编译-1"><a href="#直接编译-1" class="headerlink" title="直接编译"></a>直接编译</h3><p>编译时指定llvm为编译工具链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make CC=clang LD=ld.lld AR=llvm-ar NM=llvm-nm STRIP=llvm-strip \ OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump READELF=llvm-readelf HOSTCC=clang HOSTCXX=clang++ HOSTAR=llvm-ar HOSTLD=ld.lld<br></code></pre></td></tr></table></figure><p>或者直接使用kbuild的简单编译法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make LLVM=1<br></code></pre></td></tr></table></figure><p>如果你的LLVM工具链不在系统路径里面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make LLVM=/path/to/llvm/<br></code></pre></td></tr></table></figure><p>如果你想直接使用某个版本的LLVM，这将直接使用clang-18等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make LLVM=-18<br></code></pre></td></tr></table></figure><h3 id="交叉编译-1"><a href="#交叉编译-1" class="headerlink" title="交叉编译"></a>交叉编译</h3><p> <code>CROSS_COMPILE</code>用来指定交叉编译器，如果在LLVM中没有指定<code>CROSS_COMPILE</code>，那么会使用<code>ARCH</code>来寻找，即，如果你仅使用LLVM工具，<code>CROSS_COMPILE</code>是不必要的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make ARCH=arm64 LLVM=1<br></code></pre></td></tr></table></figure><p>如果需要禁止clang自身的汇编器，可以使用<code>LLVM_IAS=0</code>，此时的<code>CROSS_COMPILE</code>是不可缺少的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make ARCH=arm64 LLVM=1 LLVM_IAS=0 CROSS_COMPILE=arm64-linux-gnu-<br></code></pre></td></tr></table></figure><h2 id="维护符号链接"><a href="#维护符号链接" class="headerlink" title="维护符号链接"></a>维护符号链接</h2><p>由于使用llvm.sh安装的llvm全家桶只有具体的版本，而不是一个通用的符号链接，因此需要自己维护这个关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 定义要管理的LLVM工具</span><br>llvm_tools=(<br>    <span class="hljs-string">&quot;clang&quot;</span> <span class="hljs-string">&quot;clang++&quot;</span> <span class="hljs-string">&quot;clangd&quot;</span> <span class="hljs-string">&quot;clang-format&quot;</span> <span class="hljs-string">&quot;clang-tidy&quot;</span><br>    <span class="hljs-string">&quot;llvm-ar&quot;</span> <span class="hljs-string">&quot;llvm-as&quot;</span> <span class="hljs-string">&quot;llvm-bcanalyzer&quot;</span> <span class="hljs-string">&quot;llvm-cat&quot;</span> <span class="hljs-string">&quot;llvm-config&quot;</span> <br>    <span class="hljs-string">&quot;llvm-cov&quot;</span> <span class="hljs-string">&quot;llvm-cxxfilt&quot;</span> <span class="hljs-string">&quot;llvm-diff&quot;</span> <span class="hljs-string">&quot;llvm-dis&quot;</span> <span class="hljs-string">&quot;llvm-dwarfdump&quot;</span><br>    <span class="hljs-string">&quot;llvm-extract&quot;</span> <span class="hljs-string">&quot;llvm-link&quot;</span> <span class="hljs-string">&quot;llvm-lto&quot;</span> <span class="hljs-string">&quot;llvm-mc&quot;</span> <span class="hljs-string">&quot;llvm-nm&quot;</span><br>    <span class="hljs-string">&quot;llvm-objcopy&quot;</span> <span class="hljs-string">&quot;llvm-objdump&quot;</span> <span class="hljs-string">&quot;llvm-opt-report&quot;</span> <span class="hljs-string">&quot;llvm-profdata&quot;</span><br>    <span class="hljs-string">&quot;llvm-ranlib&quot;</span> <span class="hljs-string">&quot;llvm-readelf&quot;</span> <span class="hljs-string">&quot;llvm-readobj&quot;</span> <span class="hljs-string">&quot;llvm-rtdyld&quot;</span><br>    <span class="hljs-string">&quot;llvm-size&quot;</span> <span class="hljs-string">&quot;llvm-strings&quot;</span> <span class="hljs-string">&quot;llvm-strip&quot;</span> <span class="hljs-string">&quot;llvm-symbolizer&quot;</span><br>    <span class="hljs-string">&quot;llvm-tblgen&quot;</span> <span class="hljs-string">&quot;lld&quot;</span> <span class="hljs-string">&quot;ld.lld&quot;</span><br>)<br><br><span class="hljs-comment"># 查找最新的LLVM工具</span><br><span class="hljs-function"><span class="hljs-title">find_latest_llvm</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> tool_name=<span class="hljs-variable">$1</span><br>    <span class="hljs-comment"># 使用find命令查找所有的可执行文件</span><br>    <span class="hljs-built_in">local</span> versions=$(find /usr/bin -name <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;tool_name&#125;</span>-*&quot;</span> | grep -oE <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;tool_name&#125;</span>-[0-9\.]+&quot;</span> | <span class="hljs-built_in">sort</span> -V | <span class="hljs-built_in">tail</span> -1)<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/usr/bin/<span class="hljs-variable">$&#123;versions&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 更新update-alternatives</span><br><span class="hljs-function"><span class="hljs-title">update_alternatives</span></span>() &#123;<br>    <span class="hljs-built_in">local</span> tool_name=<span class="hljs-variable">$1</span><br>    <span class="hljs-built_in">local</span> latest_tool_path=$(find_latest_llvm <span class="hljs-variable">$&#123;tool_name&#125;</span>)<br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$latest_tool_path</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;未找到<span class="hljs-variable">$&#123;tool_name&#125;</span>的版本，跳过。&quot;</span><br>        <span class="hljs-built_in">return</span><br>    <span class="hljs-keyword">fi</span><br><br>    <span class="hljs-comment"># 使用update-alternatives进行更新</span><br>    <span class="hljs-built_in">sudo</span> update-alternatives --install /usr/bin/<span class="hljs-variable">$&#123;tool_name&#125;</span> <span class="hljs-variable">$&#123;tool_name&#125;</span> <span class="hljs-variable">$&#123;latest_tool_path&#125;</span> 100<br>    <span class="hljs-built_in">sudo</span> update-alternatives --<span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;tool_name&#125;</span> <span class="hljs-variable">$&#123;latest_tool_path&#125;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;tool_name&#125;</span>已更新为<span class="hljs-variable">$&#123;latest_tool_path&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 遍历所有的LLVM工具并更新</span><br><span class="hljs-keyword">for</span> tool <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;llvm_tools[@]&#125;</span>&quot;</span>; <span class="hljs-keyword">do</span><br>    update_alternatives <span class="hljs-variable">$&#123;tool&#125;</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;所有LLVM工具均已更新完毕。&quot;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>嵌入式</tag>
      
      <tag>工具</tag>
      
      <tag>clangd</tag>
      
      <tag>clang-format</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker安装配置</title>
    <link href="/2025/01/01/docker/"/>
    <url>/2025/01/01/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将清华源放入apt目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -sS https://download.docker.com/linux/debian/gpg | gpg --dearmor &gt; /usr/share/keyrings/docker-ce.gpg<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-ce.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -sc)</span> stable&quot;</span> &gt; /etc/apt/sources.list.d/docker.list<br></code></pre></td></tr></table></figure><p>安装docker ce和docker compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></figure><p>查看是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure><h2 id="配置镜像源"><a href="#配置镜像源" class="headerlink" title="配置镜像源"></a>配置镜像源</h2><p>国内的都屏蔽了，但是俄罗斯好兄弟的可以用QWQ</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /etc/docker<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>        <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span>,<br>        <span class="hljs-string">&quot;https://huecker.io&quot;</span>,<br>        <span class="hljs-string">&quot;https://dockerhub.timeweb.cloud&quot;</span>,<br>        <span class="hljs-string">&quot;https://noohub.ru&quot;</span><br>    ]<br>&#125;<br>EOF<br><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="镜像导入-导出"><a href="#镜像导入-导出" class="headerlink" title="镜像导入&#x2F;导出"></a>镜像导入&#x2F;导出</h2><p>可能你在服务器上不可以直接重启docker服务，那么你可以在本地下载镜像，然后导出为tar包，上传到服务器后，再导入</p><h3 id="从容器导入-导出"><a href="#从容器导入-导出" class="headerlink" title="从容器导入&#x2F;导出"></a>从容器导入&#x2F;导出</h3><p>查看容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps -a<br></code></pre></td></tr></table></figure><p>导出为镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">export</span> 容器ID &gt; image.tar<br></code></pre></td></tr></table></figure><p>导入镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker import 容器名 &lt; image.tar<br></code></pre></td></tr></table></figure><p>查看是否导入成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><h3 id="从镜像导入-导出"><a href="#从镜像导入-导出" class="headerlink" title="从镜像导入&#x2F;导出"></a>从镜像导入&#x2F;导出</h3><p>查看镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><p>导出镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker save 镜像ID &gt; image.tar<br></code></pre></td></tr></table></figure><p>或者一次性导出多个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker save -o images.tar 镜像1 镜像2 ...<br></code></pre></td></tr></table></figure><p>导入镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker load &lt; image.tar<br></code></pre></td></tr></table></figure><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><p>查看镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><p>下载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull 镜像名:tag<br></code></pre></td></tr></table></figure><p>由镜像运行一个容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run [option] <span class="hljs-built_in">command</span> [args]<br><span class="hljs-comment"># -i 交互式shell</span><br><span class="hljs-comment"># -t 启用tty</span><br><span class="hljs-comment"># -d detach，后台运行docker容器</span><br><span class="hljs-comment"># -u 指定用户</span><br><span class="hljs-comment"># -p 用户密码</span><br><span class="hljs-comment"># -v /path/to/host:/path/to/docker:authority 映射主机目录到docker容器目录</span><br><span class="hljs-comment"># --workdir string  指定工作目录</span><br><span class="hljs-comment"># -p 10290:22指定映射的端口</span><br><span class="hljs-comment"># --privileged  是否有特权</span><br></code></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker rmi 镜像名:tag<br></code></pre></td></tr></table></figure><p>重命名镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag IMAGEID REPOSITORY:TAG<br></code></pre></td></tr></table></figure><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><p>查看所有容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><p>进入一个已存在的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span><br></code></pre></td></tr></table></figure><p>启动&#x2F;停止容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start/stop 容器名<br></code></pre></td></tr></table></figure><p>删除容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> 容器名<br></code></pre></td></tr></table></figure><h2 id="vscode远程连接"><a href="#vscode远程连接" class="headerlink" title="vscode远程连接"></a>vscode远程连接</h2><p>首先docker要进行端口映射，然后安装ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">//将宿主机的端口映射到容器中<br>docker run -itd -p 10290:22<br><br>//安装ssh<br>apt-get install openssh-server <br>apt-get install openssh-client <br>apt-get install ssh<br><br><br>//开放ssh端口<br>vim /etc/ssh/sshd_config<br>Port 22<br><br>//开启服务<br>/etc/init.d/ssh restart<br><br>//服务自启动，每次登录start 容器自动打开ssh<br><span class="hljs-comment"># 找到并打开文件/root/.bashrc</span><br>$ vim /root/.bashrc<br><span class="hljs-comment"># 在.bashrc末尾添加如下代码</span><br>$ service ssh start<br><br><br>//在vscode中直接远程连接服务器中打开的docker容器，这样就可以直接在容器的环境中使用vscode插件了，例如clangd<br>//注意给登录用户创建家目录，用于保存vscode缓存<br>ssh -p 10290 镜像中的用户名@服务器地址<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>嵌入式</tag>
      
      <tag>工具</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell语言详解</title>
    <link href="/2025/01/01/shell/"/>
    <url>/2025/01/01/shell/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="变量tips"><a href="#变量tips" class="headerlink" title="变量tips"></a>变量tips</h2><ul><li><p>定义变量时，等号周围不能有空格；</p></li><li><p>定义变量中不能有空格；</p></li><li><p>变量使用时，前面要加$；</p></li><li><p>建议使用变量时将变量用花括号括起来；</p></li><li><p>只读变量可以在变量前加readonly</p><ul><li><pre><code class="language-shell">#!/bin/bashmyUrl=&quot;https://www.google.com&quot;readonly myUrl</code></pre></li></ul></li><li><p>删除变量可以使用unset，变量被删除后不能再次使用，unset不能删除只读变量；</p></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>单引号字符串里任何字符都会原样输出，单引号字符串中变量是无效的；</p></li><li><p>单引号字符串中不能出现单独的一个单引号，加转义字符也不行；</p></li><li><p>双引号里可以有变量；</p></li><li><p>双引号里可以出现转义字符；</p></li><li><p>获取字符串长度<code>string=&quot;abcd&quot;</code> <code>echo $&#123;#string&#125;</code>,即表示变量的<code>$</code>符号后加一个<code>#</code></p></li><li><p>提取子字符串</p><ul><li><pre><code class="language-shell">string=&quot;runoob is a great site&quot;echo $&#123;string:1:4&#125; # 输出 unoo</code></pre></li></ul></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>数组元素间用空格分割；</li><li>取数组元素<code>$&#123;数组名[下标]&#125;</code>；</li><li>取数组所有元素<code>$&#123;数组名[@]&#125;</code>；</li><li>获取数组长度<code>$&#123;#数组名[@]&#125;</code>；</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li><p><code>#</code>表示注释；</p></li><li><pre><code class="language-shell">#多行注释:&lt;&lt;EOF注释内容。。。EOF##或者:&lt;&lt;&#39;...&#39;##或者:&lt;&lt;!...!</code></pre></li></ul><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><ul><li><p>向脚本传递参数，脚本内使用的格式为<code>$n</code>，n代表第几个参数，<code>$1</code>表示第一个参数；</p></li><li><p><code>$0</code>表示执行的文件名，包含文件路径；</p></li><li><p><code>$#</code>表示传递到脚本参数的个数；</p></li><li><p><code>$*</code>以一个单字符串的形式显示所有向脚本传递的参数；</p></li><li><p><code>$$</code>脚本运行的当前进程的ID号；</p></li><li><p><code>$!</code>后台运行的最后一个进程的ID号；</p></li><li><p><code>$@</code>与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数(不是单字符串了)</p><ul><li>如<code>使用&quot;$@&quot;则返回&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code></li></ul></li><li><p><code>$-</code>显示Shell使用的当前选项；</p></li><li><p><code>$?</code>显示最后命令的退出状态；</p></li></ul><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul><li><p>要进行数学运算，需要使用斜点<code>val=expr 2 + 2</code></p></li><li><p>表达式和运算符之间要有空格，这点要区分变量赋值，变量赋值等号周围不能加空格；</p></li><li><p>方括号[ ]等价与test，方括号周边要加空格；</p></li><li><p>乘号前面必须要加反斜杠<code>[ $a \* $b ]</code>；</p></li><li><p>布尔运算：</p><ul><li><code>!</code>取非；</li><li><code>-o</code>取或；</li><li><code>-a</code>取与；</li></ul></li><li><p>逻辑运算：</p><ul><li><code>&amp;&amp;</code>逻辑与；</li><li><code>||</code>逻辑或；</li></ul></li><li><p>字符串运算：</p><ul><li><code>=</code>检查字符串相等；</li><li><code>!=</code>检查字符串不等；</li><li><code>-z</code>检查字符串长度是否为0，为0返回true；</li><li><code>-n</code>检查字符串是否不为0，不为0返回true；</li><li><code>$</code>检测字符串是否为空，不为空返回true；</li></ul></li><li><p>文件测试：</p><ul><li><code>-b file</code>检查文件是否为块设备，是则返回true；</li><li><code>-c file</code>检查文件是否是字符设备，是则返回true；</li><li><code>-d file</code>检查文件是否是目录，是则返回true；</li><li><code>-f file</code>检查文件是否是普通文件，是则返回true；</li><li><code>-g file</code>检查文件是否设置了SGID位，是则返回true；</li><li><code>-k file</code>检查文件是否设置了粘着位sticky bit，是则返回true；</li><li><code>-p file</code>检查文件是否是有名管道，是则返回true；</li><li><code>-u file</code>检查文件是否设置了SUID位，是则返回true；</li><li><code>-r file</code>检查文件是否可读，是则返回true；</li><li><code>-w file</code>检查文件是否可写，是则返回true；</li><li><code>-x file</code>检查文件是否可执行，是则返回true；</li><li><code>-s file</code>检查文件是否为空(文件大小是否大于0)，不为空则返回true；</li><li><code>-e file</code>检测文件(包括目录)是否存在，是则返回true；</li><li><code>-S</code>判断文件是否是socket；</li><li><code>-L</code>检测文件是否存在合并是一个符号链接；</li></ul></li></ul><h2 id="命令行展开"><a href="#命令行展开" class="headerlink" title="命令行展开"></a>命令行展开</h2><p><code>&#123;&#125;</code>会在脚本中展开表达式，<code>..</code>表示递归，第三位表示步长</p><p> 如：</p><p><code>&#123;1..5&#125;</code>展开就是<code>1 2 3 4 5</code></p><p><code>&#123;1..5..2&#125;</code>展开就是<code>1 3 5</code></p><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p><code>alias</code>为某命令产生一个别名</p><p><code>unalias</code>取消这个别名</p><h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><p><code>history</code>会展示之前的历史命令，命令前有编号</p><p><code>&#123;!num&#125;</code>运行history中对应数字的命令</p><p><code>&#123;!!&#125;</code>运行上一条命令</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><code>^</code>表示<code>CTRL</code>键</p><p><code>^A</code>移动光标到行首</p><p><code>^E</code>移动光标到行尾</p><p><code>^U</code>剪切这一行</p><p><code>^K</code>剪切光标之后的所有内容</p><p><code>^Y</code>粘贴之前剪切的内容</p><p><code>^L</code>等同于clear，清屏</p><p><code>^D</code>退出当前程序，正常退出</p><p><code>^C</code>退出当前程序，非正常退出</p><p><code>^Z</code>暂停（挂起）当前程序，并放入后台</p><p><code>^S</code>暂停屏幕输出</p><p><code>^Q</code>恢复屏幕输出</p><p><code>^R</code>在历史命令中搜索</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h4 id="基本正则字符"><a href="#基本正则字符" class="headerlink" title="基本正则字符"></a>基本正则字符</h4><p><code>^</code>：行首</p><p><code>$</code>：行尾</p><p><code>[]</code>：选字，如<code>[abc]</code>则为abc中的任意一个，还可以范围匹配<code>[a-c]</code>，表示abc</p><p><code>*</code>：任意字符，包括空，出现任意次</p><p><code>.</code>：任意一个字符（非换行），有且只有一个</p><h4 id="扩展正则字符"><a href="#扩展正则字符" class="headerlink" title="扩展正则字符"></a>扩展正则字符</h4><p><code>()</code>：分组，被其包裹的部分是一个整体，并获取这个匹配，可以在后面使用</p><p><code>&#123;&#125;</code>：匹配前一个分组的某些次数</p><p><code>?</code>：前一个字符的零次或一次，若前面是一个限制符时，匹配模式是非贪婪的（即尽可能匹配少的字符）</p><p><code>+</code>：前面一个字符的一次及以上</p><p><code>|</code>：表示或者，同时过滤多个字符串</p><p><code>\</code>：转义字符（escape char），跟在其后的，表示其字符本身含义，而不是其正则含义，或者将普通字符转义为特殊字符</p><p><code>\b</code>：匹配一个单词边界，也就是单词和空格间的位置</p><p><code>\B</code>：匹配非单词边界</p><p><code>\cx</code>：匹配由x指明的控制字符，如<code>\cM</code>匹配<code>^M</code>，x必须是字母</p><p><code>\d</code>：匹配一个数字</p><p><code>\D</code>：匹配一个非数字</p><p><code>\f</code>：匹配一个换页符，等价于<code>\x0c</code>和<code>\cL</code></p><p><code>\n</code>：匹配一个换行符，等价于<code>\x0a</code>和<code>\cJ</code></p><p><code>\r</code>：匹配一个回车符，等价于<code>\x0d</code>和<code>\cM</code></p><p><code>\s</code>：匹配一个空白字符，包括空格，制表，换页等</p><p><code>\S</code>：匹配任何非空白符</p><p><code>\t</code>：匹配一个制表符</p><p><code>\v</code>：匹配一个垂直制表符</p><p><code>\w</code>：匹配字母，数字，下划线（如c语言中合法的变量名）</p><p><code>\W</code>：匹配非字母，数字，下划线</p><p><code>\xn</code>：匹配n，其中n是16进制转义值，必须为两个字符</p><p><code>\num</code>：匹配num，其中num是一个正整数，是对所获取的匹配的引用，如<code>(.)\1</code>匹配两个连续的相同字符</p><p><code>\n</code>：n是一个数字，标识一个8进制转义值或一个向后引用。如果<code>\n</code>之前有至少n个获取的子表达式，则n为向后引用，否则，如果n为八进制数字，则n为一个八进制转义值</p><p><code>\nm</code>：n，m都是一个数字，标识一个八进制转义值，或者一个向后引用，最多到99</p><p><code>\nml</code>：匹配八进制数字，如<code>n</code>为<code>0-3</code>，<code>m</code>和<code>l</code>为<code>0-7</code>，则匹配八进制转义值<code>nml</code></p><p><code>\un</code>：匹配n，其中n是四个16进制数字表示的Unicode字符，如<code>\u00A9</code>表示<code>？</code></p><h4 id="组合字符"><a href="#组合字符" class="headerlink" title="组合字符"></a>组合字符</h4><p><code>^$</code>：表示空行（啥也没有）</p><p><code>.*</code>：匹配至少一个的所有内容，没有空</p><p><code>^.*</code>：匹配任意多个字符开头</p><p><code>.*$</code>：匹配任意多个字符结尾</p><p><code>[^abc]</code>：反选，匹配非abc的任意字符</p><p><code>a&#123;n, m&#125;</code>：匹配前一个分组的至少n次，至多m次，如<code>a&#123;1, 3&#125;</code>，匹配 <code>a</code>，<code>aa</code>，<code>aaa</code></p><p><code>a&#123;n, &#125;</code>：匹配前一个分组的至少n次，至多不限</p><p><code>a&#123;, m&#125;</code>：匹配前一个分组的至多m次，至少不限</p><p><code>a&#123;n&#125;</code>：匹配前一个分组正好n次</p><p><code>(?:pattern)</code>：匹配，但不获取这个匹配结果</p><p><code>(?=pattern)</code>：正向肯定预查，在任何匹配pattern的字符串处匹配查找字符串</p><p><code>(?!pattern)</code>：正向否定预查，在任何不匹配pattern的字符串处匹配查找字符串</p><p><code>(?&lt;=pattern)</code>：反向肯定预查，在任何匹配pattern的字符串处匹配查找字符串，方向和正向相反</p><p><code>(?&lt;!pattern)</code>：反向否定预查，在任何不匹配pattern的字符串处匹配查找字符串，方向和正向相反</p><p><code>[]+</code>：方括号内的内容的一次或多次</p><p><code>&lt;&gt;</code>：定位单词的左侧和右侧</p><h4 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h4><p><code>[[:alpha:]]</code>：任何字母</p><p><code>[[:digit:]]</code>：任何数字</p><p><code>[[:alnum:]]</code>：任何字母和数字</p><p><code>[[:space:]]</code>：任何空白字符</p><p><code>[[:upper:]]</code>：任何大写字母</p><p><code>[[:lower:]]</code>：任何小写字母</p><p><code>[[:punct:]]</code>：任何标点符号</p><p><code>[[:xdigit:]]</code>：任何16进制的数字</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>相同优先级的从左到右运算，不同优先级的先高后低</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>\</code></td><td align="center">转义符</td></tr><tr><td align="center"><code>(), (?:), (?=), []</code></td><td align="center">圆括号与方括号</td></tr><tr><td align="center"><code>*, +, ?, &#123;n&#125;, &#123;n,&#125;,&#123;n,m&#125;,&#123;,m&#125;</code></td><td align="center">限定符</td></tr><tr><td align="center"><code>^, $, \任何元字符、任何字符</code></td><td align="center">定位点和序列</td></tr><tr><td align="center">&#96;</td><td align="center">&#96;</td></tr></tbody></table><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p><code>i</code>：忽略大小写</p><p><code>g</code>：全局匹配</p><p><code>m</code>：多行匹配</p><p><code>s</code>：<code>.</code>中包含换行<code>\n</code></p>]]></content>
    
    
    <categories>
      
      <category>脚本语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>脚本语言</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zsh安装配置</title>
    <link href="/2025/01/01/zsh/"/>
    <url>/2025/01/01/zsh/</url>
    
    <content type="html"><![CDATA[<h1 id="zsh配置"><a href="#zsh配置" class="headerlink" title="zsh配置"></a>zsh配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>安装zsh</li></ol><p>debian系：</p><p><code>sudo apt install zsh</code></p><p>arch linux系：</p><p><code>sudo pacman -S zsh</code></p><p>Fedora系：</p><p><code>sudo dnf install zsh</code></p><ol start="2"><li>设置为默认shell</li></ol><p><code>chsh -s /bin/zsh</code></p><ol start="3"><li>安装oh-my-zsh</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)</span>&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>安装p10k</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">github源</span><br>git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k<br><span class="hljs-meta prompt_"># </span><span class="language-bash">国内源</span><br>git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k<br></code></pre></td></tr></table></figure><ol start="5"><li>将p10k设置为默认主题</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sed -i &#x27;/^ZSH_THEME=/c\ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;&#x27; ~/.zshrc<br></code></pre></td></tr></table></figure><ol start="6"><li>配置高亮，自动提示，补全</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting<br>git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br>git clone https://github.com/zsh-users/zsh-completions $ZSH_CUSTOM/plugins/zsh-completions<br></code></pre></td></tr></table></figure><ol start="7"><li>将配置写入.zshrc中</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">! grep -q &quot;autoload -U compinit &amp;&amp; compinit&quot; ~/.zshrc &amp;&amp; echo &quot;autoload -U compinit &amp;&amp; compinit&quot; &gt;&gt; ~/.zshrc<br>sed -i &#x27;/^plugins=/c\plugins=(git sudo z zsh-syntax-highlighting zsh-autosuggestions zsh-completions)&#x27; ~/.zshrc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实用工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>嵌入式</tag>
      
      <tag>工具</tag>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何为社区提交patch</title>
    <link href="/2025/01/01/%E5%A6%82%E4%BD%95%E4%B8%BA%E7%A4%BE%E5%8C%BA%E6%8F%90%E4%BA%A4patch/"/>
    <url>/2025/01/01/%E5%A6%82%E4%BD%95%E4%B8%BA%E7%A4%BE%E5%8C%BA%E6%8F%90%E4%BA%A4patch/</url>
    
    <content type="html"><![CDATA[<h1 id="为Linux社区提交patch"><a href="#为Linux社区提交patch" class="headerlink" title="为Linux社区提交patch"></a>为Linux社区提交patch</h1><h2 id="描述patch更改"><a href="#描述patch更改" class="headerlink" title="描述patch更改"></a>描述patch更改</h2><p><strong>提出问题</strong>：首先阐述你的patch要解决的问题，无论是一行的代码bug修复或者增加5000+行的新特性。</p><p>注意查看优化和平衡，最优往往都是有代价的。</p><p><strong>描述技术细节</strong>：一旦问题建立，那么就需要详细描述你的技术细节。</p><p><strong>每一个patch仅解决一个问题</strong>：当你的patch太长，那么你需要将其分割。</p><p><strong>包含完整的patch描述</strong>：提交patch时，需要包含完整的正当性描述，不要仅仅说这是第几版patch。</p><p><strong>不要仅仅包含一个commit的SHA-1 ID</strong>：如果想要引用一个具体的commit，不要仅仅提供一个SHA-1 ID，也要包含一行commit的总结，来方便reviewer更容易理解。至少包含前12个SHA-1 ID字符，内核中的object相当的多，字符较少时碰撞是大概率的，即使现在没有，也不能保证五年以后~~~</p><p><strong>当你的patch修复了一个指定commit的bug</strong>：使用<code>Fixes:</code>tag加12个字符的SHA-1 ID，还有一行的总结。</p><h2 id="如何分割你的patch"><a href="#如何分割你的patch" class="headerlink" title="如何分割你的patch"></a>如何分割你的patch</h2><p><strong>当你的patch包含一个bug修复和一个性能增强</strong>：将他们分为两个或更多patch。</p><p><strong>如果你新增了一个API，并在另一个文件使用了这个API</strong>：将他们分为两个。</p><p><strong>如果你对多个文件做了同一个更改</strong>：将这些更改作为一个patch即可，因为这是同个逻辑的修改。</p><p><strong>每一个补丁都应该便于理解</strong>：每一个补丁都应该是合理的，并且有他们自己的merits。</p><p><strong>如果一个patch依赖另一个patch</strong>：简单的标记“this patch depends on patch X”即可。</p><p><strong>分割patch时，特别注意内核能否构建和运行</strong>：patch序列中的每一个哦。</p><p><strong>当时实在无法压缩你的patch set</strong>：那么，你可以每次发送15个左右，然后等待review和integration。</p><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p><strong>不检查代码风格是在浪费reviewer的时间</strong>：当然也会导致你的patch被拒绝。</p><p><strong>一种例外</strong>：当你仅仅是移动一段代码从一个文件到另一个地方，那么你的patch应该保持干净，这个patch应该仅有移动的动作。</p><p><strong>代码风格检查脚本</strong>：<code>scripts/checkpatch.pl</code></p><h2 id="选择patch的接受人"><a href="#选择patch的接受人" class="headerlink" title="选择patch的接受人"></a>选择patch的接受人</h2><p><strong>发现MAINTAINERS的脚本</strong>：<code>scripts/get_maintainer.pl</code></p><p><strong>实在找不到MAINTAINERS</strong>：找  Andrew Morton (<a href="mailto:&#x61;&#107;&#112;&#109;&#64;&#x6c;&#105;&#110;&#x75;&#120;&#45;&#102;&#x6f;&#x75;&#110;&#100;&#97;&#116;&#x69;&#x6f;&#x6e;&#46;&#x6f;&#114;&#103;">akpm@linux-foundation.org</a>)</p><p><strong>选择一个邮件列表</strong>：<a href="mailto:&#x6c;&#105;&#110;&#x75;&#120;&#45;&#107;&#x65;&#114;&#110;&#101;&#x6c;&#64;&#118;&#103;&#x65;&#114;&#x2e;&#107;&#x65;&#x72;&#x6e;&#x65;&#x6c;&#x2e;&#x6f;&#114;&#x67;">linux-kernel@vger.kernel.org</a> 是最后的手段（这个内容太多了），通常你应该在MAINTAINERS文件中找特定子系统的邮件列表，你的补丁可以获得更多关注，但是<em>不要向无关的列表发送垃圾邮件</em>。</p><p><strong>不要一次发送超过15个邮件！！！！</strong></p><p><strong>安全相关的patch</strong>：如果你修复了一个安全相关的bug，发送邮件到<a href="mailto:&#115;&#x65;&#99;&#117;&#x72;&#x69;&#116;&#x79;&#x40;&#107;&#101;&#x72;&#x6e;&#101;&#108;&#x2e;&#x6f;&#114;&#x67;">security@kernel.org</a>，修复一个发行版的严重bug时，需要同时抄送到stable maintainers。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cc: stable@vger.kernel.org<br></code></pre></td></tr></table></figure><p><strong>添加Sign-off</strong></p><p><strong>如果你的修改涉及内核用户态</strong>：发送一个man-page patch到MAN-PAGES的MAINTAINERS，或者至少发送一个更改通知，用户空间的API修改也应该备份到<a href="mailto:&#x6c;&#x69;&#x6e;&#x75;&#x78;&#45;&#97;&#112;&#x69;&#x40;&#x76;&#103;&#101;&#x72;&#x2e;&#x6b;&#x65;&#x72;&#x6e;&#101;&#108;&#46;&#111;&#x72;&#103;">linux-api@vger.kernel.org</a>。</p><p><strong>一些琐碎的patch</strong>：也许你可以抄送到Trivial Patch Monkey<a href="mailto:&#116;&#x72;&#x69;&#118;&#105;&#x61;&#108;&#64;&#107;&#x65;&#114;&#110;&#x65;&#108;&#46;&#x6f;&#114;&#x67;">trivial@kernel.org</a>。</p><h2 id="邮件大小"><a href="#邮件大小" class="headerlink" title="邮件大小"></a>邮件大小</h2><p><strong>当你的邮件大小超过300k</strong>：不要将过大的邮件发送到邮件列表和maintainers，超过300k的邮件更好的方法是将你的patch放在服务器上，并且提供一个URL指向你的patch。特别注意：如果你的patch超过300k，几乎可以确定它需要分解。</p><h2 id="响应审查评论"><a href="#响应审查评论" class="headerlink" title="响应审查评论"></a>响应审查评论</h2><p><strong>忽略评审人是一个被评审人忽略的好办法</strong>：不会带来代码更改的评论或问题几乎肯定会带来评论或者日志的更改，以便于下一个评审人更好的理解发生了什么。</p><h2 id="保持耐心"><a href="#保持耐心" class="headerlink" title="保持耐心"></a>保持耐心</h2><p><strong>评审人很忙</strong>：在确保发送到执行位置后，耐心等待至少一周。</p><h2 id="邮件请加-PATCH-前缀"><a href="#邮件请加-PATCH-前缀" class="headerlink" title="邮件请加[PATCH]前缀"></a>邮件请加[PATCH]前缀</h2><p><strong>在补丁邮件前加[PATCH]前缀</strong>：以便于linus和其他内核开发者注意到。</p><h2 id="开发者的个人标识"><a href="#开发者的个人标识" class="headerlink" title="开发者的个人标识"></a>开发者的个人标识</h2><p><strong>在你的补丁中，添加sign-off</strong>：作为你的补丁标识（请使用真实姓名）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Signed-off-by: Random J Developer &lt;random@developer.example.org&gt;<br></code></pre></td></tr></table></figure><p><strong>当你作为一个maintainer</strong>：你有时会需要修改补丁，然后才能将其合入，你可以在提交者的sign-off之下和你的sign-off中间增加一行，指明你修改的特性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Signed-off-by: Random J Developer &lt;random@developer.example.org&gt;<br>[lucky@maintainer.example.org: struct foo moved from foo.c to foo.h]<br>Signed-off-by: Lucky K Maintainer &lt;lucky@maintainer.example.org&gt;<br></code></pre></td></tr></table></figure><p><strong>特殊的向后兼容</strong>：在commit message顶部，Date的下面，增加一个标识</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Date:   Tue Oct 7 07:26:38 2014 -0400<br><br>  libata: Un-break ATA blacklist<br><br>  commit 1c40279960bcd7d52dbdf1d466b20d24b99176c8 upstream.<br></code></pre></td></tr></table></figure><p>或者，一旦补丁向后移植，会出现问题时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Date:   Tue May 13 22:12:27 2008 +0200<br><br>    wireless, airo: waitbusy() won&#x27;t delay<br><br>    [backport of 2.6 commit b7acbdfbd1f277c1eb23f344f899cfa4cd0bf36a]<br></code></pre></td></tr></table></figure><h2 id="一些有用的标识"><a href="#一些有用的标识" class="headerlink" title="一些有用的标识"></a>一些有用的标识</h2><p><strong>Signed-off-by</strong>：谁完成了整个补丁。</p><p><strong>Acked-by</strong>：通常被用来既不贡献也不转发补丁时使用。不像Signed-off-by那样正式，acker至少审查了该patch并表示接受。并且，该标识并不一定表示对整个补丁的确认，例如，如果一个补丁影响多个子系统，那么来自某个子系统maintainer的ack表示仅对该子系统的影响。</p><p><strong>可以通过Cc添加抄送</strong></p><p><strong>Co-Developed-by</strong>：共同开发者，当多人处理单个补丁时，这很有用，注意，此人还要再补丁中具有Signed-off-by</p><p><strong>Reported-by</strong>：发现bug的人。</p><p><strong>Tested-by</strong>：该补丁已经由指定的人员成功测试</p><p><strong>Reviewed-by</strong>：指明该补丁已经被review过并且被接受。</p><p><strong>Suggested-by</strong>：该补丁的想法是由指定的人建议的</p><p><strong>Fixes</strong>：指明该补丁修复了一个bug在前面的commit中</p><h2 id="patch的标准格式"><a href="#patch的标准格式" class="headerlink" title="patch的标准格式"></a>patch的标准格式</h2><p><strong>from</strong>：指定补丁的作者</p><p><strong>补丁正文</strong>：75列换行，将被永久复制到变更日志中以描述此补丁</p><p><strong>一个空行</strong>：</p><p><strong>Signed-off-by</strong>：一行，也会被加入到变更日志中</p><p><strong>—</strong>：标识行，仅包含—，标志变更日志结束，— 标记后面的附加注释的一个很好的用途是用于 diffstat，显示哪些文件已更改，以及每个文件插入和删除的行数。 diffstat 对于较大的补丁特别有用。 其他仅与当前或维护者相关、不适合永久变更日志的评论也应该放在这里。 此类注释的一个很好的例子可能是补丁更改日志，它描述了补丁的 v1 和 v2 版本之间发生的更改。</p><p><strong>任何不适合变更日志的附加评论</strong></p><p><strong>事实上的补丁</strong>：diff的输出</p><hr><p><strong>主题行格式</strong>：使得按主题字母顺序排序变得容易</p><p><strong>标题应声明子系统</strong>：电子邮件主题中的子系统应标识正在修补内核的哪个区域或子系统。</p><p><strong>标题摘要</strong>：简明地描述该邮件包含的补丁，你的标题摘要将成为你的补丁的唯一标识符（可以通过gitk或者git log –oneline来查看）。标题摘要不应该是文件名，不要使用相似的摘要在整个补丁集中。</p><p>基于以上理由，标题摘要必须满足不超过70-75个字符，同时既能描述补丁的change，也能说明补丁的必要性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Subject: [PATCH 001/123] subsystem: summary phrase<br></code></pre></td></tr></table></figure><p><strong>摘要短语可以使用方括号中的标签作为前缀</strong>：标签不视为摘要的一部分，但描述了应该如何处理补丁，如多个版本v1,v2,v3，或者RFC（request for comments）请求评论，多个补丁需要补丁序列，如1&#x2F;4, 2&#x2F;4, 3&#x2F;4, 4&#x2F;4等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Subject: [PATCH &lt;tag&gt;...] &lt;summary phrase&gt;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Subject: [PATCH 2/5] ext2: improve scalability of bitmap searching<br>Subject: [PATCH v2 01/27] x86: fix eflags tracking<br></code></pre></td></tr></table></figure><p><strong>from必须是第一行</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">From: Original Author &lt;author@example.com&gt;<br></code></pre></td></tr></table></figure><p><strong>正文将永远进入到变更日志</strong>：解释正文将致力于永久源代码变更日志，因此对于那些早已忘记了可能导致此补丁的讨论的直接细节的有能力的读者来说应该是有意义的。 包含补丁所解决的故障症状（内核日志消息、oops 消息等）对于可能搜索提交日志以查找适用补丁的人来说特别有用。 如果补丁修复了编译失败，则可能不需要包含所有编译失败； 足以让搜索该补丁的人能够找到它。 正如摘要短语一样，简洁和描述性都很重要。</p><h2 id="拉取请求"><a href="#拉取请求" class="headerlink" title="拉取请求"></a>拉取请求</h2><p><strong>pull</strong>：如果你有一系列的patch，更方便的方法应该是由maintainer去pull你的代码到他的子系统仓库，然而，从邮件列表中pull需要更多的信任度，比起从开发人员那里来说。</p><p>拉取请求的主题行中，应该包含[GIT]或者[PULL]，请求本身应该包含仓库名和分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Please pull from<br><br>    git://jdelvare.pck.nerim.net/jdelvare-2.6 i2c-for-linus<br><br>to get these changes:<br></code></pre></td></tr></table></figure><p>拉取请求还应该包含一条综述，说明请求中包含哪些内容，可以使用git request-pull</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式Linux内核移植两三事</title>
    <link href="/2025/01/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D%E4%B8%A4%E4%B8%89%E4%BA%8B/"/>
    <url>/2025/01/01/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D%E4%B8%A4%E4%B8%89%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式Linux内核移植两三事"><a href="#嵌入式Linux内核移植两三事" class="headerlink" title="嵌入式Linux内核移植两三事"></a>嵌入式Linux内核移植两三事</h1><h2 id="内核源码的来源"><a href="#内核源码的来源" class="headerlink" title="内核源码的来源"></a>内核源码的来源</h2><p>有三种方式：</p><ol><li><code>Linux</code>社区</li><li>芯片原厂（如恩智浦<code>linux-imx</code>）</li><li>板卡厂商（如韬睿<code>toradex</code>）</li></ol><h3 id="Linux社区"><a href="#Linux社区" class="headerlink" title="Linux社区"></a>Linux社区</h3><p>优势：更注重通用性</p><p>劣势：没有对单个具体平台的优化</p><h3 id="芯片原厂"><a href="#芯片原厂" class="headerlink" title="芯片原厂"></a>芯片原厂</h3><p>优势：在社区源码的基础上，针对某款芯片（如<code>imx8qm</code>）做了优化，适配了特定的<code>BSP</code>驱动，而这些驱动可能并还没来得及合入社区主线</p><p>劣势：易用性不足，文档不足</p><h3 id="板卡厂商"><a href="#板卡厂商" class="headerlink" title="板卡厂商"></a>板卡厂商</h3><p>优势：注重用户体验，文档充足</p><p>劣势：封装更好意味着学习者对原理的理解会不足</p><h2 id="内核移植的三个类型"><a href="#内核移植的三个类型" class="headerlink" title="内核移植的三个类型"></a>内核移植的三个类型</h2><h3 id="内核架构移植"><a href="#内核架构移植" class="headerlink" title="内核架构移植"></a>内核架构移植</h3><p>将<code>Linux</code>内核从一种架构（如<code>x86</code>）移植到另一种架构（如<code>ARM</code>等）</p><p>影响范围：通常需要调整内核体系结构相关的代码</p><div class="note note-info">            <p>通常由芯片原厂进行</p>          </div><h4 id="内核体系结构都涉及哪些代码？"><a href="#内核体系结构都涉及哪些代码？" class="headerlink" title="内核体系结构都涉及哪些代码？"></a>内核体系结构都涉及哪些代码？</h4><h3 id="BSP移植"><a href="#BSP移植" class="headerlink" title="BSP移植"></a>BSP移植</h3><h4 id="BSP是什么？"><a href="#BSP是什么？" class="headerlink" title="BSP是什么？"></a>BSP是什么？</h4><p><code>BSP</code>是<code>board support package</code>的缩写，也就是板级支持包，其主要作用是可以将硬件和<code>Linux</code>内核连接起来</p><p>也就是说：<code>BSP</code>提供了<code>Linux</code>内核可以在硬件上跑起来的所有环境，包括设备树，驱动等</p><h4 id="BSP移植的内容"><a href="#BSP移植的内容" class="headerlink" title="BSP移植的内容"></a>BSP移植的内容</h4><p>将<code>Linux</code>内核移植到一个新的开发板或嵌入式设备上</p><p>影响范围：新硬件的驱动，设备树，引导加载程序等</p><div class="note note-info">            <p>通常由板卡厂商来进行</p>          </div><h3 id="平台移植"><a href="#平台移植" class="headerlink" title="平台移植"></a>平台移植</h3><p>将<code>Linux</code>内核从一个特定硬件平台移植到另一个特定硬件平台</p><p>影响范围：设备树文件或配置，外设删减，引脚复用等</p><div class="note note-info">            <p>通常由终端客户进行</p>          </div><h2 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h2><p>嵌入式的板卡，一般除了运行内存<code>RAM</code>之外，还会有焊接在板子上的，称为<code>eMMC</code>的<code>NAND</code>闪存（就是通常意义上的磁盘）</p><p>运行内存的部分特殊区域，会直接映射到<code>eMMC</code>上，当然也会有其他设备的寄存器区域，详细信息需要查看板卡的<code>Reference Manual</code>，其中有一章<code>Memory Map</code>，讲述了内存的布局</p><p>板卡复位后，会从指定的地址（这个地址往往是板卡厂商预设好的）开始执行，也就是<code>bootstrap</code>阶段，这个在传统PC上就是执行<code>BIOS</code>代码的地方，这个阶段会初始化一些基本的硬件组件，比如时钟，<code>DDR(内存)</code>，等，然后检测启动设备，比如从<code>SD</code>卡启动，从<code>eMMC</code>启动等</p><p>以<code>eMMC</code>为例，接着就是读取<code>eMMC</code>中的<code>uboot</code>，<code>uboot</code>负责加载内核镜像和设备树，接着交给内核执行，内核读取根文件系统，启动完成</p><p>通过上面的分析，<code>bootstrap</code>阶段的代码是芯片厂商内置在<code>ROM</code>中的，这个代码不需要我们插手，嵌入式工程师需要关注的有四个部分：</p><ol><li>引导加载器<code>uboot</code></li><li>内核<code>image</code></li><li>设备树<code>dtb</code></li><li>根文件系统<code>ramdisk</code></li></ol><p>其中引导加载器主要负责初始化硬件，然后加载内核，设备树，根文件系统，之后将执行流交给内核（注意，<code>uboot</code>只是加载设备树和根文件到内存中，具体对它们的解析是由内核完成的，<code>uboot</code>只是将其在内存中的地址传给内核）</p><p>内核也就是操作系统本身</p><p>设备树用来告诉内核，你有哪些硬件可以使用，硬件规格是什么</p><p>根文件系统则放置了一些基本的命令，你可以通过根文件系统里面的<code>shell</code>和内核进行交互(没有根文件系统的内核，没有交互可言)</p><div class="note note-light">            <p>发现了么？所谓的启动，至少要有三次，一次是<code>BIOS</code>代码，一次是<code>uboot</code>（服务器上可能是<code>grub</code>等），一次是内核。并且它们都要初始化硬件</p><p>比如<code>BIOS</code>至少要初始化时钟和<code>DDR</code>（没有<code>DDR</code>都没法去执行<code>uboot</code>了，所有的可执行代码都要放在内存上才能执行）</p><p><code>uboot</code>要初始化比如时钟，串口<code>UART</code>，网卡<code>ENET</code>等硬件，然后加载内核</p><p>在内核中，也要初始化硬件，这次是内核要用到的所有硬件（硬件信息从设备树中获取）</p><p>其中内核初始化后的硬件功能最完整，最强大，前面两个阶段的硬件初始化只是为内核打地基（比如<code>uboot</code>不会初始化<code>PCIE</code>相关的硬件，因为<code>uboot</code>用不到）</p>          </div><p>那么，终于回到本章主题，所谓烧录就是指，将上面讨论的那四个组件，写入到嵌入式板卡的持久化存储设备中（常见是<code>eMMC</code>）</p><p>目标定下了，途径也可以是多种多样的，常见的有<code>OTG</code>烧录，网络烧录，<code>SD</code>卡烧录，<code>JTAG</code>烧录等</p><p>现在来考虑，一个裸机的嵌入式板卡，除了固件里面有一段<code>BIOS</code>代码之外，其余什么都没有，而焊接在板卡上的<code>eMMC</code>是块设备，使用它的前提是对块设备进行分区（通常使用<code>fdisk, parted</code>等），并对其分区格式化好某种文件系统（<code>mkfs.vfat, mkfs.ext3</code>等）</p><div class="note note-info">            <p>比如启动分区（内核镜像，设备树等内容所在的分区）一般是<code>FAT32</code><br>根文件系统的分区一般是<code>ext3</code>，<code>ext4</code>等<br>顺便一提，<code>fdisk</code>只能格式化为<code>DOS</code>分区，也就是<code>MBR</code>主引导目录格式</p><p><code>parted</code>可以格式化为<code>GPT</code>分区</p>          </div><p>请注意，格式化磁盘一般是操作系统才有的功能，而嵌入式板子上的<code>eMMC</code>是焊接在板子上的，你也不可能把它取下来，挂载在一个<code>Linux</code>&#x2F;<code>Windows</code>&#x2F;<code>Mac</code>上对其进行格式化，这就需要一些巧妙的方式，接下来我们一一道来。</p><h3 id="OTG烧录"><a href="#OTG烧录" class="headerlink" title="OTG烧录"></a>OTG烧录</h3><p>所谓<code>OTG</code>就是<code>USB On - The - Go(OTG)</code>技术允许设备在没有主机（如计算机）的情况下，直接进行设备间的数据传输。在 OTG 烧录中，通常是将具备 OTG 功能的嵌入式设备与存储有镜像文件的 USB 存储设备（如 U 盘）直接连接，或者与另一台作为烧录主机的设备连接。嵌入式设备通过内置的 OTG 驱动程序识别 USB 存储设备，并从中读取镜像文件，然后按照预设的烧录流程将镜像写入自身的存储介质中。</p><div class="note note-light">            <p><code>OTG</code>需要硬件支持，即：</p><ol><li>开发板需要支持<code>OTG</code></li><li>开发板连接到主机</li><li>主机有<code>OTG</code>驱动程序和相关依赖库</li></ol>          </div><p>一般的操作是：连接开发板，直接将一份镜像（包括<code>uboot</code>，<code>image</code>，<code>dtb</code>，<code>ramdisk</code>）通过<code>OTG</code>放入<strong>嵌入式设备的内存</strong>中，然后启动这个跳转到这个<code>image</code>启动，这样开发板上就有了一个操作系统可用，就可以直接用这个操作系统格式化好<code>eMMC</code>，然后把要烧录进板子的镜像拷贝到<code>eMMC</code>上，就烧录好了，再次启动时，<code>BIOS</code>从<code>eMMC</code>启动，就可以启动拷贝进来的系统了</p><p>格式化<code>eMMC</code>一般会分两个分区，一个<code>boot</code>分区，一个文件系统分区，<code>boot</code>分区中存放内核，设备树，文件系统分区存放根文件系统</p><p>在<code>eMMC</code> 上，<code>uboot</code>所在的分区一般是写保护的，如果你想要写这个分区，需要先打开写保护（把只读关掉）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 这里的boot0就是eMMC特有的启动分区，eMMC的每一个硬件分区都是独立编址的</span><br><span class="hljs-built_in">echo</span> 0 &gt; /sys/block/mmcblkxxxboot0/force_ro<br></code></pre></td></tr></table></figure><p>下面开始拷贝镜像，先是<code>uboot</code>，拷贝到<code>eMMC</code>的<code>boot0</code>分区里面</p><p>然后格式化<code>boot</code>分区，将其格式化为<code>FAT32</code>，挂载该分区，然后放入内核镜像和设备树，卸载该分区</p><p>最后格式化文件系统分区，将其格式化为<code>ext3/4</code>，挂载该分区，然后放入根文件系统，以及可能需要到的内核模块，卸载该分区</p><p>这时，开发板已经烧录好系统了</p><h3 id="SD卡烧录"><a href="#SD卡烧录" class="headerlink" title="SD卡烧录"></a>SD卡烧录</h3><p>首先准备一个<code>SD</code>卡，先将其<code>fdisk</code>进行分区，并将其格式化为<code>FAT32</code>，然后将一个格式化板卡<code>eMMC</code>的镜像（引导固件），和要烧写到板卡上的镜像（烧写在板卡上的操作系统），都拷贝到这个<code>SD</code>卡中</p><p>板卡设定为从<code>SD</code>卡启动，然后会首先去读取<code>uboot</code>，<code>uboot</code>去加载内核和设备树，挂载根文件系统，此时一个操作系统已经启动了，就可以用这个操作系统将要烧写的镜像拷贝到<code>eMMC</code>中了（和上面<code>OTG</code>步骤一样，先格式化<code>eMMC</code>，然后拷贝）</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>Linux内核移植</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
